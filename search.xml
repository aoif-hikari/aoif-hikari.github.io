<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>End-to-end 视频编码框架： DVC 与 M-LVC</title>
    <url>/2021/11/16/DVC/</url>
    <content><![CDATA[<blockquote>
<p>DVC: An End-to-end Deep Video Compression Framework<br>M-LVC: Multiple Frames Prediction for Learned VideoCompression</p>
</blockquote>
<span id="more"></span>
<h2 id="DVC"><a href="#DVC" class="headerlink" title="DVC"></a>DVC</h2><ul>
<li>单参考帧</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_46ff30fd95be45de8b030b6e04d8a96f.png" alt=""></p>
<h3 id="运动估计"><a href="#运动估计" class="headerlink" title="运动估计"></a>运动估计</h3><ul>
<li>使用CNN模型估计光流(运动信息)</li>
</ul>
<p>spynet</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_9c0468d02e7397d0e6f3dc09871ecd26.png" alt=""></p>
<ul>
<li>运动编码网络，auto-encoder结构，压缩光流，量化</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_2de6cc62a832d95b26953a9d25a9c1d1.png" alt=""></p>
<blockquote>
<p>End-to-end Optimized Image Compression (google iclr_17)<br><img src="https://notes.sjtu.edu.cn/uploads/upload_9344269049815a0ddc301862bc90b6bc.png" alt=""><br><img src="https://notes.sjtu.edu.cn/uploads/upload_9bfec99932d669a2230dedf4d4fbf20e.png" alt=""><br>使用了GDN(generalized divisive normalization)进行归一化处理。类似一般CNN网络中的Batch Normalization作用，可以捕捉图像的统计特性，并将其转换为高斯分布。</p>
<p>量化：假设量化区间为1，即为将y量化为它最近的整数</p>
<script type="math/tex; mode=display">
\hat{y}_{i}=q_{i}=\operatorname{round}\left(y_{i}\right)</script><p>$\hat y$ 的边缘密度(离散概率分布)可以表示为</p>
<script type="math/tex; mode=display">
P_{q_{i} }(n)=\int_{n-\frac{1}{2} }^{n+\frac{1}{2} } p_{y_{i} }(t) \mathrm{d} t, \quad \text { for all } n \in \mathbb{Z}</script><p>即 $p_{y_i}(t)$ 是 $y$ 的概率密度函数，由于四舍五入，在某一整数的（-0.5，0.5）区间内都会量化为该整数，则通过积分的形式计算这一区间内的数值的出现概率，得到量化后的整数的出现概率。</p>
<p>优化目标是网络的率失真性能 $R+\lambda D$，损失函数设计为</p>
<script type="math/tex; mode=display">
L\left(g_{a}, g_{s}, P_{q}\right)=-E\left[\log _{2} P_{q}\right]+\lambda E[d(z, \tilde{z})]</script><p>R, is lower-bounded by the entropy of the discrete probability distribution of the quantized vector, $H [P_q]$</p>
<p>涉及到量化问题，但是量化会导致不可微分，阻断反向传播优化。在训练过程中添加（-0.5，0.5）范围的均匀噪声$\tilde{\boldsymbol{y} }=\boldsymbol{y}+\Delta \boldsymbol{y}$<br>即采用这种形式近似可微以用于反向传播的优化。在推理过程中，则依旧使用round 函数进行四舍五入（因为不用进行优化了）。</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_33abb0c4538dfa3a60b30c3ed4200fd9.png" alt=""></p>
</blockquote>
<h3 id="运动补偿"><a href="#运动补偿" class="headerlink" title="运动补偿"></a>运动补偿</h3><p><img src="https://notes.sjtu.edu.cn/uploads/upload_086a9f9ef0f9f6e3cd6cecfa2d486ba1.png" alt=""></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_63e81feb7ecf9972b1a543962cddbb62.png" alt=""></p>
<p>给定前一重建帧 $\hat x_{t-1}$ 和解码的运动矢量 $\hat v_t$，运动补偿网络将获得预测帧 $\bar x_t$。</p>
<p>首先基于运动信息 $\hat v_t$ 将 $\hat x_{t-1}$ warp到当前帧，warp的帧有伪影，所以将warped frame 和 $\hat v_t$，$\hat x_{t-1}$共同作为运动补偿网络输入。</p>
<p>该方法是像素级的运动补偿方法，避免了传统的基于块的运动补偿方法中的块效应，不需要环路滤波模块。</p>
<h3 id="变换、量化"><a href="#变换、量化" class="headerlink" title="变换、量化"></a>变换、量化</h3><ul>
<li>残差编码网络</li>
</ul>
<p>原始帧 $x_t$ 和预测帧 $\bar x_t$ 之间的残差信息 $r_t$ 由残差网络编码</p>
<blockquote>
<p>Variational image compression with a scale hyperprior (google iclr_18)<br><img src="https://notes.sjtu.edu.cn/uploads/upload_d50ec3ca86a40a4252def91730390001.png" alt=""></p>
</blockquote>
<ul>
<li>量化</li>
</ul>
<blockquote>
<p>End-to-end Optimized Image Compression (google iclr_17)</p>
<p>训练阶段通过加入均匀噪声来代替量化运算，推理阶段运动信息和残差直接四舍五入取整量化</p>
</blockquote>
<h3 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h3><ul>
<li>量化运动信息和量化残差编码为比特</li>
<li>使用比特率估算网络获得中每个符号的概率分布，估算比特数成本</li>
</ul>
<blockquote>
<p>Variational image compression with a scale hyperprior (google iclr_18)</p>
</blockquote>
<h2 id="M-LVC"><a href="#M-LVC" class="headerlink" title="M-LVC"></a>M-LVC</h2><ul>
<li>多参考帧</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_988f0dfe898c62afb33b944e3a430dd4.png" alt=""></p>
<h3 id="运动估计与预测"><a href="#运动估计与预测" class="headerlink" title="运动估计与预测"></a>运动估计与预测</h3><ul>
<li>运动估计网络（ME-Net）使用 FlowNet2.0 生成光流MV （$v_t$）</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_2b161a3a6260e3c4c4db1eac99068a7c.png" alt=""></p>
<ul>
<li>采用MV预测网络（MAMVP-Net）来预测当前的MV($\bar v_t$)</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_e276dfa8ed49aa9ed1055da91e0f9bc7.png" alt=""></p>
<p>采用先前多个重构的MV对当前MV进行预测，上面网络图中采用先前三个重构MV进行预测。首先，对先前每个MV进行金字塔特征提取，见（a）</p>
<script type="math/tex; mode=display">
\left\{f_{\hat{v}_{t-i} }^{l} \mid l=0,1,2,3\right\}=H_{m f}\left(\hat{v}_{t-i}\right), i=1,2,3</script><p>其次，考虑到先前重构MV有错误，对抽取的金字塔特征进行warp</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{\hat{v}_{t-3} }^{l, w} &=\operatorname{Warp}\left(f_{\hat{v}_{t-3} }^{l}, \hat{v}_{t-1}^{l}+\operatorname{Warp}\left(\hat{v}_{t-2}^{l}, \hat{v}_{t-1}^{l}\right)\right) \\
f_{\hat{v}_{t-2} }^{l, w} &=\operatorname{Warp}\left(f_{\hat{v}_{t-2} }^{l}, \hat{v}_{t-1}^{l}\right), l=0,1,2,3
\end{aligned}</script><p>再次，利用金字塔网络从粗到细预测当前MV，见(b)。</p>
<ul>
<li><p>使用MVD编码器/解码器网络（google iclr_17）对$v_t$和$\bar v_t$之差$d_t$进行编码</p>
<ul>
<li>$d_t$ -&gt; $m_t$ -&gt; $\hat m_t$</li>
<li>使用google iclr_17中的CNN估计$\hat m_t$的分布，熵编码为比特流</li>
</ul>
</li>
<li><p>由于解码后的$\hat{d}_t$包含量化误差，使用MV优化网络（MV Refine-Net）来减少量化误差并提高质量。将优化后的MV存在解码的MV缓冲器中，用于下一帧编码。</p>
</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_b1d75a450aed0ed8e9cc32f087df4f50.png" alt=""></p>
<h3 id="运动补偿-1"><a href="#运动补偿-1" class="headerlink" title="运动补偿"></a>运动补偿</h3><ul>
<li>重构MV后，使用运动补偿网络（MMC-Net）获得预测帧$\bar x_t$，MMC-Net可以通过使用多个参考帧来生成更准确的预测帧</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_229eb93048d2fae3843cde7a28df12c1.png" alt=""></p>
<h3 id="残差"><a href="#残差" class="headerlink" title="残差"></a>残差</h3><ul>
<li><p>运动补偿后，残差编码网络（google 18_iclr，同DVC）对原始帧$x_t$和预测帧$\bar{x}_t$之间的残差$r_t$进行编码。</p>
<ul>
<li>$r_t$ -&gt; $y_t$ -&gt; $\hat y_t$</li>
<li>使用google 18_iclr中的CNN估计$\hat y_t$的分布，熵编码为比特流</li>
</ul>
</li>
<li><p>解码的$\hat{r}’_t$包含量化误差，因此使用残差优化网络（Residual Refine-Net）来减少量化误差并提高质量。</p>
</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_b771cb5e9d315bc82af335dc4b7c0874.png" alt=""></p>
<h3 id="重建帧"><a href="#重建帧" class="headerlink" title="重建帧"></a>重建帧</h3><ul>
<li>在优化残差后，将加到预测帧上来获得重构帧。然后将重构帧缓存在解码的帧缓冲器中以用于下一帧编码。</li>
</ul>
<h3 id="Training-Strategy"><a href="#Training-Strategy" class="headerlink" title="Training Strategy"></a>Training Strategy</h3><h4 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function."></a>Loss Function.</h4><script type="math/tex; mode=display">
J=D+\lambda R=d\left(x_{t}, \hat{x}_{t}\right)+\lambda\left(R_{m v d}+R_{r e s}\right)</script><ul>
<li>$d(x_{t}, \hat{x}_{t})$ 使用 MSE</li>
<li>$R_{m v d}, R_{r e s}$ 别表示用于编码MVD和残差的比特率。在训练过程中，不进行实际编码，而是根据相应的$\hat{m}_t$和$\hat{y}_t$的熵来估计比特率。分别使用google 17_iclr和google 18_iclr中的CNNs来估计$\hat{m}_t$和$\hat{y}_t$的概率分布，然后得到相应的熵。</li>
<li>训练过程中通过添加均匀噪声来代替量化运算(google 17_iclr)。</li>
</ul>
]]></content>
      <tags>
        <tag>end-to-end</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode / 二分查找</title>
    <url>/2021/10/20/Leetcode%20_%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<blockquote>
<p>有序数组要想到二分查找</p>
</blockquote>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123; <span class="comment">// l = r 处理只有一个元素的情况;如果超时条件改为left &lt; right</span></span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//low+high在low和high特别大时可能溢出，使用减法low + (high - low)/2避免溢出</span></span><br><span class="line">    <span class="keyword">if</span>(target = nums[mid])&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">        left = mid+<span class="number">1</span>; <span class="comment">// 根据题目注意区间开闭</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">        right = mid -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>简单</p>
<blockquote>
<p>374  猜数字大小<br>278  第一个错误的版本</p>
</blockquote>
</li>
<li><p>二分</p>
<blockquote>
<p>35  搜索插入位置<br>34 / 剑指 53 在排序数组中查找元素的第一个和最后一个位置(存在重复元素)(二分+中心扩散)<br>剑指53 - II. 0～n-1中缺失的数字<br>540 有序数组中的单一元素<br>167  两数之和 II - 输入有序数组（二分）</p>
</blockquote>
</li>
<li><p>旋转数组</p>
<blockquote>
<p>189 旋转数组<br>33 搜索旋转排序数组(无重复元素，两个区间必有一个有序)<br>81 搜索旋转排序数组 II(有重复元素，可能出现无法判断哪个区间有序的情况，num[l] = num[mid] = num[r]。解决方法：将当前二分区间的左边界加一，右边界减一。)<br>153 寻找旋转排序数组中的最小值(无重复元素)(几处细节)<br>154 / 剑指11 寻找旋转排序数组中的最小值 II (有重复元素)</p>
</blockquote>
</li>
<li><p>数学</p>
<blockquote>
<p>367  有效的完全平方数<br>69  x 的平方根<br>275  H 指数 II(给定一个大小为 n 的升序的引用次数列表，要求找到满足 citations[i] &gt;= n - i 的第一个 citations[i])<br>441  排列硬币(等价于求满足k(k + 1) &lt;= 2n的k的最大值，二分法可以设置左边界为0，右边界设置为√2n，然后二分查找即可)<br>162  寻找峰值</p>
<pre><code>   /\
  /  \
 /    \
/      \

二分时，取到的 中间值，与 中间值+1 做对比。有2种情况：
中间值 &lt; 中间值+1 ：说明当前取的点，在 上坡 部分，峰顶值在前面
中间值 &gt; 中间值+1 ：说明当前取的点，在 下坡 部分，峰顶值在后面

二分法 第一次 mid 是有2层意义：
第一次 mid 的点，一定会落到一座山上；并判断当前是处在上坡，还是下坡
</code></pre></blockquote>
</li>
</ul>
<p><strong>时间复杂度：$O(logN)$，远好于顺序查找的$O(n)$<br>（虽然二分查找效率高，但是要将表按关键字排序。而排序本身很费时）</strong></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>In-Loop Filter / 融入QP信息的网络</title>
    <url>/2021/10/19/In-Loop_Filter%20_%20%E8%9E%8D%E5%85%A5QP%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<blockquote>
<p>两篇paper<br>A QP-ADAPTIVE MECHANISM FOR CNN-BASED FILTER IN VIDEO CODING<br>One-for-all: An Efﬁcient Variable Convolution Neural Network for In-loop Filter of VVC</p>
</blockquote>
<span id="more"></span>
<ul>
<li>不同量化参数（QP）压缩的视频，其压缩噪声水平不同</li>
<li>不同的帧类型（FT），压缩噪声水平不同。</li>
<li>为单个QP/QP段或FT训练模型，消耗大量的资源训练大量模型，增加了视频编解码器的内存负担</li>
<li>A practical convolutional neural network as loop filter for intra frame: QPmap</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_23b54651e201bcbc4be324893286ff33.png" alt=""></p>
<ul>
<li>$\hat{\boldsymbol{y} }=\boldsymbol{w} *\{\boldsymbol{y} ; Q P\}+\boldsymbol{b}$</li>
</ul>
<ul>
<li><script type="math/tex; mode=display">
  \begin{aligned} \hat{\boldsymbol{y} } &=\boldsymbol{w}_{1} * \boldsymbol{y}+\boldsymbol{w}_{2} * Q P+\boldsymbol{b} \\ &=\boldsymbol{w}_{1} * \boldsymbol{y}+\left(\Sigma \boldsymbol{w}_{2} \cdot Q P+\boldsymbol{b}\right) \\ &=\boldsymbol{w}_{1} * \boldsymbol{y}+\boldsymbol{b}^{\prime}(Q P) \end{aligned}</script></li>
<li><p>$\boldsymbol{b}^{\prime}(Q P)=\Sigma \boldsymbol{w}_{2} \cdot Q P+\boldsymbol{b}$</p>
</li>
<li>QP被添加到线性函数的偏置上，没有反应出QP和滤波强度(权重)的关系，且只有第一层引入了QP信息</li>
<li>QPmap不如QP-Separate/QP-Band models</li>
</ul>
<h2 id="A-QP-ADAPTIVE-MECHANISM-FOR-CNN-BASED-FILTER-IN-VIDEO-CODING"><a href="#A-QP-ADAPTIVE-MECHANISM-FOR-CNN-BASED-FILTER-IN-VIDEO-CODING" class="headerlink" title="A QP-ADAPTIVE MECHANISM FOR CNN-BASED FILTER IN VIDEO CODING"></a>A QP-ADAPTIVE MECHANISM FOR CNN-BASED FILTER IN VIDEO CODING</h2><h3 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h3><p>（忽略偏置bias）<br>时域卷积：$\boldsymbol{w} * \boldsymbol{y}=\hat{\boldsymbol{x } }$<br>频域乘积：$\mathcal{F}(\boldsymbol{w}) \mathcal{F}(\boldsymbol{y})=\mathcal{F}(\hat{\boldsymbol{x} })$<br>$\mathcal{F}(\hat{\boldsymbol{x} }) \approx \mathcal{F}(\boldsymbol{x})$</p>
<p>QP增加导致Qstep增加，引入噪声$\epsilon$</p>
<p>$\boldsymbol{w}^{\prime} *(\boldsymbol{y}+\boldsymbol{\epsilon})=\hat{\boldsymbol{x} }^{\prime}$</p>
<p>$\mathcal{F}\left(\boldsymbol{w}^{\prime}\right)(\mathcal{F}(\boldsymbol{y})+\mathcal{F}(\boldsymbol{\epsilon}))=\mathcal{F}\left(\hat{\boldsymbol{x} }^{\prime}\right)$</p>
<p>loss fuc：MSE</p>
<p>$\mathcal{L}=\mathbb{E}\left|\boldsymbol{x}-\hat{\boldsymbol{x} }^{\prime}\right|^{2}$</p>
<p>Parseval’s theorem</p>
<p>$\begin{aligned} \mathcal{L} &amp;=\mathbb{E}\left|\mathcal{F}(\boldsymbol{x})-\mathcal{F}\left(\hat{\boldsymbol{x} }^{\prime}\right)\right|^{2} \\ &amp;=\mathbb{E}\left|\mathcal{F}(\boldsymbol{x})-\mathcal{F}\left(\boldsymbol{w}^{\prime}\right)(\mathcal{F}(\boldsymbol{y})+\mathcal{F}(\boldsymbol{\epsilon}))\right|^{2} \\ &amp; \approx \mathbb{E}\left|\mathcal{F}(\boldsymbol{x})-\mathcal{F}\left(\boldsymbol{w}^{\prime}\right)[\mathcal{F}(\boldsymbol{x}) / \mathcal{F}(\boldsymbol{w})+\mathcal{F}(\boldsymbol{\epsilon})]\right|^{2} \end{aligned}$</p>
<script type="math/tex; mode=display">
\mathcal{F}\left(\boldsymbol{w}^{\prime}\right)=\underbrace{\mathcal{F}(\boldsymbol{w})}_{\text {org. filter } } \underbrace{\left[\frac{1}{1+|\mathcal{F}(\boldsymbol{w})|^{2} \mathcal{F}(\boldsymbol{n}) / \mathcal{F}(\boldsymbol{s})}\right]}_{\text {influence factor } }</script><script type="math/tex; mode=display">
\mathcal{F}(\boldsymbol{n})=\mathbb{E}|\mathcal{F}(\boldsymbol{\epsilon})|^{2} \text { and } \mathcal{F}(\boldsymbol{s})=\mathbb{E}|\mathcal{F}(\boldsymbol{x})|^{2}</script><p>similar to Wiener deconvolution</p>
<ul>
<li>Wiener deconvolution：recover the original signal from the distorted signal by using the priors of the input signal, noise, and degradation function</li>
<li>this solution：aims at making a speciﬁc ﬁlter adaptive to the changing quantization noise.</li>
</ul>
<h3 id="应用于CNN"><a href="#应用于CNN" class="headerlink" title="应用于CNN"></a>应用于CNN</h3><p>从频域的角度来看，从CNN中提取的特征对应于输入图像在不同频率上的选择<br>作用在整个频带上的 $\boldsymbol{w}^{\prime}$ 可以被分解成作用在特定频带上的子滤波器 $w_{i}^{\prime}$ </p>
<p>上式可写为</p>
<p>$\begin{aligned} \mathcal{F}\left(\boldsymbol{w}^{\prime}\right) &amp;=\sum_{i} \mathcal{F}\left(w_{i}^{\prime}\right) \\ &amp;=\sum_{i} \mathcal{F}\left(w_{i}\right)\left[\frac{1}{1+\left|\mathcal{F}\left(w_{i}\right)\right|^{2} \mathcal{F}\left(n_{i}\right) / \mathcal{F}\left(s_{i}\right)}\right] \end{aligned}$</p>
<p>第一项 $\mathcal{F}\left(w_{i}\right)$ 等价于CNN中的卷积核<br>第二项表示每个卷积核的 influence factor ，可以看作作用在特定子频带上</p>
<p>$\left|\mathcal{F}\left(w_{i}\right)\right|^{2} / \mathcal{F}\left(s_{i}\right)$ : 假设子带中$\left|\mathcal{F}\left(w_{i}\right)\right|^{2}$ 是常数，原始信号强度$\mathcal{F}\left(s_{i}\right)$ is also invariable in the task of adapting to different quantization noises，整体是常数 $k_i$</p>
<p>量化噪声强度 $\mathcal{F}(\boldsymbol{n})$ ：默认编码配置下，在所有频率上都与量化步长Qstep的平方成正比<br>分解子噪声 $\mathcal{F}\left(n_{i}\right)$载特定频率上与量化步长Qstep的平方成正比</p>
<script type="math/tex; mode=display">
\frac{\left|\mathcal{F}\left(w_{i}\right)\right|^{2} }{\mathcal{F}\left(s_{i}\right)} \mathcal{F}\left(n_{i}\right) \approx k_{i} \mathcal{F}\left(n_{i}\right) \propto Q_{s t e p}^{2}</script><p>trainable parameters θ  to represent the proportional relation- ship，then</p>
<script type="math/tex; mode=display">
\mathcal{F}\left(\boldsymbol{w}^{\prime}\right) \approx \sum_{i} \mathcal{F}\left(w_{i}\right)\left[\frac{1}{1+\theta_{i} Q_{\text {step } }^{2} }\right]</script><p>N ： the number of feature maps of CNN<br>number of parameters introduced by this method: $O\left(N^{2}\right)$, the same order as the number of the kernels</p>
<p>Inspired by DSC (depthwise convolution instead of standard con- volution), we apply the inﬂuence factor to the feature maps instead of the convolution kernels.</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_325bde70ed8996168a743bc8d95c7486.png" alt=""></p>
<p>parameter quantity becomes $O\left(N\right)$, same order as the number of the biases (the QP map method).</p>
<ul>
<li>Qstep 的调整</li>
</ul>
<p>VVC/HEVC: </p>
<p>$Q_{s t e p}=2^{(Q P-4) / 6}$，$Q_{s t e p}^{2}=2^{(Q P-4) / 3}$</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_18abe3cdcfd7d251d18cd079de1c589f.png" alt=""></p>
<ul>
<li>$\theta_{i}$ 不能小于等于 0</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_e196c8ad1d5122ceeaac174effc64d46.png" alt=""></p>
<p>选择第二种直接截断的方法</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ul>
<li>把这种方法应用到已经提出的这4个CNN上</li>
<li>网络加在DB和SAO之间，因为经过CNN增强后SAO ALF可能能节省一些比特</li>
<li>CNN-被集成到 VTM-6.3</li>
<li>DIV2K数据集，四个QPs包括22、27、32和37，测试用HEVC测试序列的第1帧</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_ed4a0a5646ca0cd4756c91f010e60835.png" alt="只用luma训练模型，同时也能提升色度分量"></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_305e44ab52fc39a81220ffd583e71115.png" alt="解码复杂度"></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_15537338f437af0ddd716b8eda252373.png" alt="与QPmap方法的对比"></p>
<h2 id="One-for-all-An-Efﬁcient-Variable-Convolution-Neural-Network-for-In-loop-Filter-of-VVC"><a href="#One-for-all-An-Efﬁcient-Variable-Convolution-Neural-Network-for-In-loop-Filter-of-VVC" class="headerlink" title="One-for-all:  An  Efﬁcient  Variable  Convolution Neural  Network  for  In-loop  Filter  of  VVC"></a>One-for-all:  An  Efﬁcient  Variable  Convolution Neural  Network  for  In-loop  Filter  of  VVC</h2><ul>
<li>注意力模块 </li>
</ul>
<p>给定离散值$x$，$x∈ Ω = [a, b]$, one-hot encoding 得向量</p>
<p>$\mathbf{v}_{\Omega}(x) \in \mathbb{R}^{m \times 1}$</p>
<p>$U \in \mathbb{R}^{C \times m}$ is a weight matrix</p>
<p>$\mathbf{M}=\sigma\left(U \mathbf{v}_{\Omega}(x)\right)$</p>
<p>$\sigma(x)=\log \left(1+e^{x}\right)$</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_19cb97506db4a38e75b34b4ead57da6a.png" alt=""></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_1ba48a0e32c2c84df6564fba3d7bae0b.png" alt=""></p>
<p>$I(x)=\left\{\begin{array}{l}0, \quad x \in[0, L] \\ 1+\left\lfloor\frac{x-L}{r}\right\rfloor, \quad x \in[L+1, R-1] \\ 1+\left\lfloor\frac{R-L}{r}\right\rfloor, \quad x \in[R, 63]\end{array}\right.$</p>
<p>x is QP value<br>I (x) is the index of the single high 1 bit<br>L = 20, R = 45 and r = 3. </p>
<p>the shape of U is changed from (64, C ) to (10, C )</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_9ef4aa964eb4b2d8e738dd4efb6acfce.png" alt=""></p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><img src="https://notes.sjtu.edu.cn/uploads/upload_ed6f1b8343f0262e86f409df04379a20.png" alt=""></p>
<ul>
<li>CTU and frame-level RDO</li>
<li>N = 1, D = 6,  3 × 3 convolutions C = 64</li>
<li>DIV2K, All-intra conﬁguration with QP randomly selected from [21, 41]</li>
<li>40 videos of various resolutions (3840 × 2160, 1920 × 1080, 1280 × 720, 640 × 360), encoded under Low-delay P and Random-Access conﬁg- urations at QP=22, 27, 32, and 37. select one frame per ﬁve </li>
<li>64 × 64 non-overlapping, remove the sub-images whose PSNR are more than 50.0 or less than 20.0</li>
<li>Only use the Y-channel for training</li>
</ul>
<ul>
<li><p>训练 patch 分布不均匀，修改 loss func 为 focal MSE</p>
<blockquote>
<p>疑问：为何不直接构造分布均匀的数据集？</p>
</blockquote>
<p>  <img src="https://notes.sjtu.edu.cn/uploads/upload_143d74670a6ed6c8f5e87a0abcd55450.png" alt=""></p>
<ul>
<li>首先用MSE训练一个VCNN，验证集计算增益率R<ul>
<li>$R=1-\frac{l_{\text {rec } } }{l_{\text {init } } }$</li>
<li>$l_{\text {init } }=|\mathbf{Y}-\mathbf{X}|^{2}$ and $l_{r e c}=|\hat{\mathbf{Y} }-\mathbf{Y}|^{2}$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_e6838d51215601199e4c4b24c1221660.png" alt=""></p>
<p>有以下结论：</p>
<ul>
<li>该网络在相对小QP上表现较好，而在较大QP上，如QP∈[42,44]，表现并不理想。</li>
<li>该网络在I帧上取得了最佳性能，在P和B帧上表现类似。</li>
<li>大多数有效数据的增益率低于10%，也就是说，增益率低的数据占了很大比例。所以期望网络能更多地关注具有低增益率的数据。</li>
</ul>
<h4 id="focal-MSE"><a href="#focal-MSE" class="headerlink" title="focal MSE"></a>focal MSE</h4><p>$\begin{aligned} L &amp;=\frac{1}{N} \sum_{i=1}^{N}\left(\alpha_{q}^{(i)}+\alpha_{f}^{(i)}\right)\left(1-R^{(i)}\right)^{\gamma} l_{r e c}^{(i)} \\ &amp;=\frac{1}{N} \sum_{i=1}^{N}\left(\alpha_{q}^{(i)}+\alpha_{f}^{(i)}\right) \frac{l_{\text {rec } }^{(i)^{1+\gamma} } }{l_{\text {init } }^{(i) } } \end{aligned}$</p>
<p>$\alpha_q$ : weighting factor over QP band<br>$\alpha_f$ : weighting factor over FT<br>$\gamma$ : focusing parameter</p>
<ul>
<li>ﬁrst utilize the following formula to adjust $\alpha_q$ $\alpha_f$ for each QP band and FT: $\alpha(t)=\frac{n \times(1-p(t))}{n-1}$<ul>
<li>$n$ : the number of total types, i.e. n = 10 for QP and n = 3 for FT, </li>
<li>$p(t)$ : the proportion of the data with type t. </li>
</ul>
</li>
<li>then increase α(t) of type t where the network performs poorly.</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_9b8235398f6d52404211def555c08153.png" alt=""></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_57666646d6769dbb18f9715cd57159a1.png" alt=""></p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul>
<li>BD-rate</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_2c88d6044b40b0ec1dddcbde15b5539e.png" alt=""></p>
<p>VCNN-S: separate qp model, without attention<br>VCNN-M: QPmap method</p>
<ul>
<li>Quality ﬂuctuation</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_6462317026173b9ea3376d51739f28ad.png" alt=""></p>
<ul>
<li>消融实验<ul>
<li>网络结构：复杂度和性能可以进一步权衡</li>
<li>1）VCN-C32：C=32，D=6，N=1。</li>
<li>2）VCN-D3：C=32，D=3，N=1。</li>
<li>3）VCN-N3：C=64，D=6，N=3。</li>
<li>4）VCNN：C=64，D=6，N=1</li>
</ul>
</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_c21fba20db9589b896b735b543afb452.png" alt=""></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_29ca327de24ba74d082f4c45e5780c40.png" alt=""></p>
<ul>
<li>注意力模块</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_494e75bd6f31305c6cd665d6873d3150.png" alt=""></p>
<p>1) separate：网络结构与VCN-S相同，为每个QP段和FT分别训练，共4×3=12个<br>2) FT：为每个QP段单独训练模型，共4个<br>3) QP：为每个FT单独训练，共3<br>4) FT + QP：VCNN，1个模型</p>
<p>从数据集中随机选择1/5的数据来训练</p>
<blockquote>
<p>疑问：为何 separate 表现最差？理论上separate应该表现最好</p>
</blockquote>
<ul>
<li>focal MSE</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_b7a6d06a0bcf37593311c8d8b71c8616.png" alt=""></p>
<ul>
<li>RFA</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_38c0eb28bff9b9b66dffa31886851389.png" alt=""></p>
<ul>
<li><p>以下实验都用来说明模型泛化性强</p>
<ul>
<li><p>chroma</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_b3f11be27e97b704f3cfa80121b40cbc.png" alt=""></p>
</li>
<li><p>Performance on other QPs</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_de6a347d017bbd7ea3efd10ddef4cf1d.png" alt=""></p>
</li>
<li><p>HEVC</p>
<p>apply our model trained on the VTM- 6.0 dataset directly to HM-16.9 without any ﬁne-tuning.</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_7b42f1242eda5a0b29e9df5cd228a589.png" alt=""></p>
</li>
<li><p>补充测试序列</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_f925d0880e543aad122b64d6d0f15522.png" alt=""></p>
</li>
</ul>
</li>
<li><p>计算复杂度</p>
</li>
</ul>
<p>每种编码算法的计算复杂度是在RA配置下评估的。编码复杂度∆T的计算方法是</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_bbb38e8af88f9c91b4c6b4b1303eb197.png" alt=""></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_f84d929bc41d46cc80cde6c74f4cfc0e.png" alt=""></p>
<h3 id="后续方向"><a href="#后续方向" class="headerlink" title="后续方向"></a>后续方向</h3><ul>
<li>解码复杂，无法在实时应用中实现。<ul>
<li>利用整数量化优化的网络。可以加快滤波的速度，避免在不同的硬件或软件平台上由于浮点运算而产生的不同的舍入误差</li>
<li>训练一组简单和浅层的网络，编码器根据情况选择最优的，并将索引传送到解码端</li>
<li>模型的推理依赖于第三方的深度学习框架，减少VVC编解码器和深度学习框架之间的互动造成的开销。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>视频编码</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode / 链表</title>
    <url>/2021/07/07/Leetcode-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>常用数据结构—链表</p>
</blockquote>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">// 设预指针pre的下一个节点指向head，防止空节点</span></span><br><span class="line">ListNode pre = <span class="keyword">new</span> ListNode(); </span><br><span class="line">pre.next = head;</span><br><span class="line"><span class="comment">// 设置动态当前指针cur</span></span><br><span class="line">ListNode cur = head; </span><br></pre></td></tr></table></figure>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>707 设计链表<br>剑指 Offer 06. 从尾到头打印链表（栈）</p>
<ul>
<li>删</li>
</ul>
<p>剑指 Offer 18. 删除链表的节点<br>83 删除排序链表中的重复元素(相同节点保留一个)<br><strong>82 删除排序链表中的重复元素 II(相同节点全部删除)</strong></p>
<ul>
<li>翻转</li>
</ul>
<p>24 两两交换链表中的结点<br>206/剑指 Offer 24. 反转链表<br>92 反转链表 II<br>25 k个一组翻转链表</p>
<ul>
<li>合并</li>
</ul>
<p>21/ 剑指 Offer 25 合并两个有序链表<br>23 合并K个升序链表<br>2 两数相加<br>445 两数相加 II（栈）</p>
<ul>
<li>快慢指针</li>
</ul>
<p>19/剑指 Offer 22 删除链表的倒数第 N 个结点<br>61 旋转链表<br>876 链表的中间结点<br>234 回文链表(中点+反转)<br>143 重排链表(中点+反转+合并)</p>
<ul>
<li>拆分</li>
</ul>
<p>86 分隔链表<br>328 奇偶链表<br><strong>138/剑指 Offer 35. 复杂链表的复制</strong>（hashmap / 链接+拆分）</p>
<ul>
<li>其他</li>
</ul>
<p><strong>160/剑指 Offer 52. 两个链表的第一个公共节点</strong></p>
<blockquote>
<ul>
<li><strong>集合set</strong></li>
<li><strong>快慢指针（先统计两个链表的长度，如果长度不一样，让链表长的先走，直到两个链表长度一样，这此时两个链表同时每次后移一步，看节点是否一样）</strong></li>
<li><strong>双指针</strong></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode / 位运算</title>
    <url>/2021/10/19/Leetcode-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>合理的运用位运算能显著提高代码在机器上的执行效率。<br><span id="more"></span></p>
<h2 id="右移运算符：-gt-gt"><a href="#右移运算符：-gt-gt" class="headerlink" title="右移运算符：&gt;&gt;"></a>右移运算符：&gt;&gt;</h2><p>将一个数a向右移动n位记为：a&gt;&gt;n。</p>
<ul>
<li>逻辑右移/无符号右移（java: &gt;&gt;&gt;），在移动过程中，空位都以0补齐。</li>
<li>算术右移(java: &gt;&gt;): 符号位不变，剩下位右移，空位补上符号位。 </li>
</ul>
<blockquote>
<p>如：a  =  00110111，则a&gt;&gt;2    = 00001101，b=11010011，则b&gt;&gt;2   =  11110100<br>如：a  =  00110111，则a&gt;&gt;&gt;2  = 00001101，b=11010011，则b&gt;&gt;&gt;2 =  00110100。</p>
</blockquote>
<h2 id="左移运算符：-lt-lt"><a href="#左移运算符：-lt-lt" class="headerlink" title="左移运算符：&lt;&lt;"></a>左移运算符：&lt;&lt;</h2><p>将一个数a向左移动n位记为：a&lt;&lt;n。<br>在左移的过程中，右边一律用0去填充。左边的二进制丢弃。</p>
<blockquote>
<p>比如，将10左移2位，由于10的二进制为：00001010，那么左移2位，右边用零填充的结果为：00101000。<br> 将一个数左移N位相当于将一个数乘以$2^N$，将一个数算数右移（&gt;&gt;）N位相当于将这个数除以$2^N$。 </p>
</blockquote>
<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>性质：</p>
<ul>
<li><code>n^n = 0</code></li>
<li><code>n^0 = n</code></li>
<li>异或操作满足交换律和结合律</li>
</ul>
<blockquote>
<p>136  唯一出现奇数次的数字 / 389 找不同 / 540. 有序数组中的单一元素<br>剑指56-1 唯二出现次数为奇数的数（分组异或）<br>剑指56-2 出现一次的数（除了一个数字以外，其余数字都出现 m 次 的通用问题：记录<strong>数组中所有数字</strong> 的 <strong>每一位的和</strong>，对m取余）<br>268 丢失的数字<br>剑指53 - II  0～n-1中缺失的数字<br>318 最大单词长度乘积</p>
</blockquote>
<p>异或运算交换2个数： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> b=<span class="number">20</span>; </span><br><span class="line">a=a^b; </span><br><span class="line">b=a^b; </span><br><span class="line">a=a^b; </span><br></pre></td></tr></table></figure>
<h2 id="二进制位"><a href="#二进制位" class="headerlink" title="二进制位"></a>二进制位</h2><ul>
<li>a的二进制末位为1，那么a &amp; 1 =1。如果a的二进制末位为0，那么a &amp; 1=0。<ul>
<li>判断a的二进制第i位是否是1： <code>(a &gt;&gt; i &amp; 1) == 1 ? true : false</code></li>
</ul>
</li>
<li>n &amp; (n−1)，其运算结果为把 n 的二进制位中的<strong>最低位</strong>的 1 变为 0 。</li>
<li>一个整数如果是 2 的整数次方，则其二进制表示中仅有1位1。<ul>
<li>判断整数是否为2的次方：<code>n &amp; (n−1) == 0 ? true : false</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>191 / 剑指 Offer 15 二进制中1的个数（无符号数）<br>（对有符号数：不断左移flag，和整数进行与运算。）<br>（两个整数 m 和 n，需要改变m中的多少位得到n：首先 m ^ n，然后求结果中1的位数）<br>338 比特位计数(dp + 位运算)<br>【如果 i 为偶数，那么 f(i) = f(i/2) ,因为 i/2 本质上是i的二进制左移一位，低位补零，所以1的数量不变】<br>【如果 i 为奇数，那么f(i) = f(i - 1) + 1， 因为如果i为奇数，那么 i - 1必定为偶数，而偶数的二进制最低位一定是0，那么该偶数 +1 后最低位变为1且不会进位，所以奇数比它上一个偶数bit上多一个1，即 f(i) = f(i - 1) + 1】</p>
</blockquote>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>计算机系统主要原因：使用补码，可以将符号位和其它位统一处理；同时，减法也可按加法来处理。另外，两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。</p>
<h3 id="求补码"><a href="#求补码" class="headerlink" title="求补码"></a>求补码</h3><p>最高位是符号位，0表示正，1为负</p>
<ul>
<li>正数的补码：与原码相同。<br>例如，+9的补码 00001001。</li>
<li>负数的补码：符号位为1，其余位为该数绝对值的原码按位取反；然后整个数加1。</li>
</ul>
<blockquote>
<p>例如，-7的补码：因为是负数，则符号位为“1；-7的绝对值+7的原码0000111按位取反为1111000；再加1，所以-7的补码是11111001。</p>
</blockquote>
<h3 id="已知补码求原码"><a href="#已知补码求原码" class="headerlink" title="已知补码求原码"></a>已知补码求原码</h3><ul>
<li>如果补码的符号位为“0”，表示是一个正数，所以补码就是该数的原码。</li>
<li>如果补码的符号位为“1”，表示是一个负数，求原码：符号位为1，其余各位取反，然后再整个数加1。</li>
</ul>
<h3 id="补码的表示范围"><a href="#补码的表示范围" class="headerlink" title="补码的表示范围"></a>补码的表示范围</h3><p>$-2^{n-1} —2^{n-1} -1$</p>
<ul>
<li>8位二进制带符号数表示范围：-128—127</li>
</ul>
<h3 id="补码加减法运算"><a href="#补码加减法运算" class="headerlink" title="补码加减法运算"></a>补码加减法运算</h3><p>计算机中，符号数一律用补码表示，运算时符号位和数字位一起参加运算。运算结果也用补码表示。</p>
<p>X, Y表示原数值</p>
<p>两符号数相加公式：[X+Y]补＝［X］补＋［Y］补<br>两符号数相减公式：[X-Y]补=[X]补+［-Y］补</p>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>Integer.MAX_VALUE，（2147483647），2^31 - 1, 0x7FFFFFFF<br>Integer. MIN_VALUE，（-2147483648），-2^31， </p>
<blockquote>
<p>Integer.MAX_VALUE + 1 = Integer. MIN_VALUE<br>Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE<br>-Integer.MIN_VALUE == Integer.MIN_VALUE</p>
</blockquote>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">Integer.MAX_VALUE:  <span class="number">01111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span></span><br><span class="line">				<span class="number">1</span>:  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line">				相加:<span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">Integer.MIN_VALUE:  <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Optical Flow / 光流</title>
    <url>/2021/10/09/Optical%20Flow/</url>
    <content><![CDATA[<blockquote>
<p>在连续图片序列中，从第t帧到第t+1帧，每个像素的<strong>运动速度</strong>和<strong>运动方向</strong>。</p>
</blockquote>
<span id="more"></span>
<p>稀疏光流:只计算图片中特定点的光流<br>稠密光流:每个像素都要计算光流。</p>
<h2 id="光流的表示"><a href="#光流的表示" class="headerlink" title="光流的表示"></a>光流的表示</h2><p>用三维数组 $[height, width, 2]$ 表示。其中$height$表示图像的高度，$width$表示图像的宽度，2表示x,y两个方向。<br>光流是个和原来图像大小相等的双通道图像。<br>在x方向上，正值表示物体向左移动，而负值表示物体向右移动；在y方向上，正值表示物体向上移动，而负值表示物体向下移动。</p>
<h2 id="光流提取"><a href="#光流提取" class="headerlink" title="光流提取"></a>光流提取</h2><ul>
<li>传统算法 Lucas-Kanade （稀疏）</li>
<li>深度学习算法 FlowNet/FlowNet2.0 （稠密）</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/74460341">https://zhuanlan.zhihu.com/p/74460341</a></p>
<h2 id="光流可视化"><a href="#光流可视化" class="headerlink" title="光流可视化"></a>光流可视化</h2><h3 id="稀疏"><a href="#稀疏" class="headerlink" title="稀疏"></a>稀疏</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">//[11,11,2]</span><br><span class="line">//通道1</span><br><span class="line">[[ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]</span><br><span class="line"> [ 2.5  2.   1.5  1.   0.5  0.  <span class="string">-0</span>.5 <span class="string">-1</span>.  <span class="string">-1</span>.5 <span class="string">-2</span>.  <span class="string">-2</span>.5]]</span><br><span class="line">//通道2</span><br><span class="line">[[ 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5]</span><br><span class="line"> [ 2.   2.   2.   2.   2.   2.   2.   2.   2.   2.   2. ]</span><br><span class="line"> [ 1.5  1.5  1.5  1.5  1.5  1.5  1.5  1.5  1.5  1.5  1.5]</span><br><span class="line"> [ 1.   1.   1.   1.   1.   1.   1.   1.   1.   1.   1. ]</span><br><span class="line"> [ 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5]</span><br><span class="line"> [ 0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0. ]</span><br><span class="line"> [<span class="string">-0</span>.5 <span class="string">-0</span>.5 <span class="string">-0</span>.5 <span class="string">-0</span>.5 <span class="string">-0</span>.5 <span class="string">-0</span>.5 <span class="string">-0</span>.5 <span class="string">-0</span>.5 <span class="string">-0</span>.5 <span class="string">-0</span>.5 <span class="string">-0</span>.5]</span><br><span class="line"> [<span class="string">-1</span>.  <span class="string">-1</span>.  <span class="string">-1</span>.  <span class="string">-1</span>.  <span class="string">-1</span>.  <span class="string">-1</span>.  <span class="string">-1</span>.  <span class="string">-1</span>.  <span class="string">-1</span>.  <span class="string">-1</span>.  <span class="string">-1</span>. ]</span><br><span class="line"> [<span class="string">-1</span>.5 <span class="string">-1</span>.5 <span class="string">-1</span>.5 <span class="string">-1</span>.5 <span class="string">-1</span>.5 <span class="string">-1</span>.5 <span class="string">-1</span>.5 <span class="string">-1</span>.5 <span class="string">-1</span>.5 <span class="string">-1</span>.5 <span class="string">-1</span>.5]</span><br><span class="line"> [<span class="string">-2</span>.  <span class="string">-2</span>.  <span class="string">-2</span>.  <span class="string">-2</span>.  <span class="string">-2</span>.  <span class="string">-2</span>.  <span class="string">-2</span>.  <span class="string">-2</span>.  <span class="string">-2</span>.  <span class="string">-2</span>.  <span class="string">-2</span>. ]</span><br><span class="line"> [<span class="string">-2</span>.5 <span class="string">-2</span>.5 <span class="string">-2</span>.5 <span class="string">-2</span>.5 <span class="string">-2</span>.5 <span class="string">-2</span>.5 <span class="string">-2</span>.5 <span class="string">-2</span>.5 <span class="string">-2</span>.5 <span class="string">-2</span>.5 <span class="string">-2</span>.5]]</span><br></pre></td></tr></table></figure>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_c8aeb6016d832173d50d999f73f6a45f.png" alt=""></p>
<h3 id="稠密"><a href="#稠密" class="headerlink" title="稠密"></a>稠密</h3><p><img src="https://notes.sjtu.edu.cn/uploads/upload_5ea99a85113e6fb0f28a8bc190c35260.png" alt=""></p>
<h2 id="warp"><a href="#warp" class="headerlink" title="warp"></a>warp</h2><p>将生成的光流应用到一张图像</p>
<p>在x方向上，正值表示物体向左移动，负值表示物体向右移动；<br>在y方向上，正值表示物体向上移动，而负值表示物体向下移动。 </p>
<p>x0 = pos_x + x， y0 = pos_y + y。pos_x和pos_y是原始的像素坐标，x和y是光流（向下取整），x0和y0就是warp后的像素坐标。以x方向为例，原始坐标加上一个负值，得到的结果变小了，也就相当于这个像素像左移了，如果加一个正值，结果变大，像素右移。</p>
<p>坐标变换后，很多坐标并没有相应的原始像素与之对应，需要通过插值来处理。</p>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>图像的很多处理得到的结果是连续的，为了得到离散点上的值，就需要插值。典型代表就是图像坐标的空间变换，如仿射变换，坐标经仿射变换后通常是小数，而图像只保存整数坐标位置上的像素值，所以需要插值。</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_d9a581e5ce7f1f5ed31f590edf8ddcc5.png" alt=""></p>
<ul>
<li>四个角上的点 $P_{x, y}, P_{x+1, y}, P_{x, y+1}, P_{x+1, y+1}$ 是整数坐标位置上的已知点；</li>
<li>红色的点 $P_{x_{p}, y_{p}}$ 是待插值的点；</li>
<li>红色虚线连着的两个点 $P_{x_{p}, y}, P_{x_{p}, y+1}$ 是两个辅助点。</li>
</ul>
<p>最邻近和双线性两种插值方法都比较简单，仅需要源图像和待插值的坐标。</p>
<h4 id="nearest"><a href="#nearest" class="headerlink" title="nearest"></a>nearest</h4><p>最邻近插值算法将距离$P_{x_{p}, y_{p}}$最近的已知点的像素值直接赋给$P_{x_{p}, y_{p}}$，对${x_{p}, y_{p}}$四舍五入得到${x, y}$，直接令$P_{x_{p}, y_{p}}=P_{x, y}$即可</p>
<ul>
<li>简单，但缺失精度，造成插值的图像灰度上的不连续，变化地方可能出现明显锯齿状</li>
</ul>
<h4 id="bilinear"><a href="#bilinear" class="headerlink" title="bilinear"></a>bilinear</h4><p>双线性插值从两个方向进行线性插值</p>
<script type="math/tex; mode=display">
P_{x_{p}, y}=P_{x, y}+\left(P_{x+1, y}-P_{x, y}\right)\left(x_{p}-x\right)</script><script type="math/tex; mode=display">
P_{x_{p}, y+1}=P_{x, y+1}+\left(P_{x+1, y+1}-P_{x, y+1}\right)\left(x_{p}-x\right)</script><script type="math/tex; mode=display">
P_{x_{p}, y_{p}}=P_{x_{p}, y}+\left(P_{x_{p}, y+1}-P_{x_{p}, y}\right)\left(y_{p}-y\right)</script><p>参考：<a href="https://blog.csdn.net/bby1987/article/details/105851870">https://blog.csdn.net/bby1987/article/details/105851870</a></p>
]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Coding / Block Partition</title>
    <url>/2021/11/16/Video_Coding%20_%20Block%20Partition/</url>
    <content><![CDATA[<blockquote>
<p>Block Partition，Video Coding 的基础。</p>
</blockquote>
<span id="more"></span>
<h2 id="H-264"><a href="#H-264" class="headerlink" title="H.264"></a>H.264</h2><ul>
<li>macroblock 16x16, 在一个MB内划分PU, TU<ul>
<li>I macroblock(intra)<ul>
<li>PB: luma 4x4, 16x16; chroma: 16x16</li>
</ul>
</li>
<li>P/B macroblock(inter)<ul>
<li>PB: 2Nx2N, Nx2N, 2NxN, NxN<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_35672750ff82e0032d687554f6eea5d0.png" alt="macroblock 进一步 PU 划分"></li>
</ul>
</li>
</ul>
</li>
<li>TB within an MB: 4x4 DCT2; 8x8 DCT2 in FRExt</li>
</ul>
</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_8ef1bf563d8fcaa5ad45d30c504ababd.png" alt="大分辨率序列上效率低"></p>
<h2 id="H-265"><a href="#H-265" class="headerlink" title="H.265"></a>H.265</h2><ul>
<li><p>CTU: 64X64 —-quad-tree—-&gt; CU: 8x8, 16x16, … 64x64</p>
<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_8e63500a385f17b8b3c4874752b4b2ca.png" alt=""></li>
<li><p>CU —&gt; PU</p>
<ul>
<li>intra: 2Nx2N, NxN(N=4, 8, 16, 32)</li>
<li>inter: 2Nx2N, Nx2N, 2NxN, NxN, AMP<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_5ba2983cd9e4f1ed54ecda83c73c32af.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>CU —-Residual quad tree—-&gt; TU</p>
<ul>
<li>4x4, 8x8, 16x16, 32x32 DCT-2</li>
<li>4x4 DST-7 for intra 4x4 luma block</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_b3d3c8a256459361a7095512c8c9faa4.png" alt=""></p>
<h2 id="H-266"><a href="#H-266" class="headerlink" title="H.266"></a>H.266</h2><ul>
<li><p>CTU 128x128 ——QT + MTT(multi-type-tree)—-&gt; CU: 8x8, 16x16, … 128x128</p>
<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_80c198b7a7bef214264f455a662378f1.png" alt="MTT"></li>
<li><p><img src="https://notes.sjtu.edu.cn/uploads/upload_9ff1804a48e3deec292ad5d2ef10c62b.png" alt="左下的CTU经历了三次划分，(编码端决策)复杂度已经很高"></p>
</li>
<li><p>CU划分灵活，取消PU</p>
</li>
<li>CU —-&gt;TU(取消RQT划分)<ul>
<li>ISP(intra subpartition)</li>
<li>SBT(sub-block transform)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_c0a509e00ae2037086d4bfe0a645fbae.png" alt=""></p>
<h3 id="CTU-—-gt-CU"><a href="#CTU-—-gt-CU" class="headerlink" title="CTU —&gt; CU"></a>CTU —&gt; CU</h3><h4 id="QT-MTT"><a href="#QT-MTT" class="headerlink" title="QT-MTT"></a>QT-MTT</h4><ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_964095e103d8c1e6d2cd3d4e5a93e21d.png" alt=""></li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_09d6c5324e183c5d382b71be2cfcde85.png" alt=""></li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_6397fadb947252dccda1e38fcfcfe2da.png" alt=""></li>
</ul>
<blockquote>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_6c8e028c48d9fd597c43afc8d44b8b70.png" alt=""></p>
</blockquote>
<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_16e8b9e266046d5aeccea4c27d223c69.png" alt=""></li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_dbc58176795f865ac53bbe7d309e8db3.png" alt=""></p>
<blockquote>
<p>划分中止条件(VVC)：划分到最小 CU 块；达到规定的最大二级树的划分深度<br><img src="https://notes.sjtu.edu.cn/uploads/upload_c27c39236f4094d5ceb16ad1f885899c.png" alt=""></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_669090be1545b2fa2a74777ea4d4a97b.png" alt=""><br>AV1 划分实质上是 QT+MTT，MTT最大划分到两次。（少于QT+MTT，MTT depth2，故划分上AV1灵活性不如 VVC）</p>
</blockquote>
<h4 id="split-syntax"><a href="#split-syntax" class="headerlink" title="split syntax"></a>split syntax</h4><p><img src="https://notes.sjtu.edu.cn/uploads/upload_4c52fcd16e09eddfd9add941a695a213.png" alt=""></p>
<p>首先确定五种划分模式中哪些可用（复杂）</p>
<ul>
<li>example: allow quad-split<br>  <img src="https://notes.sjtu.edu.cn/uploads/upload_916dd4abd01b5c9051bc66232e4e5b65.png" alt=""></li>
</ul>
<h4 id="CST-VVC-only"><a href="#CST-VVC-only" class="headerlink" title="CST(VVC only)"></a>CST(VVC only)</h4><ul>
<li><p>for I slice, chroma的划分可以与luma不同。</p>
<ul>
<li>intra 中 chroma 通常比 luma 简单可以划分成更少的块</li>
<li><p>CCLM技术: 用 luma 的重建信号预测 chroma，luma 预测质量高，没必要划分成更小的块</p>
</li>
<li><p><img src="https://notes.sjtu.edu.cn/uploads/upload_a816b57182398d42fac421e9e609880a.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<h4 id="other-improvements"><a href="#other-improvements" class="headerlink" title="other improvements"></a>other improvements</h4><ul>
<li><p>redundancy removal</p>
<ul>
<li><p><img src="https://notes.sjtu.edu.cn/uploads/upload_120e85edb6970ee8553f3d4cc867ed20.png" alt=""></p>
</li>
<li><p><img src="https://notes.sjtu.edu.cn/uploads/upload_f7ae94d0d3fd5ba00d13625cbe952249.png" alt=""></p>
</li>
</ul>
</li>
<li><p>图像边界强制划分</p>
<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_405f172caad834cfa865a71299a6babf.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="CU-—-gt-TU"><a href="#CU-—-gt-TU" class="headerlink" title="CU —&gt; TU"></a>CU —&gt; TU</h3><h4 id="ISP-a-k-a-SDIP-for-intra-CU"><a href="#ISP-a-k-a-SDIP-for-intra-CU" class="headerlink" title="ISP(a.k.a SDIP) for intra CU"></a>ISP(a.k.a SDIP) for intra CU</h4><ul>
<li>all luma CU 可以被划分为2个或4个预测模式相同的 TU<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_8688831be7a094f6ff08305c986aaad4.png" alt=""></li>
</ul>
</li>
<li>chroma 不划分，残差较小，用大的变换效率较高</li>
<li>出于硬件复杂度考虑，luma TB 必须至少包含16个像素</li>
</ul>
<h4 id="SBT-for-inter-CU"><a href="#SBT-for-inter-CU" class="headerlink" title="SBT for inter CU"></a>SBT for inter CU</h4><ul>
<li>motivation：多数inter情况下，残差只出现在块的一侧</li>
<li>CU划分为两个sub-TU：一部分为残差，另一部分强制不传</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_114d1fca4e5e70adfa7d3896dd72c509.png" alt=""></p>
<h3 id="硬件实现考虑"><a href="#硬件实现考虑" class="headerlink" title="硬件实现考虑"></a>硬件实现考虑</h3><ul>
<li>VPDU 以64x64节点为单位处理，不能出现跨多个节点的单元</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_1e24229de95020cec3c498ebcc1e599b.png" alt=""></p>
<ul>
<li>local dual tree 可能出现少于16个像素的chroma块<ul>
<li>intra：luma继续划分，chroma停止划分</li>
<li>inter：不存在该问题</li>
</ul>
</li>
</ul>
<h3 id="增益"><a href="#增益" class="headerlink" title="增益"></a>增益</h3><p><img src="https://notes.sjtu.edu.cn/uploads/upload_d65d11b52523ffb342ac742c2817fc76.png" alt=""></p>
]]></content>
      <tags>
        <tag>video coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Coding / HDR</title>
    <url>/2021/11/02/Video_Coding%20_%20HDR/</url>
    <content><![CDATA[<blockquote>
<p>HDR — 更高的动态范围，更广的色域，更深的比特位。</p>
</blockquote>
<span id="more"></span>
<p>将自然界中真实场景转换为屏幕上显示出来的图像，往往需要经过两个主要步骤：</p>
<ul>
<li>通过摄影设备，将外界光信息转换为图像信息存储为数字信号；</li>
<li>通过显示设备，将图像信息转换为屏幕输出的光信息。</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_062a65b8c9ed7a81b968dca8947aadd9.png" alt=""></p>
<p>在整个过程中，信息流要经过两个重要的非线性映射，才能形成我们在显示设备上看到的图像。</p>
<ul>
<li>相机的非线性映射通常称为光电转换函数（OETF）</li>
<li>显示端的显示器的非线性映射通常称为电光转换函数（EOTF）</li>
</ul>
<p>通常，OETF和EOTF并不是互逆关系。显示端的EOTF往往还包括代表创作者渲染意图的光光转换函数（OOTF），其对观看者在较暗环境下通过显示器观看带来的心理视觉影响进行了修正。</p>
<h2 id="SDR：Gamma校正"><a href="#SDR：Gamma校正" class="headerlink" title="SDR：Gamma校正"></a>SDR：Gamma校正</h2><p><img src="https://notes.sjtu.edu.cn/uploads/upload_73a758e0925744047b37727ae50db089.png" alt=""></p>
<p>经过一系列实验的测定，人类能够感知到的连续亮度谱如上图所示。</p>
<blockquote>
<p>也就是说，如果比上图更加精细，则没有必要，因为人眼无法识别；<br>如果比上图粗糙，则人眼能够感觉到间断。</p>
</blockquote>
<p>接着，将最左边纯黑编号为“0.0”，最右端纯白编号为“1.0”，中间定义为中灰“0.5”。这就形成了人眼的亮度谱。</p>
<p>但是，上图中的亮度在自然界中并不是同样成比例的，例如图中的中灰，对应自然界中的亮度是纯白的20%。</p>
<p>将人眼亮度谱与自然界中实际亮度进行建模，就可以得到下面的图像：</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_46af7cd62fea840a8a7795344e9bb60b.png" alt=""></p>
<p>在低亮度区域，人眼的敏感性较高，因此自然界中很小的亮度范围，都能够被人眼察觉；<br>在高亮度范围，人眼的敏感度较低，因此自然界中的大范围的亮度变化，在人眼感知上却并不大。<br>可以使用幂函数来拟合这种非线性的映射，用公式表示如下：</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_a30ade2b1f5ab50f8c5a912270d38b6e.png" alt=""></p>
<ul>
<li>X是使用0-1之间的实数,表示输入亮度</li>
<li>Y是使用0-1之间实数表示的输出亮度</li>
<li>γ为人为设定的参数，不同的γ选择会产生不同的效果。</li>
</ul>
<p>这种通过调整γ的取值，来调整输入输出亮度之间映射关系的方式，称之为gamma校正。根据γ取值的不同，能够发现gamma校正的不同效果：</p>
<p>当γ<1时，曲线上凸，输出值大于输入值。
当γ=1时，曲线为一条直线，输入与输出相等，不进行校正
当γ>1时，曲线下凸，输出值小于输入值</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_38001fcceeeef81b8e25162a93c8cbbb.png" alt=""></p>
<h3 id="真实场景到屏幕显示"><a href="#真实场景到屏幕显示" class="headerlink" title="真实场景到屏幕显示"></a>真实场景到屏幕显示</h3><p><img src="https://notes.sjtu.edu.cn/uploads/upload_9b556e400adfa83d459a6721e9fc9e57.png" alt=""></p>
<ul>
<li><p>首先，图像每个像素的取值在0-255之间，先进行归一化，将0-255这256个数线性映射到0-1之间。</p>
</li>
<li><p>接着，在图像获取阶段，摄像机中会使用一种encoding gamma函数进行gamma校正，这里的gamma值小于1。</p>
<ul>
<li>自然界中的亮度，首先在摄像机中进行归一化，映射到0-1之间，接着，将这个经过归一化的值输入encoding gamma函数中。最后将encoding gamma函数的输出值与0-255的像素值归一化结果进行比较，就能得到这个像素点的像素值。</li>
</ul>
</li>
<li><p>显示阶段的gamma校正通常使用一种display gamma函数来完成，这里的gamma值大于1。</p>
<ul>
<li>显示设备读取像素值后，进行归一化，然后将归一化结果输入display gamma函数中。将输出的值对应的自然光线进行输出。</li>
</ul>
</li>
</ul>
<h3 id="可逆过程？"><a href="#可逆过程？" class="headerlink" title="可逆过程？"></a>可逆过程？</h3><p>理论上来说，上述两个阶段的gamma值乘积应该为1。因为两个gamma校正实际上做的是恰好相反的操作，一个是将自然光线存储为数字信息，另一个是将数字信息转换为光线。而为了使自然中的光线与显示设备产生的光线一致，显然这里的gamma值的乘积需要为1。</p>
<p>但是，在实际操作中，这两个gamma值的乘积并不为1，原因有以下两点：</p>
<ul>
<li>对于传统显示设备来说，屏幕能够显示的亮度范围与颜色范围与实际情况相差好几个数量级；</li>
<li>在真实的场景中，原始的场景填充了观察者的所有视野，而显示设备的亮度往往只局限在一个被周围环境包围的屏幕上。</li>
</ul>
<p>这两个差别使得感知对比度相较于原始场景明显下降了。</p>
<p>为了平衡这种现象，进而保证显示亮度在<strong>感知上</strong>和原始场景是一致，的两个gamma的乘积并不是1，而是经过试验得到的其他值。</p>
<blockquote>
<p>在电影院这种漆黑的环境中，乘积为1.5<br>在明亮的室内，乘积为1.125<br>个人电脑使用的一个标准叫sRGB，它使用的encoding gamma大约是0.45（也就是1/2.2）。这个值是为了配合display gamma为2.5的设备工作的。这样，end-to-end gamma就是0.45 * 2.5 = 1.125了。</p>
</blockquote>
<h3 id="Gamma-校正的意义"><a href="#Gamma-校正的意义" class="headerlink" title="Gamma 校正的意义"></a>Gamma 校正的意义</h3><p>按照上一节所说，两段gamma校正实际上是一对逆过程，一个将光信息转化为数字信息，一个将数字信息转化为光信息。<br>按照常理来说，并不需要复杂的非线性映射，只需要将归一化后的光信息记录下来，然后再让显示设备进行输出即可。<br>从这种角度来说，gamma校正是一个不必要的操作。</p>
<p>这是一个合理的质疑。问题的根源在<strong>存储位宽</strong>上，如果存储位宽足够大，显然可以使用上述归一化记录方式进行处理，但是，实际生产与应用中的位宽是有限的。</p>
<ul>
<li>在传统的图像存储与显示标准中，一个像素点有三个通道，而每个通道只有8位。</li>
<li>这也就意味着，图像的灰阶有限，与真实世界相比，差了很多数量级。</li>
<li>因此，想要在有限灰阶上表现出近似于自然界的亮度，就需要对灰阶分配进行设计</li>
</ul>
<p>这也是Gamma校正的意义。</p>
<ul>
<li><p>由于人类感知的“中灰”，在实际的自然光线中对应于白光的20%的亮度。因此，如果完全按照自然光线的数值进行灰度处理，纯黑到中灰这一段在人类感知中占到一半的灰度，将只能由20%的灰阶进行表示，而剩下的一半会有80%的灰阶进行表示，这显然是不合理的。Gamma校正就可以解决这个问题。</p>
</li>
<li><p>在实际操作中，中灰对应的自然光线，显然会被映射为0.5的取值，也就对应128这一灰阶。这样的结果就是高亮度与低亮度部分分别占有一半的灰阶，这就会使得显示的图像的直观感受更接近于现实。</p>
</li>
</ul>
<p>因此，gamma校正实际上是用来解决显示设备亮度灰阶不足的问题的。</p>
<ul>
<li>如果将图像存储的编码位宽扩大到32位，也就是能完全包含自然界亮度范围的时候，自然就不再需要进行gamma校正了，这种情况下，只需要将自然光线的亮度值记录下来，然后对应输出即可。</li>
<li>但是，使用32位位宽来存储图像过于“奢侈”，因此gamma校正在实际生活中起到了广泛而巨大的作用。</li>
</ul>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>传统的Gamma校正方式，是针对<strong>传统CRT显示设备与LDR图像</strong>设计的，对应的标准是BT.1886标准。而BT.1886标准规定的的峰值亮度仅为100nits，它与传统CRT设备的显示能力相一致。</p>
<p>目前大多数显示设备的显示能力早已突破100nits的限制，普通消费级显示器的亮度一般在200nits至500nits，商业级的监视器亮度可以达到1000nits至2000nits，实验室级别的监视器甚至可以高达4000nits至20000nits。</p>
<p>同时，现代数字运动图像传感器能够捕获动态范围到80dB或者比特深度达到14bit的线性视频信号。由于实践和历史原因，大多数专业视频制作系统都采用10比特，而消费者级别的视频和计算机图形学通常采用8比特。在HDR技术中，通常采用10比特或12比特。</p>
<p>显示设备亮度范围的提升、图像编码bit depth的提升，使得传统Gamma校正不适用于HDR的光电转换过程。如果强行使用Gamma校正进行转换，会在图像与视频中出现明显的分块与分环瑕疵。</p>
<p>针对上述问题，标准化组织规范了两种新型光电转换曲线：PQ曲线、HLG曲线。</p>
<p>由于8比特的位深限制了使用更宽广的动态范围，因此需要定义新的OETF曲线为视频制作和传输提供更高的动态范围。Dolby实验室提出了新的OETF曲线，称为PQ曲线，目前已经被标准化为SMPTE ST 2084。</p>
<p>Dolby提出的 PQ EOTF基于 Barten 的CSF模型。</p>
<h2 id="HDR：PQ-and-HLG-transfer-functions"><a href="#HDR：PQ-and-HLG-transfer-functions" class="headerlink" title="HDR：PQ and HLG transfer functions"></a>HDR：PQ and HLG transfer functions</h2><p>为了在屏幕上显示数字图像，显示设备需要将<strong>像素值转换成相应的光值</strong>。这个过程通常是非线性的，被称为EOTF（Electro-Optical Transfer Function，电光传输函数）。不同的显示设备支持不同类型的 “传输函数”。</p>
<p>常规的HDTV显示设备（SDR显示器）通常使用BT.709 Gamma transfer function来将视频信号转换为光。这些显示器主要用于显示亮度范围达100 Nits（cd/m2）的图像。</p>
<p>HDR定义了两个额外的传输函数来处理这个问题—感知量化器（Perceptual Quantizer，PQ）和混合对数伽马（Hybrid Log-Gamma，HLG）。</p>
<ul>
<li>HDR PQ是一个绝对的、以显示为参考的信号，支持PQ的显示设备需要实现tone mapping来适应光照度。显示设备使用内容元数据来显示PQ编码的图像。这可以为整个视频流（静态）或每个单独的镜头（动态）来一次。</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_ce534244d8a230353f0fffdf0804d7de.png" alt="PQ"></p>
<ul>
<li>HDR HLG是一个相对的、以场景为参考的信号。这意味着支持HLG的显示设备会根据内容和自身的显示能力自动适应光照度。</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_2767a93b6aec39142d38dd2e3ee9d8a4.png" alt="HLG"></p>
<p>预计在理想条件下，基于PQ的动态转换将达到最佳的质量效果，但代价是与现有显示系统的兼容性。</p>
<p>下图描述了各种传递函数的光照度的映射情况。垂直轴显示信号值的刻度为0-1，0为黑色，1为白色。这样做是为了使信号范围、比特深度不受影响。水平轴显示的是显示设备的尼特光照水平。</p>
<p>OETF - 光-电转移函数。描述光值将如何转换为数字值的数学传输函数，通常在相机内。<br>OOTF - 光-光传输函数。这个转移函数补偿了相机环境和显示器环境之间的色调感知差异。<br><img src="https://notes.sjtu.edu.cn/uploads/upload_0a057c35d6b3c8458095bfb0c48c2613.png" alt=""></p>
<p>人类对较暗区域的变化比对较亮区域的变化更敏感。这一特性在HDR系统中也得到了利用，与明亮区域相比，黑暗区域的颗粒度更大。</p>
<p>上图显示，与明亮区域相比，黑暗区域的光照度范围由更大的信号值表示—这意味着黑暗区域的颗粒度更高。虽然这在基于BT.709的显示器中分布更均匀，但在明亮区域的HDR显示器中，它的颗粒度变得更小。</p>
<ul>
<li>在HLG的情况下，一半以上的信号值在0-60尼特之间的光照度中被表示，其余的信号值在60-1000尼特范围内被表示。</li>
<li>在基于PQ ST2084的显示器中，大约有一半的信号值在0-40尼特之间的光照度中表示，其余一半的信号值在60-1000尼特范围内表示。</li>
</ul>
<p>根据该图，HDR HLG在低亮度区域与BT.709相似，因此与现有的SDR显示设备有更好的兼容性。<br>然而，HDR PQ与BT.709有很大不同。如果我们试图在SDR显示器上显示PQ HDR图像，由PQ代表的较暗区域将无一例外地变得更亮，从而降低了图像的对比度水平，其结果是一个水洗的图像。</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_accd4d5e5cadcce2af7dc4d83f348f86.png" alt=""></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_dd3197d6133124bbcf0111d4706009cb.png" alt=""></p>
<p>虽然基于PQ的转换提供了在支持HDR的显示器上显示最佳质量结果的承诺，但与HLG相比，它需要显示设备的适当 Tone mapping。</p>
<h3 id="HDR-Tone-Mapping"><a href="#HDR-Tone-Mapping" class="headerlink" title="HDR Tone Mapping"></a>HDR Tone Mapping</h3><ul>
<li>Tone Mapping是在HDR元数据的基础上将数字信号适应适当的光照水平的过程。</li>
<li>这个过程不是简单地在图像数据上应用EOTF（电光传输函数），而是试图<strong>使用元数据信息</strong>将<strong>图像数据与显示设备的能力进行映射</strong>。</li>
<li>由于市场上有广泛的HDR显示设备，每个设备都有自己的Nits（即 “亮度”）范围，正确的色调映射对于良好的用户体验是必要的。由于色调映射是根据视频流中的元数据完成的，因此正确的元数据的存在是必要的。</li>
</ul>
<p>源素材可以用最好的相机以HDR拍摄，然后在高端HDR母版系统上进行母版处理，但它仍然需要在市场上可用的HDR电视上以最佳方式显示。色调映射将内容与设备进行适当的亮度映射，不会出现明显的退化。</p>
<blockquote>
<p>比如，一个图像是以2000尼特的峰值亮度拍摄的。如果它显示在0-2000尼特范围的电视上，亮度范围将与拍摄的原始画面完全一致。然而，在其他设备上的结果将是不同的。<br><img src="https://notes.sjtu.edu.cn/uploads/upload_07cd23fdacd116f9139ac14d8bc6abd6.png" alt=""><br>由于 Tone Mapping 是在 HDR 显示设备上显示基于 PQ 的 HDR 内容的必要操作，电视需要知道内容的原始属性，即所使用的亮度范围和母版系统参数。这些信息是以 HDR 元数据的形式传达的。<br>读取 HDR 元数据后，显示设备可以决定 Tone Mapping 参数，使转换后的视频在显示设备的显示范围内处于最佳状态。</p>
</blockquote>
<h3 id="HDR元数据"><a href="#HDR元数据" class="headerlink" title="HDR元数据"></a>HDR元数据</h3><p>HDR 元数据是显示设备以最佳方式显示内容的一种辅助手段。它包含 HDR 内容和母版设备属性，显示设备根据其自身的色域和峰值亮度来映射内容。有两种类型的元数据 - 静态和动态。</p>
<ul>
<li>静态元数据：静态元数据包含适用于整个内容的元数据信息。它由SMPTE ST 2086标准化。<ul>
<li>在一个典型的内容中，亮度和色彩范围因镜头而异。静态元数据的挑战在于，如果根据静态元数据进行 Tone Mapping，它将只基于整个内容中最亮的那一帧。</li>
<li>因此，大部分内容的动态范围和色域的压缩程度将超过需要。</li>
<li>这将导致在能力较差的HDR显示设备上出现糟糕的观看体验。</li>
</ul>
</li>
<li>动态元数据：动态元数据允许在每个场景的基础上进行 Tone Mapping。动态元数据已经被SMPTE ST 2094标准化，它定义了与内容相关的元数据。<ul>
<li>当内容在能力较弱的 HDR 显示设备上显示时，这将导致用户的观看体验明显改善。</li>
</ul>
</li>
<li>将动态元数据与静态元数据一起使用，可以克服只使用静态元数据进行 Tone Mapping 所带来的问题。</li>
</ul>
<h3 id="Dolby-Vision"><a href="#Dolby-Vision" class="headerlink" title="Dolby Vision"></a>Dolby Vision</h3><ul>
<li>Dolby Vision使用动态元数据，是当今最常用的HDR技术。</li>
<li>主要的OTT服务提供商，如Netflix和亚马逊，以及主要的电影公司和许多著名的电视制造商都采用了这种技术。</li>
<li>Dolby Vision在SMPTE ST 2094-10中得到了标准化。除了支持动态元数据外，杜比视界还允许为特定设备描述多种修饰，从而在这些设备上实现更精细的显示。</li>
</ul>
<h2 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h2><p>cd/m2 - 坎德拉(cd)是国际单位制(SI)中发光强度的基本单位；即一个点光源在特定方向上发出的每单位实体角度的发光功率。一支普通的蜡烛发出的光，其发光强度大约为1坎德拉。</p>
<p>Nits — 一种用于描述亮度的非SI单位。1Nits=1cd/m2。</p>
<p>WCG - Wide Color Gamut，宽色域。提供比BT.709更广泛的颜色范围的色域。DCI-P3和BT.2020是WCG的例子，在显示设备上提供更真实的图像表现。</p>
<p>参考：<br><a href="https://www.veneratech.com/hdr/">https://www.veneratech.com/hdr/</a></p>
]]></content>
      <tags>
        <tag>video coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Coding / ALF</title>
    <url>/2021/10/20/alf/</url>
    <content><![CDATA[<blockquote>
<p>ALF, VVC中增益最大的单项工具。</p>
</blockquote>
<span id="more"></span>
<p>ALF思想：维纳滤波。</p>
<p>维纳滤波是一种基于最小均方误差准则、对平稳过程的最优估计器，其输出与期望输出之间的均方误差为最小。</p>
<p>下图为ALF在VVC中位置。</p>
<p><img src="/img/VVC/alf.png" style="zoom:67%;" /></p>
<p>ALF使用如下所示两种钻石形状的滤波器，5x5大小的适用于色度分量，7x7适用于亮度分量。其中滤波系数平均值为128。</p>
<p><img src="/img/VVC/alfshape.png" style="zoom: 33%;" /></p>
<p><code>sh_alf_enabled_flag</code></p>
<p><code>sh_alf_cb_enabled_flag</code></p>
<p><code>sh_alf_cr_enabled_flag</code></p>
<h2 id="ALF解码端滤波过程"><a href="#ALF解码端滤波过程" class="headerlink" title="ALF解码端滤波过程"></a>ALF解码端滤波过程</h2><h3 id="1-块分类"><a href="#1-块分类" class="headerlink" title="1. 块分类"></a>1. 块分类</h3><blockquote>
<p>对不同的小块使用不同的滤波器，因此需将这些小块进行分类。</p>
</blockquote>
<p>对于<strong>亮度</strong>，每个4x4小块被分为25类，每类有相应的滤波器。类别$C$计算规则如下。</p>
<p>$C=5D+\hat A$</p>
<p>其中$D$和$A$分别表示当前块的$Direction$和$Activity$，计算之前需要当前<strong>块</strong>的水平、垂直和两个对角方向的gradient。</p>
<p><img src="/img/VVC/block-gradient.png" style="zoom:67%;" /></p>
<p>$(i, j)$为当前4x4块的左上角坐标。4x4子块的梯度等于当前4x4块周围补两圈共64个像素的梯度之和。其中像素梯度用1-D拉普拉斯算子计算</p>
<p><img src="/img/VVC/pixel.png" style="zoom:67%;" /></p>
<p>为了减少计算量，64个像素的梯度值不必都计算，而是通过下图方式下采样，只计算标注的像素的梯度。该过程是在一个10x10大小的窗口中进行。</p>
<p><img src="/img/VVC/down.png" style="zoom:67%;" /></p>
<h4 id="计算Direction"><a href="#计算Direction" class="headerlink" title="计算Direction"></a>计算Direction</h4><ul>
<li>水平垂直方向上梯度的最大最小值：</li>
</ul>
<p><img src="/img/VVC/h.png" style="zoom: 67%;" /></p>
<p>​        对角线方向上梯度的最大最小值：</p>
<p><img src="/img/VVC/d.png" style="zoom:67%;" /></p>
<ul>
<li>根据上述四个值以及阈值$t_1$和$t_2$设置D的值，规则如下<br><img src="/img/VVC/setd.png" style="zoom: 80%;" /></li>
</ul>
<p>step1中子块被划分为纹理，step3中子块被划分为强/弱水平或垂直，step4中子块被划分为强/弱对角线方向。</p>
<h4 id="计算Activity"><a href="#计算Activity" class="headerlink" title="计算Activity"></a>计算Activity</h4><ul>
<li>计算$A$：</li>
</ul>
<p><img src="/img/VVC/A.png" style="zoom: 80%;" /></p>
<ul>
<li>将A映射为值在0—4之间的$\hat A$</li>
</ul>
<p><img src="/img/VVC/map.png"  /></p>
<p><img src="/img/VVC/Q.png"  /></p>
<h3 id="2-几何变换（Geometric-transformations）"><a href="#2-几何变换（Geometric-transformations）" class="headerlink" title="2. 几何变换（Geometric transformations）"></a>2. 几何变换（Geometric transformations）</h3><blockquote>
<p>其目的是使不同块的方向性一致，以减少ALF类的数量，反过来也减少了过滤系数。应用几何变换可以使具有水平边缘的4×4块和具有垂直边缘的4×4块都具有相同的方向性 ，具体进行哪一种翻转取决于第一步中计算得到的gradient。</p>
</blockquote>
<p>几何变换包括三种，对角翻转Diagonal、垂直翻转Vertical flip、旋转Rotation，以7x7的块为例如下图：</p>
<p><img src="/img/VVC/flip.png" style="zoom: 50%;" /></p>
<p>几何变换规则如下表：</p>
<p><img src="/img/VVC/trans.png" style="zoom: 50%;" /></p>
<h3 id="3-滤波"><a href="#3-滤波" class="headerlink" title="3. 滤波"></a>3. 滤波</h3><h4 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h4><p>在$(x, y)$处像素值为$R(x,y)$，滤波后像素值$\tilde{R}(x,y)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tilde{R}(x, y)=&\left[\sum _ { i = 0 } ^ { N - 2 } c _ { i } \left(R\left(x+x_{i}, y+y_{i}\right)+R\left(x-x_{i}, y-\right.\right.\right.\left.\left.\left.y_{i}\right)\right)+c_{N-1} R(x, y)+64\right]>>7
\end{aligned}</script><p>化简得</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tilde{R}(x, y)=& R(x, y)+\left\{\left[\sum _ { i = 0 } ^ { N - 2 } c _ { i } \left(R\left(x+x_{i}, y+y_{i}\right)-\right.\right.\right.R(x, y))+\sum_{i=0}^{N-2} c_{i}\left(R\left(x-x_{i}, y-y_{i}\right)-\right.R(x, y))+64]>>7\}
\end{aligned}</script><p>对于7x7和5x5的块，N分别为13和7。</p>
<h4 id="非线性自适应滤波"><a href="#非线性自适应滤波" class="headerlink" title="非线性自适应滤波"></a>非线性自适应滤波</h4><blockquote>
<p>引入clip function来减少临近样本和当前样本差异过大时的影响。</p>
</blockquote>
<p><img src="/img/VVC/nonliner.png"  /></p>
<script type="math/tex; mode=display">
\begin{array}{c}
f_{i}=\min \left(b_{i}, \max \left(-b_{i}, R\left(x+x_{i}, y+y_{i}\right)-R(x, y)\right)\right)+\min \left(b_{i}, \max \left(-b_{i}, R\left(x-x_{i}, y-y_{i}\right)-R(x, y)\right)\right)
\end{array}</script><p>$min(y, max(-y, x))$对应于$Clip3(-y, y, x)$</p>
<p>$b_i$： clipping parameter，取决于$BitDepth$和$clipidx$，如下表。</p>
<p><img src="/img/VVC/bi.png"  /></p>
<p>相关flag：</p>
<p><code>alf_luma_clip_flag</code></p>
<p><code>alf_luma_clip_idx\[ sfIdx ][ j ]：表示传输的第sfIdx个滤波器的第  j 个系数的clipidx。</code></p>
<p><code>alf_chroma_clip_flag</code></p>
<p><code>alf_chroma_clip_idx</code></p>
<h2 id="减少行缓冲区的边界过滤过程"><a href="#减少行缓冲区的边界过滤过程" class="headerlink" title="减少行缓冲区的边界过滤过程"></a>减少行缓冲区的边界过滤过程</h2><p><img src="/img/VVC/linebuffer.png"  /></p>
<p>如果没有行缓冲区边界处理，需要使用DBF和SAO过滤后的B行到K行的样本。<br>在下层CTU可用之前，DBF和SAO滤波器不能应用于A至D行。因此，如果没有行缓冲区边界处理，ALF就不能应用于E到H行的样本，直到下层CTU可用。<br>除了A到D行之外，E到K的7个luma行必须存储在行缓冲器中用于luma ALF。同样地，4个额外的色度行将存储在行缓冲器中用于色度ALF<br> 为了计算与行缓冲区边界相邻的样本(E行)梯度值，padding，即D行的样本被替换为E行的样本。<br>行缓冲区边界另一侧的所有样本梯度值都被设置为0，减少了样本梯度的总和，需要对活动性A进行缩放：</p>
<p><img src="/img/VVC/scalea.png"  /></p>
<p>当要过滤的样本的滤波形状越过行缓冲区边界时，对称样本填充。白色为待滤波像素，灰色为对称padding后的像素</p>
<p><img src="/img/VVC/sy.png" style="zoom:80%;" /></p>
<p>当要过滤的样本位于最接近行缓冲区边界的一行时，二维滤波器相当于一个水平滤波器，引入明显的视觉伪影，将滤波强度降低8倍可以将这些伪影降到最低。公式中右移7相应变为右移10。</p>
<p><img src="/img/VVC/10.png" style="zoom: 67%;" /></p>
<h2 id="CCALF"><a href="#CCALF" class="headerlink" title="CCALF"></a>CCALF</h2><blockquote>
<p>用亮度样本修正色度分量，提供近1%的BD-Rate增益</p>
</blockquote>
<p><img src="/img/VVC/ccalf.png" style="zoom:67%;" /></p>
<p>CCALF滤波器系数值必须是2的次幂，{0, 1, 2, 4, 8,16, 32, 64}，方便移位运算。</p>
<p>相关flag：</p>
<p><code>Slice级：</code></p>
<p><code>sh_alf_cc_cb_enabled_flag</code></p>
<p><code>sh_alf_cc_cr_enabled_flag</code></p>
<p><code>CTB级：</code></p>
<p><code>alf_cc_cb_filter_signal_flag</code></p>
<p><code>alf_cc_cb_filters_signalled_minus1</code></p>
<p><code>alf_cc_cb_mapped_coeff_abs</code></p>
<p><code>alf_cc_cb_coeff_sign</code></p>
<h2 id="编码端ALF"><a href="#编码端ALF" class="headerlink" title="编码端ALF"></a>编码端ALF</h2><h3 id="系数计算过程"><a href="#系数计算过程" class="headerlink" title="系数计算过程"></a>系数计算过程</h3><blockquote>
<p>维纳滤波器的基本原理是找到一个合适的单位冲激响应,使得加入了随机噪声的信号通过滤波器后,得到的信号与原始信号的均方误差MSE最小。</p>
</blockquote>
<p>设$o[i]$为原始未压缩图像的像素值,其中$i∈I$为坐标矢量,$I$是所有被该滤波器进行滤波的像素点坐标的集合;</p>
<p>$r[i]$为经过压缩后未滤波的像素值,也就是经过DBK和SAO后的像素值,相比原始像素值引入了随机噪声;</p>
<p>$f[i]$为滤波后的像素值。</p>
<p>$c_n$为滤波系数，$p_n$是该滤波器系数相对滤波器中心位置的偏移值。</p>
<p>可以求得滤波后的像素值与原始像素值的均方误差</p>
<p><img src="/img/VVC/alfc1.png" style="zoom:67%;" /></p>
<p>MSE对各系数求偏导</p>
<p><img src="/img/VVC/alfc2.png" style="zoom:67%;" /></p>
<p>为使MSE最小，令其对各系数的偏导数为0，有</p>
<p><img src="/img/VVC/alfc3.png" style="zoom:67%;" /></p>
<p>将上式写成矩阵形式，</p>
<p><img src="/img/VVC/alfc4.png" style="zoom: 50%;" /></p>
<p>令</p>
<p><img src="/img/VVC/alfc5.png" style="zoom: 67%;" /></p>
<p><img src="/img/VVC/alfc6.png" style="zoom: 67%;" /></p>
<p>有</p>
<p><img src="/img/VVC/alfc7.png" style="zoom:67%;" /></p>
<p>令</p>
<p><img src="/img/VVC/alfc8.png" style="zoom:67%;" /></p>
<p>R矩阵由未滤波的像素值组成，得</p>
<p><img src="/img/VVC/alfc9.png" style="zoom:67%;" /></p>
<p>$T$和未滤波像素值有关，$v$和未滤波像素值及原始像素值有关。求解该方程组就可以得到相应的滤波系数。</p>
<p>对于 ALF 来说，由于其卷积核是中心对称的，所以在求解过程中可以将相同系数的像素值先合并再计算，即</p>
<p><img src="/img/VVC/alfc10.png" style="zoom: 67%;" /></p>
<h3 id="快速算法求滤波后失真"><a href="#快速算法求滤波后失真" class="headerlink" title="快速算法求滤波后失真"></a>快速算法求滤波后失真</h3><p>编码端需要多次RDO，需要求得滤波后的误差，复杂度高。所以算滤波后MSE实际并没有进行滤波，而是采用快速算法。</p>
<p>根据 MSE 的定义有</p>
<p><img src="/img/VVC/alfc11.png" style="zoom:67%;" /></p>
<p>或采用矩阵方式</p>
<p><img src="/img/VVC/alfc12.png" style="zoom:67%;" /></p>
<p>由于相应像素集对应的 T 和 v 可以快速求出，所以新的 MSE 也可以快速求出，而不需要进行真正的滤波操作。</p>
<p>进一步简化可得</p>
<p><img src="/img/VVC/alfc13.png" style="zoom:67%;" /></p>
<p>这里有一部分的计算和其他模块的计算重复了。即不使用 ALF，未滤波时的MSE。上述公式中已经包含了这一部分，推导见下：</p>
<p>由MSE的定义，</p>
<p><img src="/img/VVC/alfc14.png" style="zoom:67%;" /></p>
<p>矩阵计算版：</p>
<p><img src="/img/VVC/alfc15.png" style="zoom:67%;" /></p>
<p>这里实际上可提取出MSE non−filtered这一项，也就是不使用 ALF 时的 MSE，而这一项前面已经求得，因此只需要求前面那部分即可。</p>
<p>对于维纳滤波的系数来说，由于有 $T \hat c = \hat v$，所以也可简化为</p>
<p><img src="/img/VVC/alfc16.png" style="zoom:67%;" /></p>
<h3 id="产生新滤波器的过程"><a href="#产生新滤波器的过程" class="headerlink" title="产生新滤波器的过程"></a>产生新滤波器的过程</h3><p>如何对每一帧产生new filter set：</p>
<ul>
<li>对每一帧，通过merge ALF on的CTBs的数据产生一个亮度filter set。在第一轮迭代中，假设所有CTBs都ALF on。</li>
</ul>
<ul>
<li>对每个CTB用产生的filters和自身数据做RDO，决定是否使用ALF。</li>
</ul>
<ul>
<li>以上步骤迭代四次。</li>
</ul>
<p>产生filter set具体步骤：</p>
<ul>
<li>首先对25类分别算一个滤波器。</li>
</ul>
<ul>
<li>在每次迭代中，通过合并两个滤波器，将滤波器的数量减少1。为了确定哪两个滤波器应该被合并，对于剩下的每一对滤波器，编码器分别通过合并两个滤波器和相应的统计数据重新设计一个滤波器。使用重新设计的滤波器，然后估计失真度，编码器合并失真度最小的一对。</li>
</ul>
<ul>
<li>得到25个滤波器组，第一组有25个滤波器，第二组有24个滤波器，以此类推，直到第25组包含一个滤波器。</li>
</ul>
<ul>
<li>选择RDcost最小的一组</li>
</ul>
<p>产生具体一个filter：</p>
<ul>
<li>用CTB的数据解Wiener-Hopf方程，得coeff。clipidx和coeff迭代计算直到方差不再降低。</li>
</ul>
<ul>
<li>在每轮迭代中，clipidx一个一个更新，从$d_0$到$d_{N-2}$，每个clipidx有三种选择：保持不变，加1，减1，对每一种算coeff和distortion，选方差最小的。第一轮迭代clipidx初始化为2。合并两个滤波器时，clipidx取对应的均值。</li>
</ul>
<h2 id="syntax"><a href="#syntax" class="headerlink" title="syntax"></a>syntax</h2><p>滤波相关参数放在APS中。</p>
<p>一个ALF APS最多包括1 luma filter set 和8 chroma filters，为每个色度分量最多包含四个CC-ALF滤波器，还有clipidx。1 filter set 最多包括25个滤波器（对应25种类），不同类别的滤波器参数可以merge，所以实际一般少于25个。</p>
<p><img src="/img/VVC/alfsyntax1.png"  /></p>
<p><code>alf_luma_num_filters_signalled_minus1：加1表示对亮度分量传输的滤波器数量，其值在[0,24]间。</code></p>
<p><code>alf_luma_coeff_delta_idx[ filtIdx ]：filtIdx 所指定类别对应的滤波器增量的索引。即表明了类别merge后每类所对应的滤波器。</code></p>
<p><code>alf_luma_coeff_abs\[ sfIdx ][ j ]：表示传输的第  sfIdx  个滤波器的第  j 个系数 的绝对值。其值在[0,128]间。</code><br><code>alf_luma_coeff_sign\[ sfIdx ][ j ]：表示传输的第  sfIdx  个滤波器的第  j 个系数 的符号。</code></p>
<p><code>alf_luma_clip_idx\[ sfIdx ][ j ]：表示传输的第  sfIdx  个滤波器的第  j 个系数的clipidx。</code></p>
<p><img src="/img/VVC/alfsyntax2.png"  /><br><code>alf_chroma_num_alt_filters_minus1：加  1 表示色度可使用的滤波器数量， 其值在[0,7]间。</code><br><code>alf_chroma_coeff_abs\[ altIdx ][ j ]：表示的第  sfIdx  个色度滤波器的第  j 个系 数的绝对值。其值在[0,128]间。</code><br><code>alf_chroma_coeff_sign\[ altIdx ][ j ]：表示的第  sfIdx  个色度滤波器的第  j 个 系数的符号。</code><br><code>alf_chroma_clip_idx\[ altIdx ][ j ]：表示第  sfIdx  个色度滤波器的第  j 个系数的clipidx的索引。</code></p>
<p>APS可用数量在slice级别控制（<code>sh_num_alf_aps_ids_luma</code>），最多可用7个。</p>
<p>除了7个APS，还提供了16个预训练好的固定滤波器，APS种类为索引为0~15。CTB级可以控制ALF开关，指定所使用的滤波器组。一个luma CTB可以使用为当前slice计算的aps或为已经编码的slice计算的aps之一</p>
<p><img src="/img/VVC/alfeg.png" style="zoom:;" /></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>anchor为指定技术off</p>
<p><img src="/img/VVC/alfres.png" style="zoom: 67%;" /></p>
<p>尽管ALF编码器被设计为改善客观质量，但也可以观察到主观质量的改善。在图12的例子中，ALF同时减少了振铃伪影（用黑色圆圈标记）和阻塞伪影（用白色圆圈标记）。</p>
<p><img src="/img/VVC/alfres2.png" style="zoom:;" /></p>
<p>CC-ALF的BD-rate显示出色度的增益和luma的损失，因为CC-ALF花费的额外比特被用来提高色度质量，而luma质量几乎保持不变。CC-ALF的测试结果显示在下表中，包含三个部分。第一部分显示了编码器以PSNR增益为目标，内容为YCbCr色彩空间，采用ITU-R BT.1886光电子传递函数（OETF）的情况下的结果。在第二部分中，编码器再次以PSNR增益为目标，而内容是在RGB色彩空间中的ITU-R BT.1886 OETF。第三部分与PQ 4:2:0内容有关，显示了编码器以加权PSNR指标为目标的结果。</p>
<p><img src="/img/VVC/ccalfres.png" style="zoom:80%;" /></p>
<p><img src="/img/VVC/ccalfres2.png" style="zoom:80%;" /></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="/img/VVC/codealf.png"  /></p>
]]></content>
      <tags>
        <tag>VVC</tag>
      </tags>
  </entry>
  <entry>
    <title>deep learning / 各种卷积方法</title>
    <url>/2021/10/20/deep-learning%20_%20%E5%90%84%E7%A7%8D%E5%8D%B7%E7%A7%AF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>卷积及其变种</p>
</blockquote>
<span id="more"></span>
<h2 id="2D-Convolution"><a href="#2D-Convolution" class="headerlink" title="2D-Convolution"></a>2D-Convolution</h2><p><img src="https://yinguobing.com/content/images/2018/02/conv-std.jpg"></p>
<h2 id="Group-Convolution【AlexNet】"><a href="#Group-Convolution【AlexNet】" class="headerlink" title="Group Convolution【AlexNet】"></a>Group Convolution【AlexNet】</h2><p><img src="https://notes.sjtu.edu.cn/uploads/upload_b10b20c60b86b91ff70f65fef21f6a09.png" alt="在分组卷积中，filters被拆分为不同的组，每一个组都负责具有一定深度的传统 2D 卷积的工作"></p>
<p>上图表示的是被拆分为 2 个filters组的分组卷积。在每个filters组中，其深度仅为传统2D-卷积的一半$D_{in}/2$，而每个filters组都包含$D_{out}/2$个filters。第一个filters组（红色）对输入层的前半部分做卷积，第二个filters组（蓝色）对输入层的后半部分做卷积。最终，每个filters组都输出了$D_{out}/2$个通道。整体上，两个组输出的通道数为$D_{out}$。之后再将这些通道堆叠到输出层中，输出层就有了$D_{out}$个通道。</p>
<h2 id="Dilated-Convolution"><a href="#Dilated-Convolution" class="headerlink" title="Dilated Convolution"></a>Dilated Convolution</h2><p><img src="https://notes.sjtu.edu.cn/uploads/upload_d89c9f7c57d4924728b65e2803d488b9.png" alt="Dilated Convolution with a 3 x 3 kernel and dilation rate 2"></p>
<h2 id="Depthwise-Separable-Convolution（DSC）【MobileNet-Xception】"><a href="#Depthwise-Separable-Convolution（DSC）【MobileNet-Xception】" class="headerlink" title="Depthwise Separable Convolution（DSC）【MobileNet/Xception】"></a>Depthwise Separable Convolution（DSC）【MobileNet/Xception】</h2><p>损失精度不多的情况下大幅度降低参数量和计算量，在参数量相同的前提下，采用DSC的神经网络层数可以做的更深。</p>
<ul>
<li>step1. Depthwise Convolution</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_a3ec37d801ec2f319a7ff8c909d6166d.png" alt=""></p>
<ul>
<li>step2. Pointwise Convolution</li>
</ul>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_0567db7aabb74b5289b923643fdb8854.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;CLASS torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> - dilation: controls the spacing between the kernel points; also known as the à trous algorithm.</span></span><br><span class="line"><span class="string"> - groups: controls the connections between inputs and outputs. in_channels and out_channels must both be divisible by groups. For example,</span></span><br><span class="line"><span class="string">		At groups=1, all inputs are convolved to all outputs.</span></span><br><span class="line"><span class="string">		At groups=2, the operation becomes equivalent to having two conv layers side by side, each seeing half the input channels, and producing half the output channels, and both subsequently concatenated.</span></span><br><span class="line"><span class="string">		At groups= in_channels, each input channel is convolved with its own set of filters.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSC</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_ch, out_ch</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CSDN_Tem, self).__init__()</span><br><span class="line">        self.depth_conv = nn.Conv2d(</span><br><span class="line">            in_channels=in_ch,</span><br><span class="line">            out_channels=in_ch,</span><br><span class="line">            kernel_size=<span class="number">3</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            groups=in_ch</span><br><span class="line">        )</span><br><span class="line">        self.point_conv = nn.Conv2d(</span><br><span class="line">            in_channels=in_ch,</span><br><span class="line">            out_channels=out_ch,</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            groups=<span class="number">1</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        out = self.depth_conv(<span class="built_in">input</span>)</span><br><span class="line">        out = self.point_conv(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Asymmetric-Convolutions（AC）"><a href="#Asymmetric-Convolutions（AC）" class="headerlink" title="Asymmetric Convolutions（AC）"></a>Asymmetric Convolutions（AC）</h2><p><img src="https://notes.sjtu.edu.cn/uploads/upload_8d0cba80232d748effba02636b749964.png" alt=""></p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_5b7630300458886a5397d6cb4c327fd6.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CropLayer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#   E.g., (-1, 0) means this layer should crop the first and last rows of the feature map. And (0, -1) crops the first and last columns</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, crop_set</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CropLayer, self).__init__()</span><br><span class="line">        self.rows_to_crop = - crop_set[<span class="number">0</span>]</span><br><span class="line">        self.cols_to_crop = - crop_set[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">assert</span> self.rows_to_crop &gt;= <span class="number">0</span></span><br><span class="line">        <span class="keyword">assert</span> self.cols_to_crop &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.rows_to_crop == <span class="number">0</span> <span class="keyword">and</span> self.cols_to_crop == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">input</span></span><br><span class="line">        <span class="keyword">elif</span> self.rows_to_crop &gt; <span class="number">0</span> <span class="keyword">and</span> self.cols_to_crop == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">input</span>[:, :, self.rows_to_crop:-self.rows_to_crop, :]</span><br><span class="line">        <span class="keyword">elif</span> self.rows_to_crop == <span class="number">0</span> <span class="keyword">and</span> self.cols_to_crop &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">input</span>[:, :, :, self.cols_to_crop:-self.cols_to_crop]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">input</span>[:, :, self.rows_to_crop:-self.rows_to_crop, self.cols_to_crop:-self.cols_to_crop]</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, padding_mode=<span class="string">&#x27;zeros&#x27;</span>, deploy=<span class="literal">False</span>, use_affine=<span class="literal">True</span>, reduce_gamma=<span class="literal">False</span>, use_last_bn=<span class="literal">False</span>, gamma_init=<span class="literal">None</span> </span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ACBlock, self).__init__()</span><br><span class="line">        self.deploy = deploy</span><br><span class="line">        <span class="keyword">if</span> deploy:</span><br><span class="line">            self.fused_conv = nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=(kernel_size,kernel_size), stride=stride, padding=padding, dilation=dilation, groups=groups, bias=<span class="literal">True</span>, padding_mode=padding_mode)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.square_conv = nn.Conv2d(in_channels=in_channels, out_channels=out_channels,</span><br><span class="line">                                         kernel_size=(kernel_size, kernel_size), stride=stride,</span><br><span class="line">                                         padding=padding, dilation=dilation, groups=groups, bias=<span class="literal">False</span>,</span><br><span class="line">                                         padding_mode=padding_mode)</span><br><span class="line">            self.square_bn = nn.BatchNorm2d(num_features=out_channels, affine=use_affine)</span><br><span class="line"></span><br><span class="line">            center_offset_from_origin_border = padding - kernel_size // <span class="number">2</span></span><br><span class="line">            ver_pad_or_crop = (padding, center_offset_from_origin_border)</span><br><span class="line">            hor_pad_or_crop = (center_offset_from_origin_border, padding)</span><br><span class="line">            <span class="keyword">if</span> center_offset_from_origin_border &gt;= <span class="number">0</span>:</span><br><span class="line">                self.ver_conv_crop_layer = nn.Identity()</span><br><span class="line">                ver_conv_padding = ver_pad_or_crop</span><br><span class="line">                self.hor_conv_crop_layer = nn.Identity()</span><br><span class="line">                hor_conv_padding = hor_pad_or_crop</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.ver_conv_crop_layer = CropLayer(crop_set=ver_pad_or_crop)</span><br><span class="line">                ver_conv_padding = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                self.hor_conv_crop_layer = CropLayer(crop_set=hor_pad_or_crop)</span><br><span class="line">                hor_conv_padding = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            self.ver_conv = nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=(kernel_size, <span class="number">1</span>),</span><br><span class="line">                                      stride=stride,</span><br><span class="line">                                      padding=ver_conv_padding, dilation=dilation, groups=groups, bias=<span class="literal">False</span>,</span><br><span class="line">                                      padding_mode=padding_mode)</span><br><span class="line"></span><br><span class="line">            self.hor_conv = nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=(<span class="number">1</span>, kernel_size),</span><br><span class="line">                                      stride=stride,</span><br><span class="line">                                      padding=hor_conv_padding, dilation=dilation, groups=groups, bias=<span class="literal">False</span>,</span><br><span class="line">                                      padding_mode=padding_mode)</span><br><span class="line">            self.ver_bn = nn.BatchNorm2d(num_features=out_channels, affine=use_affine)</span><br><span class="line">            self.hor_bn = nn.BatchNorm2d(num_features=out_channels, affine=use_affine)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> reduce_gamma:</span><br><span class="line">                <span class="keyword">assert</span> <span class="keyword">not</span> use_last_bn</span><br><span class="line">                self.init_gamma(<span class="number">1.0</span> / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> use_last_bn:</span><br><span class="line">                <span class="keyword">assert</span> <span class="keyword">not</span> reduce_gamma</span><br><span class="line">                self.last_bn = nn.BatchNorm2d(num_features=out_channels, affine=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> gamma_init <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="keyword">not</span> reduce_gamma</span><br><span class="line">                self.init_gamma(gamma_init)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_gamma</span>(<span class="params">self, gamma_value</span>):</span></span><br><span class="line">        init.constant_(self.square_bn.weight, gamma_value)</span><br><span class="line">        init.constant_(self.ver_bn.weight, gamma_value)</span><br><span class="line">        init.constant_(self.hor_bn.weight, gamma_value)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init gamma of square, ver and hor as &#x27;</span>, gamma_value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">single_init</span>(<span class="params">self</span>):</span></span><br><span class="line">        init.constant_(self.square_bn.weight, <span class="number">1.0</span>)</span><br><span class="line">        init.constant_(self.ver_bn.weight, <span class="number">0.0</span>)</span><br><span class="line">        init.constant_(self.hor_bn.weight, <span class="number">0.0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init gamma of square as 1, ver and hor as 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.deploy:</span><br><span class="line">            <span class="keyword">return</span> self.fused_conv(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            square_outputs = self.square_conv(<span class="built_in">input</span>)</span><br><span class="line">            square_outputs = self.square_bn(square_outputs)</span><br><span class="line">            vertical_outputs = self.ver_conv_crop_layer(<span class="built_in">input</span>)</span><br><span class="line">            vertical_outputs = self.ver_conv(vertical_outputs)</span><br><span class="line">            vertical_outputs = self.ver_bn(vertical_outputs)</span><br><span class="line">            horizontal_outputs = self.hor_conv_crop_layer(<span class="built_in">input</span>)</span><br><span class="line">             = self.hor_conv(horizontal_outputs)</span><br><span class="line">            horizontal_outputs = self.hor_bn(horizontal_outputs)</span><br><span class="line">            result = square_outputs + vertical_outputs + horizontal_outputs</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self, <span class="string">&#x27;last_bn&#x27;</span>):</span><br><span class="line">                <span class="keyword">return</span> self.last_bn(result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="Transposed-Convolution-Deconvolution"><a href="#Transposed-Convolution-Deconvolution" class="headerlink" title="Transposed Convolution / Deconvolution"></a>Transposed Convolution / Deconvolution</h2><p>反卷积/转置卷积是上采样过程。</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_1a988c699452eb8e51899e65db49db05.png" alt="No padding，no strides，transposed"></p>
<h2 id="计算复杂度和参数量"><a href="#计算复杂度和参数量" class="headerlink" title="计算复杂度和参数量"></a>计算复杂度和参数量</h2><ul>
<li><code>MACs</code> 或 <code>MAdds</code>， 加乘数，（a*x+b as 1 MAC）</li>
<li>FLOPs，floating point operations. 浮点运算数<ul>
<li>FLOPs = 2MACs</li>
</ul>
</li>
</ul>
<p>JVET nnvc-ctc 脚本使用 torchsummary+ptflops(get_model_complexity_info) 计算，结果对齐 MACs/pixel（=结果/输入尺寸）。torchstat计算出的差2倍。</p>
<ul>
<li>param各包计算结果相同</li>
</ul>
]]></content>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Coding / Deblocking Filter</title>
    <url>/2021/10/20/dbk/</url>
    <content><![CDATA[<blockquote>
<p>VVC环路滤波：去块滤波器</p>
</blockquote>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>主要用于去除因为基于块的运动预测和变换导致的块状伪影<ul>
<li>在 VVC 中，变换尺寸最大到 64×64 </li>
<li>DBF 主要用来提升主观质量，因此 BD-rate 数值并不是很有意义。</li>
</ul>
</li>
<li>在去块滤波方面，VVC 相比于 HEVC 的主要变化是：<ul>
<li>亮度和色度都有更强（更多抽头）的去块滤波器，<ul>
<li>主要原因是 VVC 有大到 64×64 的变换块，CTU 尺寸是 128×128</li>
</ul>
</li>
<li>亮度 4×4 网格去块滤波</li>
<li>子块边界去块滤波（仿射和 STMVP）<ul>
<li>运动矢量不同，也会有一点块效应</li>
</ul>
</li>
<li>去块决策适用于运动中更小的差异<ul>
<li>HEVC 中亮度整像素，VVC 中半像素</li>
</ul>
</li>
<li>亮度自适应去块滤波</li>
<li>Tc 表扩展到 10 bit 视频<ul>
<li>HEVC 中只对 8 bit 视频</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下图是一个典型的块效应，在靠近块边界的地方存在一个很大的阶越，图中的 p0 和 q0 之间，这会使主观质量下降。</p>
<p><img src="/img/VVC/blk.png"  /></p>
<p>去方块滤波的基本原理是对平滑区域的不连续边界做强滤波，对纹理丰富区域不滤波或弱滤波。处理顺序是先对整帧图像的垂直边界进行水平滤波，然 后对水平边界进行垂直滤波。这种架构使得多个水平滤波或垂直滤波可以并行进行，也可以逐 CTB 处理。</p>
<p>对于亮度，VVC 可以对 CU 边界、TU 子块边界的 4x4 块边界进行滤波，以及对 PU 子 块边界的 8x8 块边界进行滤波。对于色度可以对CU和TU进行8x8的边界滤波。</p>
<blockquote>
<p>PU 子块包括 SbTMVP 和仿射模式产生的子块， TU 子块包括SBT 和 ISP 模式产生的子块。对于采用矩形变换核的亮度块，也可以对 4x4 的块边界进行去方块滤波。</p>
</blockquote>
<p>需要注意的是如果去方块滤波处理的是 8x8 的块边界，实际上是将 8x8 的块分成两部分单独处理，垂直边界以 8x4 为基本单位，水平边界以 4x8 为基本 单位。</p>
<h2 id="滤波过程"><a href="#滤波过程" class="headerlink" title="滤波过程"></a>滤波过程</h2><h3 id="1-确定滤波长度"><a href="#1-确定滤波长度" class="headerlink" title="1. 确定滤波长度"></a>1. 确定滤波长度</h3><p>滤波长度$S_P$,$ S_Q$：$P\ Q$块中滤波的像素个数，取决于块大小。</p>
<p>用于决策滤波的样本：$p_{x,i}…q_{x,i}\ with\ x=0..N\ and\ i=0,3$，共$S_P+1$, $S_Q+1$个</p>
<p>滤波样本：$p_{x,i}…q_{x,i} with\ x=0..N−1\ and\ i=0..3$</p>
<p><img src="/img/VVC/pq.png" style="zoom: 50%;" /></p>
<h4 id="luma"><a href="#luma" class="headerlink" title="luma"></a>luma</h4><p>CU/TU的$ S_P$/$S_Q$初始化为：</p>
<ul>
<li><p>CU/TU block side size &gt;= 32, SP and SQ = 7.</p>
</li>
<li><p>CU/TU block side size&lt;= 4, SP and SQ = 1.  </p>
</li>
<li>Otherwise, remaining uninitialized SP/SQ = 3.</li>
</ul>
<p>If a CU uses PUs, SP/SQ of the CU/TU boundary is set as follows: </p>
<ul>
<li>If  CU/TU  boundary  is  8  samples  distant  from  a  PU boundary, corresponding SP or SQ &lt;= 5. </li>
</ul>
<p>SP/SQ of the PU boundary: </p>
<ul>
<li><p>If the PU boundary is 8 samples distant from a CU/TU boundary, SP and SQ &lt;= 2. </p>
</li>
<li><p>if the PU boundary is 4 samples distant from a CU/TU boundary, SP and SQ = 1. </p>
</li>
<li><p>Otherwise, SP and SQ = 3. </p>
</li>
</ul>
<p>SP  on  the  upper  side  of  a  horizontal  CTU  boundary,  is restricted to be &lt;= 3. （减少行缓冲区）</p>
<blockquote>
<p>for CU/TU boundaries, SP+SQ, can be 7+7, 7+5, 5+7, 5+5, 7+3, 3+7, 5+3, 3+5, 3+3 or 1+1</p>
<p>for PU boundaries  inside  a  CU， 3+3, 2+2 or 1+1 </p>
</blockquote>
<p>这些滤波长度可以在随后的过滤决策步骤中进一步减少。</p>
<h4 id="chroma"><a href="#chroma" class="headerlink" title="chroma"></a>chroma</h4><ul>
<li>the CU/TU block side sizes orthogonal to the block boundary are both &gt;= 8 in chroma samples, $S_P $and$ S_Q $=3</li>
<li>Otherwise, $S_P$ and $S_Q$ = 1.</li>
</ul>
<p>The deblocking length for the upper side of a horizontal CTU boundary, SP, is restricted to be 1</p>
<blockquote>
<p> $S_P+S_Q$, can thus be 3+3, 1+3 or 1+1.  </p>
</blockquote>
<h3 id="2-根据边界两侧的编码模式和编码参数确定边界强度BS"><a href="#2-根据边界两侧的编码模式和编码参数确定边界强度BS" class="headerlink" title="2. 根据边界两侧的编码模式和编码参数确定边界强度BS"></a>2. 根据边界两侧的编码模式和编码参数确定边界强度BS</h3><p>边界强度值在一 定程度上反映了两个相邻块编码参数的一致性，相邻块采用的编码参数越一致， 其边界强度越小。</p>
<p><img src="/img/VVC/bs.png" style="zoom:80%;" /></p>
<ul>
<li>对于luma，BS=2 或 1 表示需要进行滤波，BS=0 表示不需要进行滤波。</li>
</ul>
<ul>
<li>对于色度，BS=2 或1且为大块边界表示需要进行滤波，其余情况不需要进行滤波。“大块”即边界长度大于等于32的块。<ul>
<li>If both $S_P$ and$ S_Q $=1 and bS != 2,$ S_P$ and$S_Q $= 0. </li>
<li>When$ S_Q$ = 3 and bS is non-zero, an additional decision based on spatial activity is made.  </li>
</ul>
</li>
</ul>
<h3 id="3-根据空间活动性确定滤波强度"><a href="#3-根据空间活动性确定滤波强度" class="headerlink" title="3.根据空间活动性确定滤波强度"></a>3.根据空间活动性确定滤波强度</h3><p>根据边界两侧像素的变化程度判断块的内容特性，确定该边界是否需要滤波处理。滤波强度由阈值$\beta$和$t_c$决定。</p>
<p><img src="/img/VVC/eq.png" style="zoom: 25%;" /> $i=0，3$</p>
<h4 id="luma-1"><a href="#luma-1" class="headerlink" title="luma"></a>luma</h4><h5 id="滤波长度-lt-3，判断是否应用short-tap-deblocking-filter，同HEVC。"><a href="#滤波长度-lt-3，判断是否应用short-tap-deblocking-filter，同HEVC。" class="headerlink" title="滤波长度&lt;=3，判断是否应用short-tap deblocking filter，同HEVC。"></a>滤波长度&lt;=3，判断是否应用short-tap deblocking filter，同HEVC。</h5><p>首先判断方程中的1式，即边界两遍的信号变化低于指定的阈值。</p>
<p><img src="/img/VVC/eq1.png" style="zoom: 50%;" /></p>
<p>即</p>
<p>$\begin{array}{l}<br>\left|p_{2,0}-2 p_{1,0}+p_{0,0}\right|+\left|q_{2,0}-2 q_{1,0}+q_{0,0}\right|+\left|p_{2,3}-2 p_{1,3}+p_{0,3}\right|+\left|q_{2,3}-2 q_{1,3}+q_{0,3}\right|&lt;\beta<br>\end{array}$</p>
<p>其次判断应用strong or normal。通过下式选择强滤波还是普通滤波，其中$i=0,3$<img src="/img/VVC/sw.png" style="zoom:67%;" /></p>
<p>如果(2)、(3)和(4)式都成立，则进行强滤波，否则进行普通滤波。</p>
<blockquote>
<p>(2)保证了边缘两边满足更小的局部自适应，<br>(3)保证了边缘两边的信号的平稳，<br>(4)保证边缘两遍的像素值跳变小于一个阈值。</p>
</blockquote>
<h5 id="至少一边滤波长度-gt-3，判断是否应用long-tap-deblocking-filter，为VVC新增。"><a href="#至少一边滤波长度-gt-3，判断是否应用long-tap-deblocking-filter，为VVC新增。" class="headerlink" title="至少一边滤波长度&gt;3，判断是否应用long-tap deblocking filter，为VVC新增。"></a>至少一边滤波长度&gt;3，判断是否应用long-tap deblocking filter，为VVC新增。</h5><p>为了去除平坦区域大尺寸块的方块效应，VVC 采用更长抽头的滤波器。设$S_P$&gt;3。方程中的每一项增加以下项：</p>
<ul>
<li><p>对$dPQ_i$：增加$\left|p_{3, i}-2 p_{4, i}+p_{5, i}\right|$</p>
</li>
<li><p>对$sP_i$</p>
<ul>
<li>若$S_P=5$，增加$|p_{3, i} - p_{s_p,i}|$</li>
<li>若$S_P=7$，增加$\left|p_{4, i}-p_{5, i}-p_{6, i}+p_{7, i}\right|$</li>
</ul>
</li>
</ul>
<p>避免过平滑，相应$thr$也要修改。</p>
<ul>
<li><p>$thr1$改为$\beta$&gt;&gt;4</p>
</li>
<li><p>$thr2$ 改为3$\beta$&gt;&gt;5</p>
</li>
</ul>
<p>若不满足使用long-tap deblocking filter的条件，转为判断是否使用short-tap deblocking filter。</p>
<h4 id="chroma-1"><a href="#chroma-1" class="headerlink" title="chroma"></a>chroma</h4><p>滤波长度大于3，判断四个条件，如果是420格式改为判断第0行和第1行的像素，否则还是1，3行。满足用强滤波，不满足滤波长度减到1判断是否使用弱滤波。</p>
<h3 id="4-滤波处理"><a href="#4-滤波处理" class="headerlink" title="4. 滤波处理"></a>4. 滤波处理</h3><h4 id="luma-2"><a href="#luma-2" class="headerlink" title="luma"></a>luma</h4><h5 id="更强滤波（long-tap-deblocking-filter），为双线性滤波器。"><a href="#更强滤波（long-tap-deblocking-filter），为双线性滤波器。" class="headerlink" title="更强滤波（long-tap deblocking filter），为双线性滤波器。"></a>更强滤波（long-tap deblocking filter），为双线性滤波器。</h5><p>$i = 0\ to\ 3$,  $k = 0\ to$ $S_P−1$,$ l = 0\ to$ $S_Q−1$</p>
<script type="math/tex; mode=display">
\begin{align*} &p\hbox{"}_{k,i}=Clip3\left(p_{k,i}-t_{CPk},p_{k,i}+t_{CPk},p\hbox{'}_{k,i}\right),\\ &q\hbox{"}_{l,i}=Clip3\left(q_{l,i}-t_{CQl},q_{l,i}+t_{CQl},q_{l,i}\right),\\ &p\hbox{'}_{k,i}=(f_{k}\cdot refM_{i}+(64-f_{k})\cdot refP_{i}+32) >> 6,\\ &q\hbox{'}_{l,i}=(g_{l}\cdot refM_{i}+(64-g_{l})\cdot refQ_{i}+32) >> 6,\\ &refP_{i}=(p_{Sp,i}+p_{Sp+1_{r}i}+1) >> 1,\tag{1}\\ &refQ_{i}=(q_{Sq,i}+q_{Sq+1,i}+1) >> 1,\\ &refM_{i}=\left(\sum_{m=1}^{6}(p_{m,i}+q_{m,i})+2\cdot(p_{0,i}+q_{0,i})+8\right) >> 4,\\ &\pmb{f}=\pmb{g}=\{59,50,41,32,23,14,5\},\\ &\pmb{t}_{\pmb{CP}}=\pmb{t}_{\pmb{CQ}}=(t_{C}\cdot\{6,5,4,3,2,1,1\}) >> 1, \end{align*}</script><h5 id="强滤波（short-tap-strong-deblocking-filter）-，对每块的每行-3-个像素进行修正"><a href="#强滤波（short-tap-strong-deblocking-filter）-，对每块的每行-3-个像素进行修正" class="headerlink" title="强滤波（short-tap strong deblocking filter） ，对每块的每行 3 个像素进行修正"></a><strong>强</strong>滤波（short-tap strong deblocking filter） ，对每块的每行 3 个像素进行修正</h5><p>$\delta_{0 s}=\left(p_{2}+2 p_{1}+2 p_{0}+2 q_{0}+q_{1}+4\right)&gt;&gt;3$</p>
<p>$\delta_{1 s}=\left(p_{2}+ p_{1}+p_{0}+q_{0}+2\right)&gt;&gt;2$</p>
<p>$\delta_{2 s}=\left(2 p_{3}+3 p_{2}+p_{1}+p_{0}+q_{0}+4\right)&gt;&gt;3 .$</p>
<p>$\delta$进行$clip$操作得到滤波后像素。相当于分别进行了$(1, 2, 2, 2, 1)/8$、$(1, 1, 1, 1)/4$和$(2, 3, 1, 1, 1)/8$的滤波操作。对$\delta$的$0，1，2$，$clip$的区间分别为$[p0-3tc, p0+3tc],[p1-2tc, p1+2tc],[p2-tc, p2+tc]$</p>
<h5 id="弱滤波（short-tap-normal-deblocking-filter）"><a href="#弱滤波（short-tap-normal-deblocking-filter）" class="headerlink" title="弱滤波（short-tap normal deblocking filter）"></a><strong>弱</strong>滤波（short-tap normal deblocking filter）</h5><p>通过下式判断修改几个像素值，满足式子则改变两个，否则改变一个。块越平坦也就意味着$P$和$Q$的边界越明显，即需要改变的像素也就越多</p>
<p><img src="/img/VVC/weak.png" style="zoom: 67%;" /></p>
<p>对于$i=0,1,2,3$的每一行，进行滤波前还需要单独进行下式条件判断，只有满足，该行才能够进行滤波。避免对正常存在的块边界进行不必要的滤波，因为当$\delta$绝对的大于10倍tc时，一般不太可能是由于块效应导致的。</p>
<p><img src="/img/VVC/weak2.png" style="zoom: 80%;" /></p>
<p>满足上式时，无论哪种情况，都需要对p0和q0进行滤波，</p>
<p><img src="/img/VVC/p0q0.png" style="zoom: 80%;" /></p>
<p>$\delta_{0}$的clip区间为$[-tc, tc]$。</p>
<p>当条件(5)满足时，则需要对p1进行滤波；当条件(6)满足时，需要对q1进行滤波。对p1/q1滤波操作如下：   </p>
<p><img src="/img/VVC/p1q1.png" style="zoom: 80%;" /></p>
<p>$\delta_{p1}$和$\delta_{q1}$的clip区间为$[-\frac{tc}{2}, \frac{tc}{2}]$,</p>
<blockquote>
<p>clip操作是将$\delta$的值限定到$[-c, c]$的区间,</p>
<p><img src="/img/VVC/clip.png" style="zoom: 70%;" /></p>
</blockquote>
<h4 id="chroma-2"><a href="#chroma-2" class="headerlink" title="chroma"></a>chroma</h4><h5 id="强滤波（long-tap-chroma-deblocking-filter）"><a href="#强滤波（long-tap-chroma-deblocking-filter）" class="headerlink" title="强滤波（long-tap  chroma deblocking filter）"></a>强滤波（long-tap  chroma deblocking filter）</h5><p>$S_P$  and $ S_Q$ = 3</p>
<p><img src="/img/VVC/chroma-strong.png" style="zoom: 40%;" /></p>
<p>$S_P$= 1 and $S_Q$ = 3</p>
<p><img src="/img/VVC/13.png" style="zoom: 40%;" /></p>
<p>$clip$到$[p-tc, p+tc]$或$[q-tc, q+tc]$</p>
<h5 id="弱滤波（-short-tap-chroma-deblocking-filter）"><a href="#弱滤波（-short-tap-chroma-deblocking-filter）" class="headerlink" title="弱滤波（ short-tap chroma deblocking filter）"></a>弱滤波（ short-tap chroma deblocking filter）</h5><p>both $S_P$ and $S_Q$ = 1</p>
<p><img src="/img/VVC/chroma-weak.png" style="zoom: 67%;" /></p>
<p>clip到$[-tc, tc]$后分别加/减到p0/q0上。</p>
<h2 id="luma-adaptive-deblocking-filter"><a href="#luma-adaptive-deblocking-filter" class="headerlink" title="luma adaptive deblocking filter"></a>luma adaptive deblocking filter</h2><ul>
<li>基本思想：块失真在更亮的区域更明显<ul>
<li>特别为 HDR 格式调优</li>
<li>通过增加tc和 $\beta$ 获取的 qpOffset 增加了去块强度</li>
</ul>
</li>
</ul>
<p>在HEVC中滤波强度由$\beta$和tc决定，而$\beta$和tc是由平均量化参数$qPL$生成。</p>
<p>在VVC中为$qPL$增加一个偏移值，偏移量由重建像素的平均亮度级$LL$决定。</p>
<p><img src="/img/VVC/ll.png" style="zoom: 50%;" /></p>
<p><img src="/img/VVC/mapping.png" style="zoom: 67%;" /></p>
<p>$LL$的范围在SPS中传输。</p>
<p><img src="/img/VVC/qpl.png" style="zoom: 50%;" /></p>
<p>$Q_{beta} = clip3(0.63, qPL+(sh_beta_offset_div2&lt;&lt;1))$</p>
<p>$Q_{tc} = clip3(0.65, qPL+ 2*(bS-1)+(sh_tc_offset_div2&lt;&lt;1))$</p>
<p><img src="/img/VVC/beta.png" style="zoom: 67%;" /></p>
<p><img src="/img/VVC/beta1.png" style="zoom: 50%;" /></p>
<p>$t_{C}=\left\{\begin{array}{cl}\left(t_{C}^{\prime}+(1&lt;&lt;(9-\text { BitDepth }))&gt;&gt;(10-\text { BitDepth }),\right. &amp; \text { BitDepth }&lt;10 \\ t_{C}^{\prime} *(1&lt;&lt;(\text { BitDepth }-10)), &amp; \text { BitDepth } \geq 10\end{array}\right.$</p>
<p>在slice级中有相应的语法元素：tc_offset_div2 和 beta_offset_div2。tc和$\beta$计算时，相应地把tc−offset−div2 和beta−offset−div2的2倍加到当前的QP上，从而调整tc和$\beta$的值，实现对滤波的自适应控制。</p>
<p><img src="/img/VVC/dbk.png" style="zoom: 80%;" /></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>anchor为相应的工具关闭。</p>
<p><img src="/img/VVC/dbfres.png" style="zoom: 50%;" /></p>
<p><img src="/img/VVC/dbfres2.png" style="zoom: 33%;" /></p>
<p><img src="/img/VVC/dbkres1.png" style="zoom:;" /></p>
<p><img src="/img/VVC/dbkres.png" style="zoom:;" /></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="/img/VVC/codedbk.png" style="zoom:;" /></p>
]]></content>
      <tags>
        <tag>VVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/06/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a></p>
</blockquote>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo配置</title>
    <url>/2021/07/07/hexo/</url>
    <content><![CDATA[<blockquote>
<p>hexo，快速、简洁且高效的博客框架</p>
</blockquote>
<span id="more"></span>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="regexp">//</span> 清除缓存</span><br><span class="line">hexo g <span class="regexp">//</span> 创建静态文件</span><br><span class="line">hexo s <span class="regexp">//</span> 本地运行</span><br><span class="line">hexo d <span class="regexp">//</span> 部署到远程</span><br></pre></td></tr></table></figure>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>主题文件夹放在<code>./theme/</code> 下，<code>_config.yml</code> 中<code>theme:</code> 改成主题文件夹名</p>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>文章存放路径<code>/source/_posts/*.md</code></p>
<ul>
<li>文章头部</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="string">/8/3</span> <span class="number">18</span><span class="string">:20:00</span> <span class="string">//发布时间</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">hexo</span> <span class="string">//分类</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span> <span class="string">//使用mathjax渲染公式</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">hexo博客</span> <span class="string">//标题</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文章折叠</li>
</ul>
<p>需要折叠的部分之前加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>正文中插入目录</li>
</ul>
<p>以下 hexo-toc 插件与  next 主题侧边目录栏冲突(安装后导致侧边栏目录失效)</p>
<blockquote>
<p>安装<code>npm install hexo-toc --save</code><br>在博客根目录下的 <code>_config.yml</code> 中如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;#文章目录</span></span><br><span class="line"><span class="string">&gt;toc:</span></span><br><span class="line">   <span class="attr">maxDepth:</span> <span class="number">3</span> <span class="comment">#表示目录深度为3，即最多生成三级目录</span></span><br></pre></td></tr></table></figure>
<p>在Markdown中需要显示文章目录的地方添加<br><code>&lt;!-- toc --&gt;</code></p>
</blockquote>
<ul>
<li>公式</li>
</ul>
<p>卸载原有公式渲染引擎 <code>npm uninstall hexo-renderer-marked --save</code><br>安装kramed <code>npm install hexo-renderer-kramed --save</code></p>
<blockquote>
<p>问题1：kramed对<code>\,&#123;,&#125;</code>有转义，无法正常显示</p>
<p>解决方法：</p>
<p>定位到博客根目录，找到<code>/node_modules/kramed/lib/rules/inline.js</code>文件，进行部分修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,      第11行，将其修改为</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    第20行，将其修改为</span></span><br><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<p>问题2：公式中以下符号会解析错误<code>&#123;&#123;` `&#125;&#125;</code> <code>&#123;%` `%&#125;</code></p>
<p>解决方法：中间加空格，变为<code>&#123; &#123;</code> <code>&#125; &#125;</code> <code>&#123; %</code> <code>% &#125;</code></p>
</blockquote>
<ul>
<li>图片居中(md支持html语法)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/img/...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="多分支管理"><a href="#多分支管理" class="headerlink" title="多分支管理"></a>多分支管理</h2><p>同时管理了两个分支：</p>
<ul>
<li>master -负责展示静态网页</li>
<li>hexo -备份本地hexo文件（默认分支）</li>
</ul>
<p>执行<code>hexo d</code>时，自动更新master分支（config文件中deploy配置）</p>
<p>add, commit, pull更新hexo分支需要备份的源文件</p>
<h2 id="中文目录无法跳转"><a href="#中文目录无法跳转" class="headerlink" title="中文目录无法跳转"></a>中文目录无法跳转</h2><p><a href="https://github.com/theme-next/hexo-theme-next/pull/1540/files">fix: Chinese TOC cannot jump by jiangtj · Pull Request #1540 · theme-next/hexo-theme-next (github.com)</a></p>
<p>解决方法：在 <code>themes/next/source/js/util.js</code> 中增加两行代码，删除两行代码。保存后<code>hexo clean &amp; hexo g &amp; hexo s</code> 即可解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> navItems = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.post-toc li&#x27;</span>);</span><br><span class="line">   <span class="keyword">const</span> sections = [...navItems].map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> link = element.querySelector(<span class="string">&#x27;a.nav-link&#x27;</span>);</span><br><span class="line">     <span class="comment">//增加该行</span></span><br><span class="line">     <span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(<span class="built_in">decodeURI</span>(link.getAttribute(<span class="string">&#x27;href&#x27;</span>)).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">     <span class="comment">// TOC item animation navigate.</span></span><br><span class="line">     link.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">       event.preventDefault();</span><br><span class="line">       <span class="comment">//删除该行</span></span><br><span class="line">       <span class="comment">//var target = document.getElementById(event.currentTarget.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">       <span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">       <span class="built_in">window</span>.anime(&#123;</span><br><span class="line">         <span class="attr">targets</span>  : <span class="built_in">document</span>.scrollingElement,</span><br><span class="line">         <span class="attr">duration</span> : <span class="number">500</span>,</span><br><span class="line">         <span class="attr">easing</span>   : <span class="string">&#x27;linear&#x27;</span>,</span><br><span class="line">         <span class="attr">scrollTop</span>: offset + <span class="number">10</span></span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">// 删除该行 </span></span><br><span class="line">     <span class="comment">//return document.getElementById(link.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">     <span class="comment">// 增加该行</span></span><br><span class="line">     <span class="keyword">return</span> target;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>无法解决的问题尝试清除缓存<code>hexo clean</code>后重新生成</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java / HTML与CSS</title>
    <url>/2021/08/06/html%E4%B8%8Ecss/</url>
    <content><![CDATA[<blockquote>
<p>HTML，超文本标记式编程语言，是一种专门在浏览器编译与执行的编程语言。用于通知浏览器将接收的数据以指定方式在窗口展示；控制浏览器请求行为。CSS则用于定位浏览器中HTML标签并对定位的HTML标签中【样式属性】进行统一管理。</p>
</blockquote>
<span id="more"></span>
<h2 id="HTML语法规范"><a href="#HTML语法规范" class="headerlink" title="HTML语法规范"></a>HTML语法规范</h2><ul>
<li>所有命令都是声明在标签中,比如<code>&lt;br&gt;</code></li>
<li>不区分英文字母大小写，比如<code>&lt;BR&gt;</code>,<code>&lt;br&gt;</code>, <code>&lt;Br&gt;</code> 都是合法命令</li>
<li>命令开发时主要通过对命令中属性进行赋值实现开发目的。</li>
</ul>
<p>属性赋值时内容可以包含在<code>&quot;&quot;</code>中，也可以包含在<code>&#39;&#39;</code>，也可以省略双引号与单引号，此时属性之间必须采用空格进行隔离。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;one&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">name</span>=<span class="string">one/</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>命令根据书写方式分为：双目标签命令与单目标签命令</li>
</ul>
<p>双目标签命令书写命令分别出现在开始标签与结束标签，比如 <code>&lt;tr&gt;&lt;/tr&gt;</code>，结束标签不能省略<br>单目标签命令书写命令出现一个标签之内，比如<code>&lt;br/&gt;</code><br>单目标签命令用于表示结束”/“可以省略不写，比如 <code>&lt;br/&gt;</code>, <code>&lt;br&gt;</code> 这两个都是合法单目标签命令</p>
<h2 id="浏览器发送请求三要素"><a href="#浏览器发送请求三要素" class="headerlink" title="浏览器发送请求三要素"></a>浏览器发送请求三要素</h2><p>控制浏览器发送请求地址；请求方式；携带请求参数</p>
<h3 id="控制浏览器发送请求地址"><a href="#控制浏览器发送请求地址" class="headerlink" title="控制浏览器发送请求地址"></a>控制浏览器发送请求地址</h3><h4 id="超链接标签命令"><a href="#超链接标签命令" class="headerlink" title="超链接标签命令"></a>超链接标签命令</h4><ul>
<li>格式：  <code>&lt;a href=&quot;请求地址&quot;&gt;提示信息&lt;/a&gt;</code></li>
<li>原理：  超链接标签命令不会被浏览器自动执行。在用户使用鼠标单击超链接标签命令时，命令才会执行，执行要求浏览器立刻按照href属性地址发送请求</li>
</ul>
<h4 id="表单标签命令"><a href="#表单标签命令" class="headerlink" title="表单标签命令"></a>表单标签命令</h4><ul>
<li><p>格式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;请求地址&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="comment">&lt;!--提交按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原理：表单标签命令不会被浏览器自动执行。在用户单击提交按钮时，此时表单标签命令被触发执行。执行时要求浏览器立刻按照action属性地址发送请求</p>
</li>
</ul>
<h3 id="控制浏览器发送请求采用请求方式"><a href="#控制浏览器发送请求采用请求方式" class="headerlink" title="控制浏览器发送请求采用请求方式"></a>控制浏览器发送请求采用请求方式</h3><p>请求方式：决定浏览器在发送请求时行为特征<br>浏览器可以选择请求方式：7种，目前为止只考虑【POST请求方式】和【GET请求方式】</p>
<blockquote>
<p>GET请求方式：<br>要求浏览器发送请求时，携带的【请求参数数量】不能超过4K；必须在浏览器地址栏上将【请求参数信息】展示出来；必须将请求参数信息保存在Http请求协议包中【请求头】；要求浏览器在接收到服务器返回的资源文件内容后，必须将资源文件内容保存在浏览器的缓存</p>
<p>POST请求方式：<br>要求浏览器发送请求时，可以携带任意数量的【请求参数】；必须在浏览器地址栏上隐藏请求参数信息；必须将请求参数信息保存在Http请求协议包中【请求体】；禁止浏览器将服务器返回资源文件内容进行保存【阅后即焚】</p>
</blockquote>
<h4 id="控制浏览器发送请求时采用GET请求方式"><a href="#控制浏览器发送请求时采用GET请求方式" class="headerlink" title="控制浏览器发送请求时采用GET请求方式"></a>控制浏览器发送请求时采用GET请求方式</h4><ul>
<li>超链接标签命令在执行时，要求浏览器必须采用GET方式发送请求</li>
<li>表单标签存在一个method属性，通过这个属性可以要求浏览器采用对应请求方式发送请求</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;请求地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;请求地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--method属性默认值是GET--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;请求地址&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="控制浏览器发送请求时采用POST请求方式"><a href="#控制浏览器发送请求时采用POST请求方式" class="headerlink" title="控制浏览器发送请求时采用POST请求方式"></a>控制浏览器发送请求时采用POST请求方式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="请求方式适用场景"><a href="#请求方式适用场景" class="headerlink" title="请求方式适用场景"></a>请求方式适用场景</h4><p>考虑到POST请求方式，用户可以将【病毒文件内容】发送到服务器上进行攻击。因此绝大多数门户级网站拒绝接收POST请求，日常开发过程绝大多数请求都是GET。在某些特殊场景下必须使用POST：</p>
<ul>
<li>文件上传</li>
<li>发起登录验证请求</li>
<li>索要服务器中实时变化数据时（股票价格，车票数量……）</li>
</ul>
<h3 id="控制浏览器发送请求携带请求参数"><a href="#控制浏览器发送请求携带请求参数" class="headerlink" title="控制浏览器发送请求携带请求参数"></a>控制浏览器发送请求携带请求参数</h3><p>方法运行时需要实参，需要由用户通过浏览器以请求参数方式提供。如<code>http：//www.baidu.com?n1=100&amp;n2=200</code>  [n1=100&amp;n2=200]就是浏览器发送请求参数。</p>
<p>请求参数格式：请求地址?请求参数名1=值1&amp;请求参数名2=值2<br>浏览器发送请求时携带的请求参数来源：</p>
<ul>
<li><p>通过超链接标签命令指定请求参数<br><code>&lt;a href=&quot;http：//www.baidu.com?userName=mike&amp;password=123&quot;&gt;百度&lt;/a&gt;</code></p>
</li>
<li><p>通过表单域标签命令指定请求参数<br>表单域标签命令，一组声明在form标签内部的标签命令，提示用户填写对应的【请求参数内容】，用于提供相对灵活的请求参数内容<br>表单域标签分类：<code>&lt;input /&gt;</code>，<code>&lt;select&gt;&lt;/select&gt;</code>，<code>&lt;textarea&gt;&lt;/textarea&gt;</code><br>所有的表单域标签都拥有两个属性：name属性声明【请求参数名】；value属性声明【请求参数内容】</p>
</li>
</ul>
<blockquote>
<p>value属性默认值<br>大多数表单域标签value属性默认值是空字符串 userName=’ ‘<br>对于radio与checkbox来说，value属性默认值’on’字符串</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http：//www.baidu.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mike&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当用户单击submit后，浏览器发送请求信息 <code>http：//www.baidu.com?userName=mike</code></p>
<blockquote>
<p>表单域标签作为请求参数条件</p>
</blockquote>
<p>对于大多数表单域标签来说，只要同时满足两个条件，就可以作为请求参数：必须声明在form标签内部；必须声明name属性。<br>对于radio标签与checkbox标签来说在满足上述两个条件同时，radio与checkbox必须在【被选中】的情况下才可以作为请求参数。<br>如果表单域标签使用disabled来修饰时，失去作为请求参数条件</p>
<blockquote>
<p>readOnly与disabled：<br>readOnly：要求当前标签中value属性只能看但是不能被修改，readOnly不会影响表单域标签作为请求参数条件<br>disabled：设置当前标签为不可用状态，此时标签中value属性内容不能被修改的。disabled修饰的表单域标签是永远都不能作为请求参数</p>
</blockquote>
<h2 id="HTML标签属性分类"><a href="#HTML标签属性分类" class="headerlink" title="HTML标签属性分类"></a>HTML标签属性分类</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p>大多数HTML标签都拥有的属性，是一个非常庞大群体</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id属性，用于区分HTML标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- name属性，允许一组标签拥有相同name--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;myText&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;myText&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="样式属性"><a href="#样式属性" class="headerlink" title="样式属性"></a>样式属性</h3><p>通知浏览器将HTML标签中数据在浏览器中以指定形态展示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color：red;color：green;width：300px;height：200px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="工作状态属性"><a href="#工作状态属性" class="headerlink" title="工作状态属性"></a>工作状态属性</h3><p>只存在于【表单域标签】中，用于表示【表单域标签】状态。</p>
<blockquote>
<p>checked：存在于radio与checkbox中，表示标签是否被选中<br>disabled：表示标签处于不可用状态<br>readOny：表示标签处于只读状态<br>seleteced：存在option标签，表示标签是否被选中</p>
</blockquote>
<h3 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h3><p>监听属性用于监听用户在何时对当前标签进行何种操作,当指定操作产生时，监听属性将会通知浏览器调用对应JavaScript方法处理当前请求。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>通知浏览器将所有满足定位条件的HTML标签进行统一定位；对已经定位HTML标签中样式属性进行集中统一赋值管理。</p>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>CSS选择器，一组定位条件用于定位HTML标签，有9个大的分类。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!--CSS选择器语法格式--&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;!--type=&#x27;text/css&#x27;，--&gt;</span><br><span class="line">        &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        定位条件&#123;</span><br><span class="line">        &quot;样式属性<span class="number">1</span>&quot;：&quot;值<span class="number">1</span>&quot;;</span><br><span class="line">        &quot;样式属性<span class="number">2</span>&quot;：&quot;值<span class="number">2</span>&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!--ID选择器,根据<span class="selector-tag">HTML</span>标签中ID属性的值进行定位--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-id">#id</span>编号&#123;</span><br><span class="line">        &quot;样式属性<span class="number">1</span>&quot;：&quot;值<span class="number">1</span>&quot;;</span><br><span class="line">        &quot;样式属性<span class="number">2</span>&quot;：&quot;值<span class="number">2</span>&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--标签类型选择器,根据<span class="selector-tag">HTML</span>标签类型进行定位--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    标签类型名&#123;</span><br><span class="line">        &quot;样式属性<span class="number">1</span>&quot;：&quot;值<span class="number">1</span>&quot;;</span><br><span class="line">        &quot;样式属性<span class="number">2</span>&quot;：&quot;值<span class="number">2</span>&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--层级选择器,根据标签之间父子关系或则兄弟关系进行定位--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    定位父标签条件  定位子标签条件&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    找到指定父标签下满足条件的所有子标签</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--自定义选择器--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .自定义选择器名&#123;</span><br><span class="line">        <span class="attribute">color</span>：red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;自定义选择器名&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>   class=&quot;自定义选择器名&quot;&gt;&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java / JSP</title>
    <url>/2021/08/06/jsp/</url>
    <content><![CDATA[<blockquote>
<p>JSP规范来自于JAVAEE规范中一种，制定了如何开发JSP文件<strong>代替响应对象将处理结果写入到响应体</strong>的开发流程制，Http服务器应该如何调用管理JSP文件。放在<code>/web/*.jsp</code>下</p>
</blockquote>
<span id="more"></span>
<h2 id="JSP规范"><a href="#JSP规范" class="headerlink" title="JSP规范"></a>JSP规范</h2><blockquote>
<p>响应对象存在弊端</p>
</blockquote>
<ul>
<li><p>适合将数据量较少的处理结果写入到响应体。如果处理结果数量过多，使用响应对象增加开发难度</p>
<blockquote>
<p>JSP文件优势</p>
</blockquote>
</li>
<li><p>JSP文件在互联网通信过程，是响应对象替代品。降低将处理结果写入到响应体的开发工作量，降低处理结果维护难度。</p>
</li>
<li>在JSP文件开发时，可以直接将处理结果写入到JSP文件，不需要手写out.print命令。</li>
<li><p>在Http服务器调用JSP文件时，根据JSP规范要求自动将JSP文件书写的所有内容通过输出流写入到响应体。</p>
<blockquote>
<p>HTML文件与JSP文件区别</p>
</blockquote>
</li>
<li><p>作为资源文件类型不同<br>HTML文件属于静态资源文件，其相关命令需要在浏览器编译并执行的.<br>JSP文件属于动态资源文件，其相关命令需要在服务端编译并执行的</p>
</li>
<li><p>调用形式不同<br>如果浏览器访问HTML文件，此时Http服务器直接通过一个输出流将HTML文件中所有的内容写入到响应体<br>如果浏览器访问JSP文件。此时Http服务器根据JSP规范来操作JSP文件编辑——&gt;编译——-&gt;调用</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!--在JSP文件中直接书写Java命令，不能被JSP文件识别，此时只会被当做字符串写入到响应体--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="comment">//在只有书写在执行标记&lt;%中内容才会被当做Java命令</span></span><br><span class="line">  <span class="comment">//1.声明Java变量</span></span><br><span class="line">  <span class="keyword">int</span> num1 = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> num2 = <span class="number">200</span>;</span><br><span class="line">  <span class="comment">//2.声明运行表达式：数学运算，关系运算，逻辑运算</span></span><br><span class="line">  <span class="keyword">int</span> num3 = num1 + num2; <span class="comment">//数学运算</span></span><br><span class="line">  <span class="keyword">int</span> num4 = num2&gt;=num1?num2:num1;<span class="comment">//关系运算</span></span><br><span class="line">  <span class="keyword">boolean</span> num5 = num2&gt;=<span class="number">200</span> &amp;&amp; num1&gt;=<span class="number">100</span>;<span class="comment">//逻辑运算</span></span><br><span class="line">  <span class="comment">//3.声明控制语句</span></span><br><span class="line">   <span class="keyword">if</span>(num2&gt;=num1)&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">   <span class="keyword">int</span> num1 =<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> num2 =<span class="number">200</span>;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--在JSP文件，通过输出标记，通知JSP将Java变量的值写入到响应体--&gt;</span><br><span class="line">变量num1的值:&lt;%=num1%&gt;&lt;br/&gt;</span><br><span class="line">变量num2的值:&lt;%=num2%&gt;&lt;br/&gt;</span><br><span class="line">&lt;!--执行标记还可以通知Jsp将运算结果写入到响应体--&gt;</span><br><span class="line">num1 + num2 = &lt;%=num1+num2%&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--制造数据--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">       Student stu1 = <span class="keyword">new</span> Student(<span class="number">10</span>,<span class="string">&quot;mike&quot;</span>);</span><br><span class="line">       Student stu2 = <span class="keyword">new</span> Student(<span class="number">20</span>,<span class="string">&quot;allen&quot;</span>);</span><br><span class="line">       Student stu3 = <span class="keyword">new</span> Student(<span class="number">30</span>,<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">       List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       list.add(stu1);</span><br><span class="line">       list.add(stu2);</span><br><span class="line">       list.add(stu3);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--数据输出--&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;2&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;学员编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;学员姓名&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%</span><br><span class="line">       <span class="keyword">for</span>(Student stu:list)&#123;</span><br><span class="line">    %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=stu.getSid()%&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=stu.getSname()%&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">       &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<h2 id="JSP文件内置对象"><a href="#JSP文件内置对象" class="headerlink" title="JSP文件内置对象"></a>JSP文件内置对象</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">   JSP文件内置对象: request</span><br><span class="line">             类型：HttpServletRequest</span><br><span class="line">             作用: 在JSP文件运行时读取请求包信息</span><br><span class="line">                  与Servlet在请求转发过程中实现数据共享</span><br><span class="line"></span><br><span class="line">  浏览器： http:<span class="comment">//localhost:8080/myWeb/request.jsp?userName=allen&amp;password=123</span></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">   <span class="comment">//在JSP文件执行时，借助于内置request对象读取请求包参数信息</span></span><br><span class="line">    String userName = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    String password =request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">来访用户姓名:&lt;%=userName%&gt;&lt;br/&gt;</span><br><span class="line">来访用户密码:&lt;%=password%&gt;</span><br></pre></td></tr></table></figure>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    JSP文件内置对象:session</span><br><span class="line">              类型:HttpSession</span><br><span class="line">              作用：JSP文件在运行时，可以session指向当前用户私人储物柜，添加共享数据，或则读取共享数据</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--session1.jsp,将共享数据添加到当前用户私人储物柜--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">   <span class="comment">// HttpSession session = request.getSession();</span></span><br><span class="line">   session.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="number">200</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">      session_1.jsp 与session_2.jsp为同一个用户/浏览器提供服务。</span><br><span class="line">      因此可以使用当前用户在服务端的私人储物柜进行数据共享</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;%</span><br><span class="line">     Integer value=(Integer) session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">session_2.jsp从当前用户session中读取数据:&lt;%=value%&gt;</span><br></pre></td></tr></table></figure>
<h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">       JSP文件内置对象 ： application</span><br><span class="line">       ServletContext application;全局作用域对象</span><br><span class="line">       同一个网站中Servlet与JSP，都可以通过当前网站的全局作用域对象实现数据共享       </span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    application.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="JSP文件原理"><a href="#JSP文件原理" class="headerlink" title="JSP文件原理"></a>JSP文件原理</h2><p>Tomcat根据JSP规范，将被访问的JSP文件[编辑]为一个java文件。这个Java文件是Servlet接口实现类；调用JVM（javac one_jsp.java）将这个java文件[编译]为class类型；生成这个class文件的实例对象（Servelt接口实例对象）；通过实例对象调用class文件中_jspService方法，_jspService方法在运行时负责将JSP文件中书写内容写入到响应体中</p>
<blockquote>
<p>_jspService方法内部结构<br>判断当前请求方式。Jsp文件可以接收的请求方式有POST,GET,HEAD<br>声明局部变量。这些局部变量都可以在JSP文件开发时直接使用<br>输出部分。这部分执行时将JSP文件内容通过输出流写入到响应体</p>
</blockquote>
<h2 id="Servlet-与-JSP"><a href="#Servlet-与-JSP" class="headerlink" title="Servlet 与 JSP"></a>Servlet 与 JSP</h2><p>JSP文件被访问时，并不是JSP文件在执行，而是对应的Servlet在执行。自定义Serlvet接口实现类与JSP文件之间调用关系，等同于两个Servlet之间调用关系</p>
<ul>
<li><p>Servlet 与JSP 分工<br>Servlet：负责处理业务并得到【处理结果】<br>JSP：不负责业务处理，主要任务将Servlet中【处理结果】写入到响应体</p>
</li>
<li><p>Servlet 与  JSP 之间调用关系<br>Servlet工作完毕后，一般通过请求转发方式 向Tomcat申请调用JSP</p>
</li>
<li><p>Servlet  与 JSP 之间实现数据共享<br>Servlet将处理结果添加到【请求作用域对象】<br>JSP文件在运行时从【请求作用域对象】得到处理结果</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理业务，得到处理结果-----查询信息</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">10</span>,<span class="string">&quot;mike&quot;</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="number">20</span>,<span class="string">&quot;allen&quot;</span>);</span><br><span class="line">        List stuList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        stuList.add(s1);</span><br><span class="line">        stuList.add(s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将处理结果添加到请求作用域对象</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;key&quot;</span>, stuList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过请求转发方案，向Tomcat申请调用user_show.jsp</span></span><br><span class="line">        <span class="comment">//同时将request与response通过tomcat交给user_show.jsp使用</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/user_show.jsp&quot;</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">   <span class="comment">//从请求作用域对象得到OneServlet添加进去的集合</span></span><br><span class="line">     List&lt;Student&gt; stuList = (List)request.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!--将处理结果写入到响应体--&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;2&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;用户编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;用户姓名&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">       <span class="keyword">for</span>(Student stu:stuList)&#123;</span><br><span class="line">    %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=stu.getSid()%&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=stu.getSname()%&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">       &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>Tomcat服务器本身自带了EL工具包（Tomcat安装地址/lib/el-api.jar）<br>格式：${作用域对象别名.共享数据}<br>作用：EL表达式是EL工具包提供一种特殊命令格式【表达式命令格式】，在JSP文件上使用，负责在JSP文件上从作用域对象读取指定的共享数据并输出到响应体。</p>
<p><code>&lt;%@ page isELIgnored=&quot;true&quot; %&gt;</code> 表示是否禁用EL语言,TRUE表示禁止.FALSE表示不禁止</p>
<h3 id="JSP文件可以使用的作用域对象"><a href="#JSP文件可以使用的作用域对象" class="headerlink" title="JSP文件可以使用的作用域对象"></a>JSP文件可以使用的作用域对象</h3><ul>
<li>ServletContext application:  全局作用域对象</li>
<li>HttpSession session: 会话作用域对象</li>
<li>HttpServletRequest request: 请求作用域对象</li>
<li>PageContext  pageContext：当前页作用域对象，这是JSP文件独有的作用域对象。Servlet中不存在在当前页作用域对象存放的共享数据仅能在当前JSP文件中使用，不能共享给其他Servlet或则其他JSP文件真实开发过程，主要用于JSTL标签与JSP文件之间数据共享数据（JSTL———-&gt;pageContext——&gt;JSP）</li>
</ul>
<blockquote>
<p>EL表达式提供作用域对象别名<br>​          JSP                           EL表达式<br>​      application                 ${applicationScope.共享数据名}<br>​      session                       ${sessionScope.共享数据名}<br>​      request                       ${requestScope.共享数据名}<br>​      pageContext              ${pageScope.共享数据名}</p>
</blockquote>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">     Integer sid =(Integer)application.getAttribute(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">     String  home=  (String)request.getAttribute(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">	 Student stu= (Student)request.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">学员ID:&lt;%=sid%&gt;&lt;br/&gt;</span><br><span class="line">学员地址:&lt;%=home%&gt;&lt;br/&gt;</span><br><span class="line">学员编号:&lt;%=stu.getSid()%&gt;&lt;br/&gt;</span><br><span class="line">学员姓名:&lt;%=stu.getSname()%&gt;</span><br><span class="line">&lt;!---EL表达式--&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">学员ID:  $&#123;applicationScope.sid&#125;&lt;br/&gt;</span><br><span class="line">学员地址：$&#123;requestScope.home&#125;&lt;br/&gt;</span><br><span class="line">&lt;!---将引用对象属性写入到响应体--&gt;</span><br><span class="line">学员编号:$&#123;requestScope.key.sid&#125;&lt;br/&gt;</span><br><span class="line">学员姓名:$&#123;requestScope.key.sname&#125;</span><br></pre></td></tr></table></figure>
<p><strong>EL表达式没有提供遍历集合方法，因此无法从作用域对象读取集合内容输出</strong></p>
<h3 id="EL表达式简化版"><a href="#EL表达式简化版" class="headerlink" title="EL表达式简化版"></a>EL表达式简化版</h3><p>EL表达式允许开发时省略作用域对象别名。命令格式： ${共享数据名}<br>EL表达式简化版由于没有指定作用域对象，所以在执行时采用【猜】算法</p>
<blockquote>
<p>首先到【pageContext】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【pageContext】没有定位成功，到【request】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【request】没有定位成功，到【session】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【session】没有定位成功，到【application】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【application】没有定位成功，返回null<br> pageContext—-&gt;request—-&gt;session—-&gt;application</p>
</blockquote>
<p>存在隐患：容易降低程序执行速度；容易导致数据定位错误<br>应用场景：设计目的就是简化从pageContext读取共享数据并输出的难度<br>EL表达式简化版尽管存在很多隐患，但是在实际开发过程中为了节省时间一都使用简化版。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">标准版EL表达式输出session中key的值:$&#123;sessionScope.key&#125;&lt;br/&gt;</span><br><span class="line">简化版EL表达式输出session中key的值:$&#123;key&#125;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="支持运算表达式"><a href="#支持运算表达式" class="headerlink" title="支持运算表达式"></a>支持运算表达式</h3><p>在JSP文件有时需要将读取共享数据进行运算之后，将运算结果写入到响应体</p>
<blockquote>
<p>运算表达式包括：<br>1) 数学运算<br>2) 关系运算:  &gt;    &gt;=   ==    &lt;   &lt;=  !=<br>​                       gt   ge   eq    lt  le   !=<br>3)逻辑运算：  &amp;&amp;   ||    ！</p>
</blockquote>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--EL表达式支持运算表达式--&gt;</span><br><span class="line">&lt;!--将作用域对象中共享数据读取出来相加，将相加结果写入到响应体--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">     String num1 = (String)request.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">     Integer num2 = (Integer)request.getAttribute(<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> sum = Integer.valueOf(num1) + num2;</span><br><span class="line">%&gt;</span><br><span class="line">传统的Java命令计算后的结果:&lt;%=sum%&gt;</span><br><span class="line">EL表达式计算后的结果:$&#123;key1+key2&#125;</span><br><span class="line">EL表达式输出关系运算:$&#123;age ge <span class="number">12</span>?<span class="string">&quot;欢迎光临&quot;</span>:<span class="string">&quot;谢绝入内&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EL表达式提供内置对象"><a href="#EL表达式提供内置对象" class="headerlink" title="EL表达式提供内置对象"></a>EL表达式提供内置对象</h3><h4 id="param"><a href="#param" class="headerlink" title="param"></a>param</h4><p>命令格式: ${param.请求参数名}<br>命令作用： 通过请求对象读取当前请求包中请求参数内容，并将请求参数内容写入到响应体</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt; </span><br><span class="line">&lt;%</span><br><span class="line"> String userName = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line"> String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"> %&gt;</span><br><span class="line">来访者姓名:&lt;%=userName%&gt;</span><br><span class="line">来访者密码:&lt;%=password%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用EL表达式内置对象--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">   http:<span class="comment">//localhost:8080/myWeb/index_1.jsp?userName=mike&amp;password=123</span></span><br><span class="line">--&gt;</span><br><span class="line">来访者姓名:$&#123;param.userName&#125;&lt;br/&gt;</span><br><span class="line">来访者密码:$&#123;param.password&#125;</span><br></pre></td></tr></table></figure>
<h4 id="paramValues"><a href="#paramValues" class="headerlink" title="paramValues"></a>paramValues</h4><p>命令格式：${paramValues.请求参数名[下标]}<br>命令作用: 如果浏览器发送的请求参数是[一个请求参数关联多个值]，此时可以通过paramVaues读取请求参数下指定位置的值，并写入到响应体。此时pageNo请求参数在请求包以数组形式存在</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	String  array[]= request.getParameterValues(<span class="string">&quot;pageNo&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">第一个值:&lt;%=array[<span class="number">0</span>]%&gt;</span><br><span class="line">第二个值:&lt;%=array[<span class="number">1</span>]%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用EL表达式内置对象--&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt; </span><br><span class="line">&lt;!--</span><br><span class="line">http:<span class="comment">//localhost:8080/myWeb/index_2.jsp?deptNo=10&amp;deptNo=20&amp;deptNo=30</span></span><br><span class="line">--&gt;</span><br><span class="line">第一个部门编号:$&#123;paramValues.deptNo[<span class="number">0</span>]&#125;&lt;br/&gt;</span><br><span class="line">第二个部门编号:$&#123;paramValues.deptNo[<span class="number">1</span>]&#125;&lt;br/&gt;</span><br><span class="line">第三个部门编号:$&#123;paramValues.deptNo[<span class="number">2</span>]&#125;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<p> header/headerValues/cookie</p>
<h3 id="EL表达式常见异常"><a href="#EL表达式常见异常" class="headerlink" title="EL表达式常见异常"></a>EL表达式常见异常</h3><p><code>javax.el.PropertyNotFoundException</code>在对象中没有找到指定属性</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Coding / LMCS</title>
    <url>/2021/10/20/lmcs/</url>
    <content><![CDATA[<blockquote>
<p>LMCS( luma mapping with chroma scaling)是  VVC 中新增的技术，其位 于去方块滤波之前，也被称为环路重整形（in-loop reshaper），主要包括两个部分：亮度映射（LM）、依赖亮度的色度缩放（CS）。</p>
</blockquote>
<span id="more"></span>
<p><img src="/img/VVC/lmcs.png"/></p>
<p>前向LM：将luma值从原始样本域映射到映射的样本域</p>
<p>反向LM：将luma值从映射的样本域映射回原始样本域</p>
<p>色度缩放：确定一个色度缩放因子并根据该缩放因子缩放色度残差值</p>
<p>映射样本域（灰色阴影块）中的过程包括反量化、反变换、luma帧内预测以及重建。原始采样域的过程包括环内滤波器、DPB 中参考图像存取和帧间预测。</p>
<h2 id="LM"><a href="#LM" class="headerlink" title="LM"></a>LM</h2><p>LM 在像素级进行操作，其基本思想是在给定位深下调整亮度值的取值范围， 这是因为一般的视频信号不会取完取值空间的所有值。例如  ITU-R BT.2100-2[5] 中对  10bit 视频的亮度窄范围取值为  64 到  940，更好地利用信号范围来提高编码效率。</p>
<p><img src="/img/VVC/reshape.png" style="zoom:;" /></p>
<p><img src="/img/VVC/his.png" style="zoom:;" /></p>
<h3 id="解码端LM步骤"><a href="#解码端LM步骤" class="headerlink" title="解码端LM步骤"></a>解码端LM步骤</h3><p>1.对解码出的luma变换系数进行反量化反变换产生【映射域】的亮度残差$Y’_{res}$</p>
<p>2.在【映射域】重建luma样本，$Y’_{r} = Y’_{res} + Y’_{pred}$</p>
<blockquote>
<p>$Y’_{pred}$：帧内下，直接通过【映射域】的帧内预测得出；帧间下，首先使用解码缓冲区（DPB）的参考图像进行运动补偿后产生【原始样本域】的预测值$Y_{pred}$,然后进行前向LM产生映射域预测值$Y’_{pred}$。（帧间预测的运动补偿时在原始像素域进行，但是信号重建在映射域进行）</p>
</blockquote>
<p>3.$Y’_{r}$进行反向LM，然后环路滤波。</p>
<h3 id="FwdMap和InvMap"><a href="#FwdMap和InvMap" class="headerlink" title="FwdMap和InvMap"></a>FwdMap和InvMap</h3><p>亮度映射为可逆过程，且分段进行，通过一个前向映射函数<code>FwdMap</code>实现，其对应的逆向映射函数为<code>InvMap</code>。</p>
<p><code>FwdMap</code>是一个分段线性模型，参数需要在码流中传输，而<code>InvMap</code>不需要在码流中传输，解码器可以通过<code>FwdMap</code>生成<code>InvMap</code>函数。</p>
<p>分段线性模型使用两个输入点$InputPivot[]$和两个输出点$MappedPivot[]$来确定分段及该分段内的映射关系，用$SignalledCW[ i ]$表示第$i$段输出码字数量（编码端确定）。</p>
<ul>
<li><p>输入分段InputPivot[]的确定：</p>
<ul>
<li><p>输入分段固定划分为16个，每个分段码字数量用$OrgCW$表示。如对于10bit信号划分为16个分段，每个分段包含64个码字，$OrgCW = 64$。</p>
</li>
<li><p>$InputPivot[i]=i*OrgCW,i=0,1…16$，表示原始信号域每个分段的枢轴点。</p>
</li>
</ul>
</li>
<li><p>输出分段MappedPivot[]：在编码过程中计算出映射域枢轴点MappedPivot[i]。</p>
<ul>
<li><p>MappedPivot[ 0 ] = 0；</p>
</li>
<li><p>MappedPivot[i+1] = MappedPivot[i] + SignalledCW [i]</p>
</li>
</ul>
</li>
</ul>
<p>根据输入和输出分段即可确定当前段内的映射函数，即分段线性模型：</p>
<p>$Y_{pred}^{\prime}=\frac{\mathrm{MappedPivot}[\mathrm{i}+1]-\mathrm{MappedPivot}[\mathrm{i}]}{\mathrm{InputPivot}[\mathrm{i}+1]-\mathrm{InputPivot}[\mathrm{i}]}\ast (Y_{pred}-\mathrm{InputPivot}[\mathrm{i}])+\mathrm{MappedPivot}[\mathrm{i}]$</p>
<h3 id="实现：查找表（LUT，look-up-table）与即时计算"><a href="#实现：查找表（LUT，look-up-table）与即时计算" class="headerlink" title="实现：查找表（LUT，look-up-table）与即时计算"></a>实现：查找表（LUT，look-up-table）与即时计算</h3><h4 id="LUT"><a href="#LUT" class="headerlink" title="LUT"></a>LUT</h4><p>计算并预先存储<code>FwdMapLUT</code>和<code>InvMapLUT</code>以在Tile级别使用，并且向前和反向映射可以简单地应用查表操作，实现为：</p>
<p><img src="/img/VVC/LUT.png" style="zoom: 80%;" /></p>
<p>下图为查找表的例子：</p>
<p>CE12-2.1a: dQP模型产生的固定映射函数</p>
<p>CE12-2.1b: a piece-wise linear (PWL) model </p>
<p><img src="/img/VVC/celut.png" style="zoom: 80%;" /></p>
<h4 id="即时计算"><a href="#即时计算" class="headerlink" title="即时计算"></a>即时计算</h4><p>$Y_{pred}^{\prime}=\frac{\mathrm{MappedPivot}[\mathrm{i}+1]-\mathrm{MappedPivot}[\mathrm{i}]}{\mathrm{InputPivot}[\mathrm{i}+1]-\mathrm{InputPivot}[\mathrm{i}]}\ast (Y_{pred}-\mathrm{InputPivot}[\mathrm{i}])+\mathrm{MappedPivot}[\mathrm{i}]$</p>
<p>正向：像素值要右移 6 位得到所属区间 i。然后检索该段的线性模型参数并即时应用以计算映射的亮度值。</p>
<p>反向：在映射域每段大小不同，因此反变换时需要较为复杂的计算来得出某个值属于哪个区域，从而增加了解码复杂度。VVC采取了以下限制，假设映射域范围时0-1023，首先范围被分为32等份，如果$MappedPivot[ i ]$不是32的倍数，$MappedPivot[ i + 1 ]$和$MappedPivot[ i ]$不能属于同一个32等分段（也就是说$MappedPivot[ i + 1 ]$必须增加大于等于32的值）。这样可以使用右移5位来判断数值属于哪一段。<code>InvMap</code>函数也可以使用简单的右移5位来执行。</p>
<h2 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h2><p>CS 在色度块级进行操作，在 VVC 中，色度的 QP 依赖于对应亮度的 QP， 当使用 LM 之后映射域的亮度值和原始信号域的亮度值可能不同，所以对应色度 QP 可能不是最优的，LMCS 中通过依赖亮度值的色度缩放解决这个问题。</p>
<p>如果当前块使用了亮度映射，且dual tree parittion 关闭，则需要额外的标志标明是否使用色度残差尺度伸缩。如果当前快没有使用亮度映射，或者dual tree parittion打开（即亮度、色度单独划分预测），色度残差尺度伸缩默认关闭。另外区域小于等于4的色度块不适用CS。</p>
<h3 id="解码端CS步骤"><a href="#解码端CS步骤" class="headerlink" title="解码端CS步骤"></a>解码端CS步骤</h3><ol>
<li>对解码出的chroma残差进行反量化反变换产生【映射域】的色度残差$C_{resScale}$</li>
<li>$C_{res} = C_{resScale} * invScaleC$</li>
<li>$C_{r} = C_{res} + C_{pred}$</li>
</ol>
<p>各分段内部$invScaleC$值是相同的。为了减少流水线延迟，$invScaleC$取决于当前虚拟流水线数据单元VPDU左方上方的重建亮度平均值$avgY’$<br>1、利用亮度映射的$InvMap$函数，找出$avg Y′$ 所对应分段线性模型的段序号$Y_{idx}$<br>2、$invScaleC = cScaleInv[ Y_{idx} ]$,  $cScaleInv[] $为事先定义好的表$LUT$</p>
<p><img src="/img/VVC/cs.png"  /></p>
<p>如果当前CU时inter 128x128, inter 128x64或inter 64x128，第一个VPDU的CS缩放因子被用于所有色度变换块。对于整个色度块，$invScaleC$是一个固定值。</p>
<p>deltaCRS：cfg中指定，APS中传输</p>
<p><code>LMCSOffset                   : 2      # chroma residual scaling offset</code></p>
<h2 id="syntax"><a href="#syntax" class="headerlink" title="syntax"></a>syntax</h2><p>LMCS可以在序列级、图片级或slice级进行控制。相关参数在APS中编码， aps_parameter_type = 1（LMCS_APS）。每个视频序列可以使用4个LMCS APS，每帧只能使用一个LMCS APS。LMCS APS数据包含两部分：1）与最多16段的线性模型有关的语法；2）CS偏移值deltaCRS，如果视频信号不是单色的。</p>
<p><code>lmcs_min_bin_idx</code>：指定  LMCS 中分段模型的最小分段的索引号，其值在 [0,15]之间。</p>
<p><code>lmcs_delta_max_bin_idx</code>：该值等于 15-LmcsMaxBinIdx，其中  LmcsMaxBinIdx 是 LMCS 中分段模型的最大分段的索引号。</p>
<p><code>aps_chroma_Present_Flag</code>：表示是否使用deltaCRS</p>
<p><code>lmcs_delta_cw_prec_minus1</code>：该值加  1 代表表示  lmcs_delta_abs_cw[ i ]所用 的比特数，其值在[0,14]之间。</p>
<p><code>lmcs_delta_abs_cw[ i ]</code>：表示第 i 个分段的码字数量增量的绝对值。</p>
<p><code>lmcs_delta_sign_cw_flag[ i ]</code>  ： 表 示   lmcsDeltaCW[ i ]  的 符 号 ， 如 果 lmcs_delta_sign_cw_flag[ i ]等于 0 则  lmcsDeltaCW[ i ]为正，否则为负。</p>
<p><code>lmcs_delta_abs_crs</code>：表示  lmcsDeltaCrs 的绝对值。</p>
<p><code>lmcs_delta_sign_crs_flag</code>：表示  lmcsDeltaCrs 的符号。</p>
<p><img src="/img/VVC/lmcsaps.png"  /></p>
<h2 id="编码端参数估计"><a href="#编码端参数估计" class="headerlink" title="编码端参数估计"></a>编码端参数估计</h2><p>两种算法，分别对应SDR/HDR HLG视频和HDR PQ视频。</p>
<h3 id="对SDR-HDR-HLG视频"><a href="#对SDR-HDR-HLG视频" class="headerlink" title="对SDR/HDR HLG视频"></a>对SDR/HDR HLG视频</h3><p>针对PSNR进行优化，将更多的luma码字分配给空间平滑区域而不是非平滑区域</p>
<p><img src="/img/VVC/sdr.png"  /></p>
<p><strong>1. 初始化时为每个有效分段分配相同数量的码字。</strong></p>
<ul>
<li>对于不是10bit的信号归一化到10bit。</li>
</ul>
<ul>
<li><p>将码字范围[0,1023]均匀划分为16个分段。</p>
</li>
<li><p>确定有效分段数量，有效指的是该分段中大部分亮度值在图像中出现了。例如，对于10bit窄范围信号，[0,63]和[941,1023]无法取到，则第0和15个分段是无效的，一共有14个有效分段。</p>
</li>
</ul>
<ul>
<li><p>对每个有效分段按下面方式分配相同数量的码字。<br>$binCW[i]=round\left(\frac{totalCW}{endIdx-startIdx+1}\right)$</p>
<p>$binCW[i]$是分配给第i段的码字数量，$totalCW$是允许的码字总数，$startIdx$和$endIdx$分别是第一个和最后一个有效片的索引值。</p>
</li>
</ul>
<p><strong>2. 基于图像统计结果调整码字数量。</strong></p>
<ul>
<li>对于图像中的每个亮度像素，计算以其为中心$winSize$ x $winSize$邻域内的空域方差$pxlVar$。其中$winSize=Floor(min(width,height)/240)-2+1$。$width,height$是图像宽高。</li>
</ul>
<ul>
<li><p>对于16个分段，计算每个的$pxlVar$平均值，$binCnt[i]$是第i个分段样本数。<br>$binVar[i]=\frac{\sum_{bin}\log_{10}(pxlVar+1.0)}{binCnt[i]}$</p>
</li>
<li><p>计算所有分段$binVar$的均值$meanVar$，和每个分段对应的归一化值$normVar[i]=binVar[i]/ meanVar$。</p>
</li>
<li>调整码字，将更多码字分配给$normVar$小的分段</li>
</ul>
<p>$\quad \mathrm{if}\ normVar[i]&lt; 1.0, \ binCW [i]=\begin{cases} binCW\ [i]+delta1[i],\quad 0.8\leq normVar[i] &lt; 0.9\\ binCW\ [i]+delta2[i],\qquad normVar\ &lt; 0.8 \end{cases}$</p>
<p>$else\ if\ normVar [i] &gt; 1.0, binCW[i]=\begin{cases} binCW[i]-delta1 [i],\quad 1.1 &lt; normVar[i]\leq 1.2\\ binCW [i]-delta2[i],\qquad normVar[i]\ &gt; 1.2 \end{cases} $</p>
<p>$ delta1[i]= round*(10∗hisr[i]) $and $delta2 [i]=round(20∗hisr[i])$</p>
<p>$hist[i]$是第$i$个分段样本数相对于所有像素数的百分比，clip到[0,0.4]，避免过度的码字分配。</p>
<p><strong>3、调整码字数量到最大码字数量。</strong></p>
<p>如果分配的码字数量超过允许的最大数量，从第一分段开始，逐渐减少分配给每个分段的码字数，直到分配的码字总数等于允许的码字总数。</p>
<p><strong>4、设置rate、slice和色度自适应参数。</strong></p>
<ul>
<li>当编码使用的QP较小（&lt;=22）时允许使用rate adaptation以保留更多图像细节。当开启rate adaptation应且有效分段数量小于16时，分配给每个分段的码字数量为66。</li>
</ul>
<ul>
<li>slice自适应使得上面步骤2、3只能在IRAP图像上进行。可以根据以下选项对slice进行LMCS激活：1）对所有帧内和子序列帧间slices；2）仅对TemporalID=0的子序列的图像的slices；3）仅对子序列帧间slices。对某些视频，其映射域图像的平均方差会大于原始像素域平均方差，且差值超过预定义阈值，此时对帧内slices禁用LMCS压缩效果会更好，或者仅对TemporalID=0的图像的slices使用LMCS。</li>
</ul>
<ul>
<li>色度自适应可以根据图像亮度和色度分量的相对平均空域方差决定是否使用色度残差的缩放。如果色度分量和亮度分量的平均空域方差比值超过预定义阈值则不进行色度残差的缩放。</li>
</ul>
<h3 id="对HDR-PQ视频"><a href="#对HDR-PQ视频" class="headerlink" title="对HDR PQ视频"></a>对HDR PQ视频</h3><p>优化加权PSNR（wPSNR），luma映射曲线是直接基于wPSNR中使用的权重得出</p>
<p>本示例针对HDR PQ内容提供了一个固定的映射函数，该函数通过luma dQP（ luma-dependent quantization adaptation method）建模。luma dQP基于平均亮度值为每个CTU生成局部delta QP（dQP）。</p>
<p>$\mathrm{dQP}(avgY)=max(-3,min(6,0.015\ast avgY-1.5-6))$</p>
<p>HDR PQ视频使用wPSNR作为客观评价指标，wPSNR通过wSSE(ܻY)计算得到，</p>
<p>$\mathrm{wSSE}(\mathrm{Y})=2^{\wedge}(dQP(Y)/3)$</p>
<p>HDR PQ的LMCS映射函数通过下面步骤得到：</p>
<p><strong>1、计算映射曲线的斜率</strong></p>
<p>$slope[Y]=\mathrm{sqrt}(\mathrm{wSSE}(Y))=2^{\wedge}(dQP(Y)/6)$</p>
<p>如果信号是窄范围，对于10bit视频的Y值取值为[0,63]和[940,1023]时斜率设为0。</p>
<p><strong>2、对映射函数斜率积分</strong>。Y=0,1…maxY-1,</p>
<p>$F[Y+1]=F[Y]+slope[Y]$</p>
<p><strong>3、通过将F[Y]归一化到[0,maxY]得到look-up table,FwdLUT[Y]</strong></p>
<p>$FwdLUT[Y]=\mathrm{clip}3 (0, \mathrm{maxY}, \mathrm{round}(F[Y]\ast maxY/F[maxY]))$</p>
<p><strong>4、计算每个分段码字数量</strong></p>
<p>$binCW[15]=FwdLUT[1023]-FwdLUT[960]$</p>
<p>$for\ i = 14;i &gt;=0; i—$</p>
<p>$binCW[i]=FwdLUT[(i+1)\ast OrgCW]-FwdLUT[i\ast OrgCW]$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="/img/VVC/codereshape.png"  /></p>
]]></content>
      <tags>
        <tag>VVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Coding / SAO</title>
    <url>/2021/10/20/sao/</url>
    <content><![CDATA[<blockquote>
<p>VVC环路滤波：自适应样点补偿滤波器</p>
</blockquote>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于量化是在频域进行，而高频系数的量化失真往往更大，图像边缘一般都是高频部分，所有边缘部分的失真会更大，解码后边缘部分会出现上下波动，这就是振铃效应。重建值在原始值上下波动。</p>
<p><img src="/img/VVC/zhenling.png"  /></p>
<p>将重建值进行分类，对波峰补偿一个负值，对波谷补偿一个正值。所以 SAO 的关键部分在于对重建像素进行分类。</p>
<p>VVC 中的 SAO与HEVC中基本一致，以CTB为单位对样本分group，分别对不同的group进行补偿。group index和offset被写入码流。包括两种补偿方式，边界补偿（Edge Offset,EO）和边带补偿（Band Offset,BO）。其中EO是根据样点值与周围样点值的关系来分类，而BO是根据样点本身的值来分类。</p>
<ul>
<li>和 HEVC 中的 SAO 基本一致</li>
<li>BD-rate 增益只有 0.1%<ul>
<li>如果没有 ALF 的话增益会高很多，能达到 0.8% 或 1%</li>
<li>在主观质量上提升挺多</li>
<li>复杂度低，可以适用于低延迟场景</li>
</ul>
</li>
<li>主要减小了振铃效应</li>
<li>可以使用 EO（边界补偿）和 BO（边带补偿）<ul>
<li>对每个 CTB，当使用EO时：<ul>
<li>一个 CTB 只能使用一种 EO 类型</li>
<li>4 种类的偏置会传输</li>
</ul>
</li>
<li>对边带补偿，整个样值范围被分成不同的边带<ul>
<li>样值被分类为某种边带</li>
<li>对每种边带，传输偏置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="补偿模式"><a href="#补偿模式" class="headerlink" title="补偿模式"></a>补偿模式</h2><p>RDO选出用EO,BO或merge。</p>
<h3 id="EO"><a href="#EO" class="headerlink" title="EO"></a>EO</h3><ul>
<li>通过RDO为该CTB选择使用一种梯度模式</li>
</ul>
<p><img src="/img/VVC/eo-g.png"  /></p>
<ul>
<li>确定梯度模式后，计算该CTB中的当前像素c和相邻2个像素ab之间的关系，分为4类，每类分配一个offset，offset由RDO过程产生。规定1,2时，offset值必须是正数；对于3,4时，offset必须是负数。对于不属于以上四个类别的像素值不进行补偿。</li>
</ul>
<p><img src="/img/VVC/eo-classify.png" style="zoom: 67%;" /></p>
<h3 id="BO"><a href="#BO" class="headerlink" title="BO"></a>BO</h3><p>根据样点值分为32个等间距的band（每一个band的范围是8），每个样点都会属于一个特定的区间。选择4个连续的band里的像素值进行补偿。需要补偿的边带起点和补偿值通过RDO选择。</p>
<p><img src="/img/VVC/BO.png"  /></p>
<p>为什么4个连续的band？</p>
<ul>
<li>一个CTU中大部分的pixel的取值应该会集中在很少的几个band中，使用连续的4个band能够覆盖大部分的pixel。</li>
<li>因为EO模式使用了4个offset值，为了不增加码率，BO复用了这4个offset值的syntax，这样不需要另外再增加syntax来专门表示。</li>
</ul>
<h3 id="参数融合（merge）"><a href="#参数融合（merge）" class="headerlink" title="参数融合（merge）"></a>参数融合（merge）</h3><p>某一个CTB的SAO的参数可以直接使用相邻CTB的参数（色度亮度同时），只需指定是哪个相邻块（左方或上方）</p>
<h2 id="syntax"><a href="#syntax" class="headerlink" title="syntax"></a>syntax</h2><p><img src="/img/VVC/sao-syntax.png"  /></p>
<p><img src="/img/VVC/VQSAO.png"  /></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>下表显示了在有/无ALF和CC-ALF的VTM-9.0中启用SAO对SDR内容的BD-rate改进。anchor为SAO禁用。</p>
<ul>
<li><p>当ALF和CC-ALF被启用时，在四个测试条件下，启用SAO的平均YUV BD-速率增益为0.2%。</p>
</li>
<li><p>当ALF和CC-ALF被禁用时，SAO不仅平均实现了1.3%的YUV BD-速率增益，而且还提供了主观的好处，如图所示。</p>
</li>
</ul>
<p>启用SAO的BD-rate改进与ALF部分重合。然而，考虑到SAO在HEVC中得到了很好的部署，而且所需的计算复杂度很低，SAO被保留在VVC中，以允许使用SAO来进一步提高客观和主观质量，特别是当ALF被禁用时。</p>
<p><img src="/img/VVC/sao.png" style="zoom: 50%;" /></p>
<p><img src="/img/VVC/sao2.png" style="zoom:;" /></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="/img/VVC/codesao.png"  /></p>
]]></content>
      <tags>
        <tag>VVC</tag>
      </tags>
  </entry>
  <entry>
    <title>图与网络 / 双计数</title>
    <url>/2021/07/06/%E5%8F%8C%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>双计数狭义上讲，对于一个集合运用两种不同的方式（行 / 列），得到等式结果或者不等式的结果。</p>
</blockquote>
<span id="more"></span>
<h2 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a>握手定理</h2><blockquote>
<p>对于图$G=(V, E)$，有</p>
<script type="math/tex; mode=display">
\sum_{v\in V}d(v) = 2|E|</script></blockquote>
<p>证明：对图G的邻接矩阵中1的个数分别从行（左），列（右）进行计数。即对二元组$\{(v,e)|v\in e\}$进行计数。</p>
<blockquote>
<p>推论：图中奇度点数目为偶数。<br>超图握手定理：对于超图$G=(V, B)$</p>
</blockquote>
<script type="math/tex; mode=display">
\sum_{v\in V}d(v) = \sum_{\beta\in B}|\beta|</script><h2 id="完全图边的双计数"><a href="#完全图边的双计数" class="headerlink" title="完全图边的双计数"></a>完全图边的双计数</h2><script type="math/tex; mode=display">
\sum_{i=1}^S{n_i} = n</script><script type="math/tex; mode=display">
{n\choose 2} = \sum_{i = 1}^S {n_i \choose 2}+\sum_{i<j}n_in_j</script><p>对于一个完全图，共有$n\choose 2$条边；<br>将完全图划分为$S$部分，每部分有$n_i$个点，${n_i \choose 2}$条边；<br>每部分之间有$n_in_j$条边。</p>
<h2 id="等式证明"><a href="#等式证明" class="headerlink" title="等式证明"></a>等式证明</h2><script type="math/tex; mode=display">
{n\choose k } = \frac{n}{k}{n-1 \choose k-1}</script><p>证明：设$A$为$k$元子集，对二元组$\{(x,A)|x\in A, |A| = k\}$进行计数。</p>
<script type="math/tex; mode=display">
\sum_{k = 1}^n k{n\choose k} = n \sum_{k = 1}^n { {n-1}\choose {k-1} } = n2^{n-1}</script><p>证明：设$A$为$k$元子集，$k=1,2,…,n$，对二元组$\{(x,A)|x\in A, |A| = k\}$进行计数。</p>
<script type="math/tex; mode=display">
{n \choose k}{k \choose l} = {n \choose l} { {n-1}\choose {k-l} }</script><p>证明：设$A$为$l$元子集，$B$为$k$元子集，对二元组$\{(A,B)||A|=l,|B|=k,A\subseteq B\}$进行计数。</p>
<h2 id="Turan-Number"><a href="#Turan-Number" class="headerlink" title="Turan Number"></a>Turan Number</h2><script type="math/tex; mode=display">
T(n,k,l)\geq \frac{n\choose l}{k \choose l}</script><blockquote>
<p>图兰数$T(n,k,l) (l\leq k \leq n)$是$n$元集合$X$的$l$元子集的最小值(下界)，使得$X$的每个$k$元子集至少包含一个这样的l元子集。</p>
</blockquote>
<p>证明：设$F$为满足条件的l元子集，记$F=\{A_1，A_2，…\}$，此时可用关联矩阵表示，$A_i$为满足条件的$l$元集合，$B_i$为$ k$元子集，若$A_i$在$B_i$上，则为$1$，就可以得到一个$0-1$矩阵。对矩阵中$1$的个数计数。</p>
<p>行计数：对于某一个$l$元集合，有$\binom{n-l}{k-l}]$个$k$元集合包含它，共有$|F|$个，行计数$1$的个数为$|F|\binom{n-l}{k-l}$</p>
<p>列计数：每个$B_i$必包含一个$A_i$，则每一列至少有一个$1$，可以得到$|F|\binom{n-l}{k-l} \geq {n\choose k}$</p>
<h2 id="Zarankiewicz’s-problem"><a href="#Zarankiewicz’s-problem" class="headerlink" title="Zarankiewicz’s problem"></a>Zarankiewicz’s problem</h2><blockquote>
<p>对于一个$n\times n$的$0-1$矩阵，如果不存在$a\times a$的全$1$子矩阵，那么这个$nxn$的矩阵最多有多少个1？<br>等价于：用二部图重新表述这个问题。一个部分大小为$n$的二部图$G=(V_1,V_2,E)$，其中$V_1,V_2$是顶点的不相交$n$元集合，$E\in V_1\times V_2$是边的集合。令$K_a(n)$为最小整数$k$边，使得任意大小为$n$且边数大于k的二部图至少包含一个$a\times a-clique$。对于任意的自然数$n$和$a$，</p>
</blockquote>
<script type="math/tex; mode=display">
K_a(n) \leq (a-1)^{\frac{1}{a} }n^{2-\frac{1}{a} }+(a-1)n</script><p>对$S= \{(x,A)|x\in V_1,A \in V_2,|A|=a,且x与A中所有点都有边相连\}$计数, 即对下图中的结构进行计数。</p>
<div align="center">
    <img src="/img/0607-1.png" style="zoom:33%;">
</div>

<p>固定$x$：从与$x$相连的元素中取$A$，设$x$的neighbor为$d(x)$，那么A有$\sum_{x\in V_1}\binom{d(x)}{a}$种选法，且$|S|=\sum_{x\in V_1}\binom{d(x)}{a}$<br>固定$A$：从$n$中选出$a$元集合，与之对应相连的$x$最多有$(a-1)$个，否则就会出现$a\times a-clique$，即$|S| \leq \binom{n}{a}(a-1)$<br>即$\sum_{x\in V_1}\binom{d(x)}{a}\leq \binom{n}{a}(a-1)$</p>
<blockquote>
<p>Jensen不等式，对凸函数有：</p>
<script type="math/tex; mode=display">
s.t.\sum_{i=1}^n\lambda_i = 1</script><script type="math/tex; mode=display">
\sum_{i=1}^n\lambda_if(x_i)\geq f(\sum_{i=1}^n\lambda_ix_i),</script><p>Jensen不等式可由数学归纳法证明，略。</p>
</blockquote>
<p>令$f(x)=\binom{x}{a}$,$x_i=d(x_i)$;<br>根据Jensen不等式，有<br>$\frac{1}{n}\sum_{x\in V_1}\binom{d(x)}{a}\geq \binom{\frac{1}{n}\sum_{x\in V_1}d(x)}{a}$</p>
<p>$\sum_{x\in V_1}\binom{d(x)}{a}\geq n\binom{\frac{1}{n}\sum_{x\in V_1}d(x)}{a}=n\binom{\frac{|E|}{n} }{a}$(因为为二部图，则degree为一倍边数)</p>
<p>即$n\binom{\frac{|E|}{n} }{a}\leq \binom{n}{a}(a-1)$<br>经过放缩有$n(\frac{|E|}{n}-(a-1))^a&lt;\frac{n(|E|/n)(|E|/n-1)…(|E|/n-(a-1))}{a!}=n\binom{\frac{|E|}{n} }{a}$</p>
<p>$\binom{n}{a}(a-1)=\frac{n(n-1)…(n-(a-1))}{a!}(a-1)&lt;\frac{n^a}{a!}(a-1)$，两边同时开a次方即可解。</p>
<ul>
<li>$K_a(n)$的下界可以用概率方法求得</li>
</ul>
<h2 id="H-free图"><a href="#H-free图" class="headerlink" title="H-free图"></a>H-free图</h2><blockquote>
<p>一个有$n$个顶点的无$H$图可以最多有多少条边?<br>定理：如果图$G=(V，E)$中不包含4个点的圈, 即$C_4-free$，那么有$|E|\leq \left \lfloor n/4(1+\sqrt{4n-3}) \right \rfloor$</p>
</blockquote>
<p>令点集$V={1，2，…，n}$，用于双计数的集合为$S=\{(u,\{v,w\})|u与v,w都邻接，且v≠w\}$，即对下图中的结构进行计数。</p>
<div align="center">
    <img src="/img/0607-1.png" style="zoom:33%;">
</div>

<p>固定$u$,那么$v$和$w$只能在度为$d(u)$的点中选取，即$\binom{d(u)}{2}$，有$\sum _{u\in V}\binom{d(u)}{2}=|S|$；</p>
<p>固定$v$和$w$，最多只有一个点可以和它们都关联，那么有$\binom{n}{2}\geq |S|$，</p>
<p>那么，$\sum _{u\in V}d^2(u)\leq \sum _{u\in V}d(u)+n(n-1)$,</p>
<blockquote>
<p>柯西—施瓦茨不等式，$|(\alpha ,\beta )|\leq ||\alpha ||*||\beta ||$<br>上述不等式中对应的分别是$[d(u_1),d(u_2)….d(u_n)]$，$(1,1,…1)$。</p>
</blockquote>
<p>由柯西—施瓦茨不等式得，$n\sum_{u\in V}d^2(n)\geq (\sum_{u\in V}d(n)*1)^2$，代入上式，$\frac{(\sum_{u\in V} d(u))^2}{n}\leq \sum_{u\in V}d(u)+n)n-1$，</p>
<p>由握手定理得$4|E|^2\leq n2|E|+n^2(n-1)$，求解n可得上述结论。</p>
<h2 id="三计数"><a href="#三计数" class="headerlink" title="三计数"></a>三计数</h2><blockquote>
<p>在超图中，有</p>
<script type="math/tex; mode=display">
\sum_{x\in X}d^2(x)=\sum_{A\in F} \sum_{x\in A}d(x)=\sum_{A\in F} \sum_{B\in F}|A\cap B|</script></blockquote>
<p>对于集合$(X,F)$，$X$为点集合，$F$为超边集合，对三元组${(x,A,B)|A,B∈F,x∈A，x∈B}$计数。<br>左：$x$在全集$X$上，$A，B$集合均包含点$x$；<br>中：先选出在$A$的$x$，再使得$x$在$B$中；<br>右：先选出$A$和$B$集合，使得$x$在$A$和$B$上，即在$A\cap B$上。</p>
<h2 id="整除关系"><a href="#整除关系" class="headerlink" title="整除关系"></a>整除关系</h2><blockquote>
<p>假设两个有限集$R$和$C$和一个子集$S\subseteq R\times C$。无论何时$(p，g)∈s $那么认为$p$和$q$是关联的。<br>设$r_p$表示$p$固定，与$p$关联的元素数目；$c_p$表示$q$固定，与$q$关联的元素数目。有</p>
<script type="math/tex; mode=display">
\sum_{p\in R}r_p=|S|=\sum_{q\in C}c_q</script></blockquote>
<p>假设$M_{|p|\times |q|}$的关联矩阵使用双计数进行证明，矩阵中若$p_i$和$q_j$相关联，$a_{ij}$则置为$1$，否则为$0$，那么$|S|$就是矩阵$M$中全部$1$的个数，等式的第一项可从行计数，最后一项可从列计数角度统计矩阵中1的个数。</p>
<p>例：<br>$R=C={1，2，…，n}$，集合$S=\{(i,j)|i可以整除j\}$，<br>$t(j)$表示$j$的因子的数目，如$j=4$，因子有$1,2,4$，那么$t(4)=3$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i/j</th>
<th style="text-align:center">1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
\overline{t(j)}=\frac{1}{n}\sum_{j=1}^{n}t(j)=\frac{1}{n}\sum_{i=1}^{n}\left \lfloor n/i \right \rfloor</script><script type="math/tex; mode=display">
\frac{1}{n}\sum_{i=1}^{n}(\frac{n}{j}-1)<\frac{1}{n}\sum_{i=1}^{n}\left \lfloor n/i \right \rfloor\leq \frac{1}{n}\sum_{i=1}^{n}\frac{n}{i}=\sum_{i=1}^{n}\frac{1}{i}</script><script type="math/tex; mode=display">
\sum_{i=1}^{n}\frac{1}{i}-1 < t(j) \leq lnn</script><script type="math/tex; mode=display">
|\overline{t(j)}-lnn|<1</script><h2 id="Sperner-Lemma"><a href="#Sperner-Lemma" class="headerlink" title="Sperner Lemma"></a>Sperner Lemma</h2><blockquote>
<p>假设某个顶点为$V1、V2、V3$的“大”三角形被三角化了(也就是说，被分解成有限数量的“小”三角形，这些“小”三角形每条边都能拼接在一起)。<br>假设三角化中的顶点从集合$\{1,2,3\}$中获取颜色，使得$V_i$接收颜色$i$(对于每个$i$)，并且沿着$V_i$到$V_i$的边的顶点只用$i$和$j$的颜色，而内部顶点用1、2或3的颜色任意着色。那么在三角测量中一定有一个小的“三色”三角形。</p>
</blockquote>
<div align="center">
    <img src="/img/0607-3.png">
</div>


<p><strong>证明：</strong></p>
<p>假定大三角形外部有一点$A$，每一个小三角形中心都有一个顶点$O$，若小三角形含有1，2顶点，则从$O$经过1，2点构成的边形成一条边(即出度)，如下图</p>
<div align="center">
    <img src="/img/0607-4.png">
</div>

<p>根据握手定理可知，度之和必为偶数， 在$V_1$和$V_2$构成的边上，观察可得出度必为奇数，即边上(1,2).(2,1)的线段必有奇数个，那么在小三角形必存在奇数度的三角形，即必存在1度的三角形，得证。</p>
<p>参考：<a href="https://www.it610.com/article/1295411404924329984.htm">【图论学习笔记二】双计数(Double Counting) - it610.com</a></p>
]]></content>
      <tags>
        <tag>图与网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java / 代理模式</title>
    <url>/2021/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>代理模式的一个典型应用：AOP(面向切面编程)</p>
</blockquote>
<span id="more"></span>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>a类本来需要调用c类（目标类）的方法完成某个功能， 但是c不让a调用。 </p>
<p>a —&gt;不能直接调用 c的方法。<br>在a 和 c 直接创建一个 b 代理，c让b访问。 c，b实现相同的功能（接口）。<br>a —&gt;访问b—&gt;访问c</p>
<p>作用：</p>
<ul>
<li>功能增强： 在原有的功能上，增加了额外的功能。 新增加的功能，叫做功能增强</li>
<li>控制访问： 代理类不让你访问目标，例如商家不让用户访问厂家。 </li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>代理类需要手工实现。即自己创建一个java类，表示代理类。所要代理的目标类是确定的。</p>
<ul>
<li>缺点：当目标类和代理类很多时候，<ul>
<li>当目标类增加， 代理类可能也需要成倍的增加。 代理类数量过多。</li>
<li>当接口中功能增加或修改，会影响众多的实现类，厂家类，代理类都需要修改。影响较大。</li>
</ul>
</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在程序执行过程中，使用jdk的<strong>反射</strong>机制，创建<strong>代理类对象</strong>， 并动态的指定要代理目标类。<br>即使目标类很多，代理类数量可以很少；当修改了接口中的方法时，不影响代理类。<br>动态代理是一种创建java对象的能力，不用创建代理类，就能创建代理类对象。<br>两种实现方式：jdk动态代理；cglib动态代理</p>
<h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><ul>
<li>使用java反射包中的类和接口实现动态代理的功能。</li>
<li>反射包 java.lang.reflect , 里面有三个类 ： InvocationHandler , Method, Proxy.</li>
<li>要求目标类实现接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用反射调用方法</span></span><br><span class="line">HelloService service = <span class="keyword">new</span> HelloServiceImpl(); <span class="comment">//创建类对象service</span></span><br><span class="line">service.sayHello(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 通过对象调用sayHello()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反射调用方法</span></span><br><span class="line">Method method =  HelloService.class.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class); <span class="comment">// 获取method对象（sayHello()方法）</span></span><br><span class="line">HelloService service2 = <span class="keyword">new</span> HelloServiceImpl2();</span><br><span class="line">Object ret = method.invoke(service2, <span class="string">&quot;李四&quot;</span>); <span class="comment">// invoke()方法调用对象service2的方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>InvocationHandler接口，只有一个方法invoke()，代理对象要完成的功能。（目标方法/功能增强）</li>
<li>Method类：表示目标类中的方法。通过Method可以执行某个目标类的方法，method.invoke(目标对象，方法的参数)</li>
<li>Proxy类：创建代理对象。之前创建对象是 new ，现在使用Proxy类的静态方法 newProxyInstance() 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现InvocationHandler接口，完成代理类要做的功能（1.调用目标方法，2.功能增强）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySellHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>; <span class="comment">// 为目标类创建对象（活动的，不是固定的，需要传入进来）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySellHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 实现invoke方法，完成代理类要做的功能</span></span><br><span class="line">    <span class="comment">// Object proxy: jdk创建的代理对象，无需赋值。</span></span><br><span class="line">	<span class="comment">// Method method: 目标类中的方法，jdk提供</span></span><br><span class="line">    <span class="comment">// Object[] args：目标类中方法的参数， jdk提供。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object res  = <span class="keyword">null</span>;</span><br><span class="line">        res =  method.invoke(target,args); <span class="comment">// 反射，执行目标对象target的method方法</span></span><br><span class="line">		<span class="comment">//功能增强，加价</span></span><br><span class="line">        <span class="keyword">if</span>( res != <span class="keyword">null</span> )&#123;</span><br><span class="line">            Float price = (Float)res;</span><br><span class="line">            price = price + <span class="number">25</span>;</span><br><span class="line">            res = price;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建代理对象，使用Proxy</span></span><br><span class="line"><span class="comment">//1. 创建目标对象</span></span><br><span class="line">UsbSell factory = <span class="keyword">new</span> UsbKingFactory();</span><br><span class="line"><span class="comment">//2.创建InvocationHandler对象</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MySellHandler(factory);</span><br><span class="line"><span class="comment">//3.创建代理对象</span></span><br><span class="line">UsbSell proxy = (UsbSell) Proxy.newProxyInstance(</span><br><span class="line">    factory.getClass().getClassLoader(),</span><br><span class="line">    factory.getClass().getInterfaces(),</span><br><span class="line">    handler</span><br><span class="line">	);</span><br><span class="line"><span class="comment">//4.通过代理执行方法</span></span><br><span class="line"><span class="keyword">float</span> price = proxy.sell(<span class="number">1</span>); <span class="comment">// 代理对象proxy调用目标类factory中的sell方法</span></span><br></pre></td></tr></table></figure>
<h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><ul>
<li>cglib是第三方的工具库， 创建代理对象。</li>
<li>原理是继承， cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法， 实现功能的修改。要求目标类不能是final的， 方法也不能是final的。</li>
<li>cglib的要求目标类比较宽松， 只要能继承即可。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 / 多路查找树</title>
    <url>/2021/10/20/%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>大量数据存储中，在查找的背景下，BST由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。那么如何减少树的深度?</p>
</blockquote>
<span id="more"></span>
<h2 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h2><p>二叉排序树在多数情况能够达到预期的查找效率，但是<strong>每个节点只能存储一个元素</strong>和<strong>只能有两个孩子</strong>，大量数据情况下会造成树的深度特别大，查找时多次的访问会造成查找效率的下降。所以引入新的数据结构——多路查找树。</p>
<ul>
<li>多路查找树的每一个节点的孩子树可以多于两个，且每个节点处可以存储多个元素。</li>
<li>多路查找树是一种特殊的查找树，所以其元素之间存在某种特定的排序关系。</li>
<li>四种特殊形式：2-3树，2-3-4树，B树（B-树），B+树</li>
</ul>
<h2 id="B树（B-树）"><a href="#B树（B-树）" class="headerlink" title="B树（B-树）"></a>B树（B-树）</h2><p>B树（B-树）是一种平衡的多路查找树。2-3树和2-3-4树都是B树的特例。节点的最大孩子数目称为B树的阶（order），因此，2-3树是3阶B树，2-3-4树是4阶B树。</p>
<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>定义2-3树中每一个节点都具有两个孩子(称<strong>2节点</strong>)或三个孩子(称<strong>3节点</strong>)。</p>
<ul>
<li>一个2节点包含一个元素（关键字）和两个孩子(只能包含两个孩子或没有孩子)，且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。</li>
<li>一个3节点包含一小一大两个元素和三个孩子(只能包含三个孩子或没有孩子)。如果某个3节点有孩子，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</li>
<li><p>2-3树的所有叶子都在同一层次。</p>
<p><img src="/img/multitree/2-3.png"/></p>
</li>
</ul>
<p>插入/删除：略</p>
<h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3-4树是2-3树的扩展，包括了4节点的使用，一个4节点包含小中大三个元素和四个孩子（或没有孩子）。<br>插入/删除：略</p>
<h3 id="应用：内外存的数据交互"><a href="#应用：内外存的数据交互" class="headerlink" title="应用：内外存的数据交互"></a>应用：内外存的数据交互</h3><p>计算机存储设备一般分为两种：内存储器和外存储器。 操作系统经常与内存和硬盘这两种存储设备进行通信，与内存操作，是虚拟一个页的概念来作为最小单位。</p>
<p>内存储器为内存，内存存取速度快，但容量小，价格昂贵，而且不能长期保存数据(在不通电情况下数据会消失)。</p>
<p>外存储器即为磁盘读取，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。</p>
<blockquote>
<p>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右。执行一次IO的时间可以执行40万条指令，所以磁盘IO是非常高昂的操作。</p>
</blockquote>
<p>当要处理的数据很大时，无法一次全部装入内存。这时对B树调整，使得B树的阶数与硬盘存储的页面大小相匹配。比如说一棵B树的阶为1001（即1个节点包含1000个关键字），高度为2（从0开始），它可以存储超过10亿个关键字（1001x1001x1000+1001x1000+1000）,只要让根节点持久的保留在内存中，那么在这颗树上，寻找某一个关键字至多需要两次硬盘的读取即可。</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><img src="/img/multitree/b.png"/></p>
<p>假设要查询的数值是5，查询过程：</p>
<p>第一次IO：把9节点加载到内存中，在内存中与目标比较；<br>第二次IO：把（2，6）节点加载到内存中，在内存中与目标比较；<br>第二次IO：把（3，5）节点加载到内存中，在内存中与目标比较；</p>
<blockquote>
<p>二叉查找树情况下，每个节点只存放一个数据，查询数据的时候每加载节点比较一遍，进行一次磁盘IO。最坏情况下，磁盘IO次数等于树的高度</p>
</blockquote>
<p>B树在查询过程中<strong>比较次数</strong>其实并不会比二叉查找树少，尤其当某一个节点中的元素数量很多的时候。可是，单个节点的元素比较都在内存中进行，相比较于磁盘IO的速度,内存中比较耗时可以忽略不计，性能提高比较大。所以只要树的高度足够低，IO数量足够少，查询性能提升越明显。 相比之下，只要不超过磁盘页的大小，仅仅是多了几次内存的交互，这也是B树的优势之一。</p>
<p>B树应用于文件系统索引和部分非关系型数据库，如MongoDB</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src="/img/multitree/b+.png"/></p>
<h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>单元素查询过程：在单元素查询时，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。<br>范围查询过程：例如查询3到11之间的元素,首先单元素查找到下限3，然后在链表上做遍历即可</p>
<p>3, 5 -&gt; 8 -&gt; 11</p>
<blockquote>
<p>B树只能依靠中序遍历来实现范围查询，3, 5 (-&gt; 6) -&gt; 8 (-&gt;9) -&gt; 11</p>
</blockquote>
<p>B+树适合随机查找，只不过查到后是索引，不能提供实际记录的访问，还需要到达包含此关键字的终端节点。非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。B+树还适合带有范围的查找。</p>
<h4 id="和B树查询的不同"><a href="#和B树查询的不同" class="headerlink" title="和B树查询的不同"></a>和B树查询的不同</h4><ul>
<li>B+树的中间节点没有卫星数据。B树中所有节点都带有卫星数据，而在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何的数据关联。所以同样大小的磁盘页可以容纳更多的节点元素，也意味着数据量相同的情况下，B+树的结构比B树更加“矮胖”，因此查询IO次数更少；</li>
<li>B+树的查询必须最终找到叶子节点，而B树只要匹配到元素即可，不论它是中间节点还是叶子节点，因此B树的查询性能并不稳定(最好情况是只查询根节点，最坏情况查询到叶子节点)，而B+树每一次查找都是稳定的。</li>
</ul>
<blockquote>
<p>卫星数据：指索引元素所指向的数据记录，比如数据库中的某一行</p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>大部分关系型数据库(如MySQL)使用的都是B+树作为索引。</p>
<blockquote>
<p><strong>关于索引</strong></p>
<ul>
<li>磁盘IO的存取次数是评价一个数据库索引优劣的关键性指标。利用索引查询数据的时会逐一加载磁盘页到内存当中，每一页对应索引树的节点。所以索引需要的是减少磁盘IO的次数以及节点存储更多的数据量。</li>
<li>在数据库的设计中，聚集索引(Clustered Index)，叶子节点直接包含了卫星数据。在非聚集索引(NonClustered Index)，叶子节点叶子节点存储的是主键值。</li>
</ul>
</blockquote>
<p>B+树相较于B树的优势有三个:</p>
<ul>
<li>IO次数更少：单一节点比B树存储了更多的数据，使得查询IO的次数减少</li>
<li>查询性能稳定：所有查询都要查找到叶子节点，查询性能稳定</li>
<li>范围查询简便：所有叶子节点形成有序链表，便于范围查询</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序 - 快速排序/归并排序/插入排序</title>
    <url>/2021/10/20/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>快速排序/归并排序/插入排序</p>
</blockquote>
<span id="more"></span>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；partition函数返回pivot的位置。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；（递归改非递归——栈）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;<span class="comment">//表示已经完成一个组的排序</span></span><br><span class="line">    <span class="keyword">int</span> index = Partition(array,left,right);<span class="comment">//pivot的位置</span></span><br><span class="line">    QuickSort(array,left,index - <span class="number">1</span>);</span><br><span class="line">    QuickSort(array,index + <span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Partition的几种写法</p>
<p><img src="/img/sort/quicksort.gif" style="zoom:50%;" ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左右指针partition，分别从左右找到后交换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = array[right]; <span class="comment">// 确定pivot</span></span><br><span class="line">	<span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; array[left] &lt;= pivot)&#123; left++;&#125;</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; array[right] &gt;= pivot)&#123; right--;&#125;</span><br><span class="line">		swap(array[left],array[right]);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(array[left],pivot); <span class="comment">// 把pivot插到中间</span></span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挖坑partition，不等左右同时找到，找到一个就覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[left]; <span class="comment">// 确定pivot</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivot)&#123; right--;&#125;</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivot)&#123;left++;&#125;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前后指针partition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">    <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[i + <span class="number">1</span>], nums[right]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = array[right];</span><br><span class="line">        <span class="keyword">int</span> cur = left;</span><br><span class="line">        <span class="keyword">int</span> pre = cur - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果找到小于key的值，并且cur和pre之间有距离时则进行交换。注意两个条件的先后位置不能更换</span></span><br><span class="line">        <span class="keyword">while</span>(cur &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(array[cur] &lt; pivot &amp;&amp; pre++ != cur)&#123; swap(array[cur],array[pre]);&#125;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array[pre++],array[right]);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交换元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-基准的选择"><a href="#1-基准的选择" class="headerlink" title="1.基准的选择"></a>1.基准的选择</h3><p>(1)<strong>固定基准</strong>。如果数组元素是随机的，划分过程不产生极端情况，那么程序的运行时间不会有太大的波动。<br>如果数组元素已经基本有序时，此时的划分就容易产生最坏的情况，即快速排序变成冒泡排序，时间复杂度为O(n^2)。<br>(2)<strong>随机基准</strong>。虽然使用随机基准能解决待排数组基本有序的情况，但是由于这种随机性的存在，对其他情况的数组也会有影响(若数组元素是随机的，使用固定基准常常优于随机基准)。<br>(3)<strong>三数取中</strong>。选取数组开头，中间和结尾的元素，通过比较，选择中间的值作为快排的基准。其实可以将这个数字扩展到更大(例如5数取中，7数取中等)。这种方式能很好的解决待排数组基本有序的情况，而且选取的基准没有随机性。</p>
<h3 id="2-快速排序分析"><a href="#2-快速排序分析" class="headerlink" title="2.快速排序分析"></a>2.快速排序分析</h3><p>快速排序是一种不稳定的排序算法。</p>
<ol>
<li><strong>最坏时间复杂度：</strong>即元素都分到一个子序列，另一个子序列为空的情况，<strong>时间复杂度为O(N2)。</strong></li>
<li><strong>最好时间复杂度：</strong>即序列是均分为两个子序列，时间复杂度是<strong>O(NlogN)</strong>，与归并排序差不多。</li>
<li><strong>平均时间复杂度：O(NlogN)</strong>。</li>
<li><strong>空间复杂度：O(logN)</strong></li>
</ol>
<h3 id="3-快速排序的优化"><a href="#3-快速排序的优化" class="headerlink" title="3.快速排序的优化"></a>3.快速排序的优化</h3><p>优化1：序列长度达到一定大小时，使用插入排序</p>
<p>当快排达到一定深度后，划分的区间很小时，再使用快排的效率不高。当待排序列的长度达到一定数值后，可以使用插入排序。由《数据结构与算法分析》(Mark Allen Weiness所著)可知，当待排序列长度为5~20之间，此时使用插入排序能避免一些有害的退化情形。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">10</span>)&#123;</span><br><span class="line">        InsertSort(arr,low,high);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;<span class="comment">//表示已经完成一个组的排序</span></span><br><span class="line">	<span class="keyword">int</span> index = Partition(array,left,right);<span class="comment">//pivot的位置</span></span><br><span class="line">	QuickSort(array,left,index - <span class="number">1</span>);</span><br><span class="line">	QuickSort(array,index + <span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>采用经典的<strong>分治</strong>（divide-and-conquer）策略（分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而<strong>治(conquer)</strong>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<ol>
<li>将数列划分为两部分；</li>
<li>递归地分别对两个子序列进行归并排序；</li>
<li>合并两个子序列。</li>
</ol>
<p><img src="/img/sort/mergesort.gif" style="zoom: 67%;" ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    sort(arr, L, mid);</span><br><span class="line">    sort(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 比较左右两部分的元素，哪个小，把那个元素填入temp中。先执行语句，执行完后自加</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123; temp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#125;</span><br><span class="line">    <span class="comment">// 上面的循环退出后，把剩余的元素依次填入到temp中</span></span><br><span class="line">    <span class="comment">// 以下两个while只有一个会执行</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid) &#123; temp[i++] = arr[p1++];&#125;</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R) &#123; temp[i++] = arr[p2++];&#125;</span><br><span class="line">    <span class="comment">// 把最终的排序的结果复制给原数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; temp.length; i++) &#123; arr[L + i] = temp[i];&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：O(nlogn)</strong><br><strong>空间复杂度：O(N)</strong>，归并排序需要一个与原数组相同长度的数组做辅助来排序<br>稳定性：归并排序是稳定的排序算法，<code>temp[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</code>这行代码可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序与打扑克时整理手上的牌非常类似。摸来的第1张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的1张并插入左手的牌(有序区)中正确的位置上。为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较。</p>
<p><img src="/img/sort/insertion.gif" style="zoom: 67%;" ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionsort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n = arr.length; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123; </span><br><span class="line">        <span class="keyword">int</span> key = arr[i]; </span><br><span class="line">        <span class="keyword">int</span> j = i-<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123; </span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j]; </span><br><span class="line">            j = j-<span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        arr[j+<span class="number">1</span>] = key; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>不稳定排序算法。<br>最坏情况：$O(n^2)$<br>最好情况：$O(n) $<br>平均情况：$O(n^2)$ </p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 / Hash</title>
    <url>/2021/10/20/hash/</url>
    <content><![CDATA[<blockquote>
<p>Hash，一般译做散列或音译为哈希，是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值，是一种压缩映射。</p>
</blockquote>
<span id="more"></span>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希的过程中需要使用哈希函数进行计算。<br>哈希函数是一种<strong>映射关系</strong>，根据数据的关键词$ key $，通过一定的函数关系，计算出该元素存储位置的函数。<br>表示为：$address = H [key]$<br>哈希函数属性：</p>
<ol>
<li>哈希函数接收任意长度的输入。哈希函数拥有较为庞大的输入值域，接受长度非常长的输入值。实际实现中会指明一个具体可接收的阈值，例如SHA-2最高接受$\frac{2^{64}-1}{8}$长度的字节字符串。</li>
<li>产生固定长度的输出值。</li>
<li>不可逆性，已知哈希函数fn与x的哈希值无法反向求出x。这里的不可逆是指计算上行不通，正着算很好算，反着算在当前的计算机计算能力条件下做不到。</li>
<li>对于特定的哈希函数，只要输入值不变，输出的值也是唯一不变的。</li>
<li>哈希函数的计算时间不应过长，即通过输入值求出输出值的时间不宜过长。</li>
<li>无冲突性，即对于输入值x与哈希函数$f_n$，无法求出一个值$y$，使得$x$与$y$的哈希值相等。但是由于哈希函数实际上代表着一种映射（对应关系），将一个大区间上的数值映射到一个小区间上，它一定是有冲突的，这里的无冲突同样是指“求冲突在计算上行不通”，正向地计算很容易，但是反向的计算在当前的计算机能力条件下做不到。</li>
<li>即使修改了输入值的一个比特位，也会使得输出值发生巨大的变化。</li>
<li>哈希函数产生的映射应当保持均匀，即不要使得映射结果堆积在小区间的某一块区域。</li>
</ol>
<p>常见的哈希函数构造方法：</p>
<h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><ul>
<li>取关键字或关键字的某个线性函数值为散列地址。</li>
<li>即 $H(key) = key$ 或$ H(key) = a*key + b$，其中a和b为常数。</li>
</ul>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><ul>
<li>取关键字被某个不大于散列表长度$ m$ 的数$ p$ 求余，得到的作为散列地址。</li>
<li>即 $H(key) = key\ \%\ p$，$ p \leq m$或$H(key) = key\ mod\ p$，$ p \leq m$</li>
</ul>
<h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><ul>
<li>当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址。</li>
<li>仅适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。</li>
</ul>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><ul>
<li>先计算出关键字值的平方，然后取平方值中间几位作为散列地址。</li>
<li>随机分布的关键字，得到的散列地址也是随机分布的。</li>
</ul>
<h3 id="折叠法（叠加法）"><a href="#折叠法（叠加法）" class="headerlink" title="折叠法（叠加法）"></a>折叠法（叠加法）</h3><ul>
<li>将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。</li>
<li>用于关键字位数较多，并且关键字中每一位上数字分布大致均匀。 </li>
</ul>
<h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><ul>
<li>选择一个随机函数，把关键字的随机函数值作为它的哈希值。</li>
<li>通常当关键字的长度不等时用这种方法。 </li>
</ul>
<p>构造哈希函数的方法很多，实际工作中要根据不同的情况选择合适的方法，总的原则是尽可能少的产生冲突。</p>
<p>通常考虑的因素有<strong>关键字的长度</strong>和<strong>分布情况</strong>、<strong>哈希值的范围</strong>等。</p>
<p>如：当关键字是整数类型时就可以用除留余数法；如果关键字是小数类型，选择随机数法会比较好。</p>
<h2 id="哈希冲突的解决"><a href="#哈希冲突的解决" class="headerlink" title="哈希冲突的解决"></a>哈希冲突的解决</h2><p>选用哈希函数计算哈希值时，可能不同的$ key $会得到相同的结果，一个地址如何存放多个数据？这就是冲突。</p>
<p>常用的主要有两种方法解决冲突：</p>
<h3 id="链接法（拉链法）"><a href="#链接法（拉链法）" class="headerlink" title="链接法（拉链法）"></a>链接法（拉链法）</h3><p>拉链法解决冲突的做法是： 将所有关键字为同一哈希值的结点链接在同一个单链表中。<br>若选定的散列表长度为 $m$，则可将散列表定义为一个由 $m$ 个头指针组成的指针数组 $T[0..m-1] $。<br>凡是散列地址为 $i$ 的结点，均插入到以$ T[i] $为头指针的单链表中。<br>$T $中各分量的初值均应为空指针。<br>在拉链法中，装填因子$ α $可以大于 1，但一般均取 $α ≤ 1$。</p>
<h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>用开放定址法解决冲突的做法是：</p>
<blockquote>
<p>用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到开放的地址则表明表中无待查的关键字，即查找失败。</p>
</blockquote>
<p>简单的说：当冲突发生时，使用某种探查(亦称探测)技术在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。<br>按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。</p>
<h4 id="线性探查法"><a href="#线性探查法" class="headerlink" title="线性探查法"></a>线性探查法</h4><p>$h_i=(h(key)+i) ％ m $，$0 ≤ i ≤ m-1 $<br>基本思想是：<br>探查时从地址 $d$ 开始，首先探查 $T[d]$，然后依次探查$ T[d+1]，…，$直到$ T[m-1]$，此后又循环到 $T[0]，T[1]，…，$直到探查到 <strong>有空余地址</strong> 或者到 $T[d-1]$为止。</p>
<h4 id="二次探查法"><a href="#二次探查法" class="headerlink" title="二次探查法"></a>二次探查法</h4><p>$h_i=(h(key)+i*i) ％ m$，$0 ≤ i ≤ m-1 $</p>
<p>基本思想是：<br>探查时从地址$ d$ 开始，首先探查 $T[d]$，然后依次探查$ T[d+1^2]，T[d+2^2]，T[d+3^2],…，$等，直到探查到 <strong>有空余地址</strong> 或者到 $T[d-1]$为止。<br>缺点是无法探查到整个散列空间。</p>
<h4 id="双重散列法"><a href="#双重散列法" class="headerlink" title="双重散列法"></a>双重散列法</h4><p>$h_i=(h(key)+i*h_1(key)) ％ m$，$0 ≤ i ≤ m-1 $</p>
<p>基本思想是：<br>探查时从地址$ d $开始，首先探查$ T[d]$，然后依次探查$ T[d+h1(d)], T[d + 2*h1(d)]，…，$等。<br>该方法使用了两个散列函数$ h(key)$ 和 $h_1(key)$，故也称为双散列函数探查法。</p>
<p>定义$ h_1(key)$ 的方法较多，但无论采用什么方法定义，都必须使$ h_1(key) $的值和$ m $互素，才能使发生冲突的同义词地址均匀地分布在整个表中，否则可能造成同义词地址的循环计算。<br>该方法是开放定址法中最好的方法之一。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表（hash table）是哈希函数最主要的应用。哈希表是实现关联数组（associative array）的一种数据结构，广泛应用于实现数据的快速查找。</p>
<p>用哈希函数计算关键字的哈希值（hash value）,通过哈希值这个索引就可以找到关键字的存储位置，即桶（bucket）。哈希表不同于二叉树、栈、序列的数据结构一般情况下，在哈希表上的插入、查找、删除等操作的时间复杂度是$ O(1)$。</p>
<p>查找过程中，关键字的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。<br>影响产生冲突多少有以下三个因素：</p>
<ol>
<li>哈希函数是否均匀；</li>
<li>处理冲突的方法；</li>
<li>哈希表的加载因子。（加载因子 = 填入表中记录个数/散列长度）</li>
</ol>
<p>哈希表的加载因子和容量决定了在什么时候桶数（存储位置）不够，需要重新哈希。加载因子太大的话桶太多，遍历时效率变低；太小的话频繁 rehash，导致性能降低。所以加载因子的大小需要结合时间和空间效率考虑。</p>
<h4 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h4><blockquote>
<p>简单来说，<strong>HashMap由数组+链表组成的</strong>，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。<br>如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可<br>如果定位到的数组包含链表，对于添加操作，其时间复杂度为$O(n)$，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。<br>所以，性能考虑，<strong>HashMap中的链表出现越少，性能才会越好。</strong></p>
</blockquote>
<p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>
<p><img src="/img/hash/hashmap.png"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Entry是HashMap中的一个静态内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">    <span class="keyword">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Creates new entry.</span></span><br><span class="line">	Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重要字段</span></span><br><span class="line"><span class="comment">//实际存储的key-value键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**负载因子，代表了table的填充度，默认是0.75</span></span><br><span class="line"><span class="comment">为了减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**HashMap被改变的次数，由于HashMap非线程安全，在对HashMap进行迭代时，</span></span><br><span class="line"><span class="comment">如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），</span></span><br><span class="line"><span class="comment">需要抛出异常ConcurrentModificationException*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</span></span><br><span class="line"><span class="comment">initialCapacity默认为16，loadFactory默认为0.75</span></span><br><span class="line"><span class="comment">在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">　　　　　<span class="comment">//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(2^30)</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        init();<span class="comment">//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，</span></span><br><span class="line">        <span class="comment">//此时threshold为initialCapacity 默认是1&lt;&lt;4(2^4=16)</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//获取在table中的实际位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;<span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//新增一个entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，</p>
<p>比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//capacity一定是2的次幂</span></span><br><span class="line">    <span class="comment">/**此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，</span></span><br><span class="line"><span class="comment">        capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1 */</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容。</span></span><br><span class="line"><span class="comment">//扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终存储位置的确定流程：</p>
<p><img src="/img/hash/2.png"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回数组下标</span></span><br><span class="line"><span class="comment">//h&amp;（length-1）保证获取的index一定在数组范围内，如默认容量16，length-1=15，h=18,转换成二进制计算为index=2。位运算对计算机来说，位运算性能更高一些</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为何HashMap的数组长度一定是2的次幂"><a href="#为何HashMap的数组长度一定是2的次幂" class="headerlink" title="为何HashMap的数组长度一定是2的次幂"></a>为何HashMap的数组长度一定是2的次幂</h4><p>HashMap的数组长度一定保持2的次幂，保证length-1低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)</p>
<p>如果不是2的次幂，也就是低位不是全为1此时，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大。</p>
<h4 id="hashmap与hashtable区别"><a href="#hashmap与hashtable区别" class="headerlink" title="hashmap与hashtable区别"></a>hashmap与hashtable区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">hashmap</th>
<th style="text-align:left">hashtable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>初始化和扩容数据</strong></td>
<td style="text-align:left">初始容量为 16，扩容大小为2n</td>
<td style="text-align:left">初始容量为 11，扩容大小为2n+1</td>
</tr>
<tr>
<td style="text-align:center"><strong>线程安全</strong></td>
<td style="text-align:left">线程不安全，方法不是Synchronize的要提供外同步，效率高</td>
<td style="text-align:left">线程安全，方法是是Synchronize的，效率低</td>
</tr>
<tr>
<td style="text-align:center"><strong>遍历方式</strong></td>
<td style="text-align:left">通过实现 Iterator接口实现</td>
<td style="text-align:left">通过实现 Enumeration, Iterator 来遍历</td>
</tr>
<tr>
<td style="text-align:center"><strong>对于null的处理</strong></td>
<td style="text-align:left">允许有null的键和值，当key为null的时候，会放在第0位</td>
<td style="text-align:left">不允许有null的键和值</td>
</tr>
<tr>
<td style="text-align:center"><strong>contains方法</strong></td>
<td style="text-align:left">containsValue和containsKey</td>
<td style="text-align:left">contains</td>
</tr>
<tr>
<td style="text-align:center"><strong>计算hash值方式</strong></td>
<td style="text-align:left">(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</td>
<td style="text-align:left">hashCode()</td>
</tr>
<tr>
<td style="text-align:center"><strong>解决hash冲突方式</strong></td>
<td style="text-align:left">链表+红黑树</td>
<td style="text-align:left">链表</td>
</tr>
</tbody>
</table>
</div>
<h4 id="JDK1-8中HashMap的性能优化"><a href="#JDK1-8中HashMap的性能优化" class="headerlink" title="JDK1.8中HashMap的性能优化"></a>JDK1.8中HashMap的性能优化</h4><p>假如一个数组槽位上链上数据过多（即拉链过长的情况）导致性能下降该怎么办？</p>
<p>JDK1.8在JDK1.7的基础上针对增加了红黑树来进行优化。即当链表超过8时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。<br><strong>HashMap put方法逻辑图（JDK1.8）</strong></p>
<p><img src="/img/hash/put.png"/></p>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><h4 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h4><p>对称加密：加密和解密的秘钥使用的是同一个，发送方和接收方事先商量好</p>
<p>缺点：每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担；密钥必须通过见面协商，而无法直接通过网络进行交换。</p>
<p><img src="/img/hash/duichen.jpg"/></p>
<p>非对称加密（公钥加密）：需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。由于公钥是对所有人公开的，所以需要保证数据被公钥加密后无法反推，即单向计算容易，逆向反推困难。模运算即是这样的单向函数。</p>
<p><img src="/img/hash/feiduichen.jpg"/></p>
<blockquote>
<p>模运算，例如，已知$3^3mod\ 7 = 6$，反之已知$3^xmod\ 7 = 6$，求$x$很困难，只能一个数一个数带入尝试。而对于大数来说更不现实。</p>
</blockquote>
<h4 id="RSA的加密解密过程"><a href="#RSA的加密解密过程" class="headerlink" title="RSA的加密解密过程"></a>RSA的加密解密过程</h4><p>RSA属于非对称加密算法。</p>
<p>原始数据$m（message）$，加密密钥$e（encrypt）$，密文$c（cipher）$，解密密钥$d（decrypt）$</p>
<p><img src="/img/hash/rsa.jpg" style="zoom:50%;" /></p>
<p>变换后得</p>
<p><img src="/img/hash/ed.jpg" style="zoom: 33%;" /></p>
<p>如何选$e，d$是关键。</p>
<blockquote>
<p><strong>互质</strong>，又称互素。若$N$个整数的最大公因子是1，则称这$N$个整数互质。<br><strong>欧拉函数</strong>，用于计算在小于等于$n$的正整数之中，有多少个数与$n$构成互质关系，以$φ(n)$表示<br>计算8的欧拉函数，和8互质的 <strong>1</strong>、<strong>3</strong>、<strong>5</strong>、<strong>7</strong>，$φ(8) = 4$</p>
<ul>
<li>如果$n$是质数的某一个次方，即$ n = p^k $($p$为质数，$k$为大于等于1的整数)，则$φ(n) = φ(p^k) = p^k - p^(k-1)$。比如$φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4$</li>
<li>如果$n$是质数，则 $φ(n)=n-1$。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</li>
<li>如果$n$可以分解成两个互质的整数之积，即 $n = p <em> k $，则$φ(n) = φ(p </em> k) = φ(p)<em>φ(k)$。比如$φ(56) = φ(8) </em> φ(7) = 4 * 6 = 24$</li>
<li>求$φ(n)$很困难，只能通过质因数分解。对大数求$φ(n)$计算上不可行。<br><strong>欧拉定理</strong>，如果两个正整数m和n互质，那么m的φ(n)次方减去1，可以被n整除。$m^{φ(n)}mod\ n\equiv 1$</li>
</ul>
</blockquote>
<p>对欧拉定理变形，$m^{φ(n)}\equiv 1 (mod\ n)$<br>$m^{kφ(n)}\equiv 1 (mod\ n)$<br>$m^{kφ(n)+1}\equiv m (mod\ n)$<br>$m^{kφ(n)+1}mod\ n\equiv m $</p>
<p>可得，$ed = kφ(n)+1$，$d = \frac{kφ(n)+1}{e}$。通过选取$k，n，e$，来计算解密密钥$d$</p>
<p>RSA算法具体的加密过程如下：</p>
<p>假设Alice想通过一个不可靠的媒体接受Bob的一条私人消息，他可以用下面的方式产生一个公钥和私钥。</p>
<ul>
<li>随意选择两个大的质数$p$和$q$，$p$不等于$q$，计算$N = p*q$.</li>
<li>根据欧拉函数，求得$φ(N)=φ(p)φ(q)=(p-1)(q-1)$。</li>
<li>选择一个小于$φ(N)$的整数$e$，使$e$与$φ(N)$互质。并求得$d$。</li>
<li>将$p$和$q$的记录销毁。</li>
</ul>
<p>其中$(N，e)$是公钥，$(N，d)$是私钥。</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>RSA的应用包括数字签名，数字证书，ssh，https等。实际应用中，由于公钥加密计算量大，速度慢，常和对称加密一起使用，公钥加密算法常被用作最初建立连接，真正数据传输过程用对称加密算法处理。</p>
<p><img src="/img/hash/https.jpg" style="zoom: 67%;" /></p>
<ul>
<li>ssh（Secure Shell）</li>
</ul>
<p>简单说，SSH是一种网络协议，存在多种实现，既有商业实现，也有开源实现，采用了非对称加密技术(RSA)加密了所有传输的数据，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>
<p>由于公私钥是唯一的一对，在客户端保障自己私钥安全的情况下，服务端通过公钥就可以完全确定客户端的真实性，所以要实现公钥登陆，要先生成一个公私密钥对。通过 <code>ssh-keygen -t rsa</code> 命令来生成密钥对，默认会保存到 <code>~/.ssh</code> 目录。使用<code>ssh-copy-id</code>命令将公钥复制到远程主机。ssh-copy-id会将公钥写到远程主机的 <code>~/ .ssh/authorized_key</code> 文件中</p>
<ul>
<li>https</li>
</ul>
<p>HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：<br>1、TCP 三次同步握手<br>2、客户端验证服务器数字证书<br>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥<br>4、SSL 安全加密隧道协商完成<br>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</p>
<blockquote>
<p><strong>HTTP 与 HTTPS 区别</strong></p>
<p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。<br>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。<br>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p>
</blockquote>
<h3 id="MD5算法-数字摘要"><a href="#MD5算法-数字摘要" class="headerlink" title="MD5算法/数字摘要"></a>MD5算法/数字摘要</h3><p>用于提供消息的完整性性保护。算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值，即16字节。又称数字摘要/数字指纹。</p>
<blockquote>
<p>不可逆，从结果无法反推原始数据<br>高度离散性，输出结果无法预测，哪怕输入改变一个bit输出也完全不同<br>抗碰撞性，想找到两个产生完全一致的md5的数据非常困难</p>
</blockquote>
<p>应用场景：</p>
<ul>
<li>用户密码保护，储存密码时不记录密码本身，只记录密码的md5结果，只有用户自己知道密码明文</li>
<li>文件完整性校验，文件较大，网络传输的不可靠因素导致传输不完整，或被篡改，校验接收端与发送端的文件一致</li>
<li><p>数字签名，发布程序同时发布md5，防止植入木马。</p>
<blockquote>
<p>经过发送方私钥加密的数字摘要，即“数字签名”，数字签名能确定消息确实是由发送方签名并发送出，因为别人假冒不了发送方的签名。还能能验证数据的完整性。</p>
</blockquote>
</li>
<li><p>云盘秒传，数据库中搜索是否存在相同的md5，如果存在则使用现有的即可。</p>
</li>
</ul>
<p>大概步骤如下：<br>填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。即便原始长度满足也必须进行。填充完后，信息的长度就为N*512+448(bit)；</p>
<p>记录信息长度：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。</p>
<p>装入标准幻数（四个整数）：标准的幻数（物理顺序）是（A=(01234567) 16 ，B=(89ABCDEF) 16 ，C=(FEDCBA98) 16 ，D=(76543210) 16 ）。在程序中定义是小端，高位在前（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L）。</p>
<p>四轮循环运算：循环的次数是分组的个数（N+1）</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java / JDBC</title>
    <url>/2021/07/07/jdbc/</url>
    <content><![CDATA[<blockquote>
<p>Java DataBase Connectivity, Java连接数据库，是SUN公司制定的一套接口, java.sql.*;</p>
<p>后期将集成到Mybatis框架中。</p>
</blockquote>
<span id="more"></span>
<p>从官网下载对应的驱动jar包，将其配置到环境变量classpath。<br><code>classpath=.;D:\course\06-JDBC\resources\MySql Connector Java 5.1.23\mysql-connector-java-5.1.23-bin.jar</code></p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 1、注册驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();	<span class="comment">//多态，父类型引用指向子类型对象</span></span><br><span class="line">        DriverManager.registerDriver(driver); <span class="comment">//静态方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册驱动的另一种方法</span></span><br><span class="line">        <span class="comment">//Class.forName(driver);</span></span><br><span class="line">        <span class="comment">//不用接受返回值，只想用类加载这个操作，执行静态代码块完成注册驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取连接</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">				url包括哪几部分:协议，IP，Port，资源名				</span></span><br><span class="line"><span class="comment">				eg：http://180.101.49.11:80/index.html</span></span><br><span class="line"><span class="comment">			http:// 通信协议; 180.101.49.11 IP地址; 80 端口号; index.html 资源名</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mydatabase&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;146&quot;</span>;</span><br><span class="line">        <span class="comment">// static Connection getConnection(String url, String user, String password)</span></span><br><span class="line">        conn = DriverManager.getConnection(url,user,password); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;数据库连接对象&quot; + conn);	</span></span><br><span class="line">        <span class="comment">//数据库连接对象com.mysql.jdbc.JDBC4Connection@1ae369b7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、获取数据库操作对象</span></span><br><span class="line">        <span class="comment">// Statement createStatement() 创建一个 Statement 对象来将 SQL 语句发送到数据库。</span></span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、执行sql语句</span></span><br><span class="line">        <span class="comment">// int executeUpdate(String sql) </span></span><br><span class="line">        <span class="comment">// 专门执行DML语句,返回值是“影响数据库中的记录条数”</span></span><br><span class="line">        <span class="comment">// 这里的sql语句不用;</span></span><br><span class="line">        <span class="keyword">int</span> count = stmt.executeUpdate(<span class="string">&quot;update dept set dname = &#x27;销售部&#x27;,</span></span><br><span class="line"><span class="string">                                       loc = &#x27;合肥&#x27; where deptno = 20;&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(count == 1 ? &quot;保存成功&quot;:&quot;保存失败&quot;);</span></span><br><span class="line">		<span class="comment">// 5、处理查询结果集</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6、释放资源, 从小到大依次关闭</span></span><br><span class="line">            <span class="comment">// 释放Statement</span></span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>	&#123;</span><br><span class="line">                    stmt.close();	</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放Connection</span></span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>	&#123;</span><br><span class="line">                    conn.close();	</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理返回结果"><a href="#处理返回结果" class="headerlink" title="处理返回结果"></a>处理返回结果</h2><p>executeUpdate：insert/update/delete, 返回结果对表文件操作时，受影响行数<br>executeQuery：查询命令【select  *  from 表名】，返回结果是查询命令得到【临时表】，ResultSet实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="comment">//rs = stmt.executeQuery(&quot;select empno,ename,sal from emp&quot;);</span></span><br><span class="line"><span class="comment">//遍历查询到的结果</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="comment">//按顺序取</span></span><br><span class="line">    String empno = rs.getString(<span class="number">1</span>);</span><br><span class="line">    String ename = rs.getString(<span class="number">2</span>);</span><br><span class="line">    String sal = rs.getString(<span class="number">3</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + sal);</span><br><span class="line">	<span class="comment">//按名称取出</span></span><br><span class="line">    String empno = rs.getString(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">    String ename = rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">    String sal = rs.getString(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + sal);</span><br><span class="line">	<span class="comment">//类型+顺序</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String ename = rs.getString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="number">3</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + (sal + <span class="number">100</span>));</span><br><span class="line">	<span class="comment">//类型+名称</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">    String ename = rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + (sal + <span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用动态资源绑定器传参"><a href="#使用动态资源绑定器传参" class="headerlink" title="使用动态资源绑定器传参"></a>使用动态资源绑定器传参</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResourceBundle bundle = ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>); <span class="comment">//.properties后缀不用写</span></span><br><span class="line">String driver = bundle.getString(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">String url = bundle.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String user = bundle.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password = bundle.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">conn = DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mydatabase</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">146</span></span><br></pre></td></tr></table></figure>
<h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><p>问题：用户输入语句含有sql语句关键字，完成了sql语句的拼接，参与编译，导致原sql语句含义被扭曲。<br>解决方法：用户提供的信息不参与编译过程，用java.sql.PreparedStatement（继承java.sql.Statement）</p>
<ul>
<li>PreparedStatement属于预编译的数据库操作对象，原理：预先对sql语句的框架进行编译，再给sql语句传“值”，使用较多。</li>
<li>PreparedStatement效率高。只用预编译一次，可执行多次。在编译阶段做安全检查（ps.setString()）Statement执行一次编译一次</li>
<li>要求支持sql语句拼接时使用Statement。（如升/降序是在语句末尾拼接asc/desc）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用PreparedStatement模拟登录，防止sql注入现象</span></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Statement stat = null;</span></span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1、注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">// 2、获取连接</span></span><br><span class="line">    conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;146&quot;</span>);</span><br><span class="line">    <span class="comment">// 3、获取预编译的数据库操作对象</span></span><br><span class="line">    <span class="comment">// sql语句的框架中，一个?，表示一个占位符，一个?将来接收一个值。注意：?不用单引号括起来</span></span><br><span class="line">    String sql = <span class="string">&quot;select * from t_user where userName = ? and userPassword = ?&quot;</span>;</span><br><span class="line">    <span class="comment">// 程序执行到此处，会发送sql语句框架给DBMS，DBMS对sql语句框架进行预编译。</span></span><br><span class="line">    ps = conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 给占位符?传值，第一个?的下标是1，第二个?的下标是2（JDBC中下标都从1开始）</span></span><br><span class="line">    ps.setString(<span class="number">1</span>,userLoginInfo.get(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">    ps.setString(<span class="number">2</span>,userLoginInfo.get(<span class="string">&quot;userPassword&quot;</span>));</span><br><span class="line">    <span class="comment">// 4、执行sql语句</span></span><br><span class="line">    rs = ps.executeQuery();</span><br><span class="line">    <span class="comment">// 5、处理结果集</span></span><br><span class="line">    <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">        loginSuccess = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 6、释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升降序排列时需要sql注入</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入desc或者asc&quot;</span>);</span><br><span class="line">String keyWords = s.nextLine();</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">    conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;146&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//createStatement可以完成拼接</span></span><br><span class="line">    stmt = conn.createStatement();</span><br><span class="line">    String sql = <span class="string">&quot;select ename from emp order by ename &quot;</span> + keyWords;</span><br><span class="line">    rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">        System.out.println(rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDBC事务自动提交"><a href="#JDBC事务自动提交" class="headerlink" title="JDBC事务自动提交"></a>JDBC事务自动提交</h2><p>即执行任一条DML语句，则自动提交一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//conn.setAutoCommit(false); // 开启事务</span></span><br><span class="line"><span class="comment">//conn.commit(); // 提交事务</span></span><br><span class="line"><span class="comment">//conn.rollback(); // 回滚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        conn = DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">            <span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="string">&quot;146&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------将自动提交改为手动提交------------------------------</span></span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// 开启事务</span></span><br><span class="line">        <span class="comment">//-----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取预编译的数据库操作对象</span></span><br><span class="line">        String sql = <span class="string">&quot;update t_act set balance = ? where actno = ? &quot;</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        ps.setInt(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">        ps.setDouble(<span class="number">2</span>,<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行sql语句</span></span><br><span class="line">        <span class="keyword">int</span> count = ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String s = null;</span></span><br><span class="line"><span class="comment">            s.toString();</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        ps.setInt(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">        ps.setDouble(<span class="number">2</span>,<span class="number">222</span>);</span><br><span class="line">        count += ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        System.out.println(count == <span class="number">2</span> ? <span class="string">&quot;转账成功&quot;</span> : <span class="string">&quot;转账失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -----------程序能执行到此处，说明没有异常，事务结束，手动提交数据----------------------</span></span><br><span class="line">        conn.commit(); <span class="comment">// 提交事务</span></span><br><span class="line">        <span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// --------遇到异常，回滚-------------------</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback(); <span class="comment">// 回滚</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//-----------------------------------------</span></span><br><span class="line">    &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>行级锁（悲观锁）:for update 当前事务结束之前，行结果被锁住，无法修改。事务排队进行，不允许并发<br>乐观锁：多线程并发，事务不需要排队，都可以修改，需要版本号。</p>
<h2 id="DAO与Entity"><a href="#DAO与Entity" class="headerlink" title="DAO与Entity"></a>DAO与Entity</h2><p>DAO(Data Access Object) 数据访问对象，将数据库操作都封装起来。包括：<br>1）实体类Dept：用于存放与传输对象数据。<br>2）数据库连接和关闭工具类JdbcUtil： 避免了数据库连接和关闭代码的重复使用，方便修改。<br>3）DAO 实现类DeptDao： 针对不同数据库给出DAO接口定义方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实体类（一张表对应一个实体，用于描述表结构，一个实例对象对应表中一个数据行，属性与表中字段保持一致）</span></span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.entity;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deptNo;</span><br><span class="line">    <span class="keyword">private</span> String  dname;</span><br><span class="line">    <span class="keyword">private</span> String  loc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDeptNo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> deptNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeptNo</span><span class="params">(Integer deptNo)</span> </span>&#123;<span class="keyword">this</span>.deptNo = deptNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDname</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> dname;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDname</span><span class="params">(String dname)</span> </span>&#123;<span class="keyword">this</span>.dname = dname;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoc</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> loc;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoc</span><span class="params">(String loc)</span> </span>&#123;<span class="keyword">this</span>.loc = loc;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dept</span><span class="params">(Integer deptNo, String dname, String loc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deptNo = deptNo;</span><br><span class="line">        <span class="keyword">this</span>.dname = dname;</span><br><span class="line">        <span class="keyword">this</span>.loc = loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据库连接和关闭工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Connection con = <span class="keyword">null</span>;<span class="comment">//类文件属性，可以在类文件中所有的方法中使用</span></span><br><span class="line">    <span class="keyword">private</span>  PreparedStatement ps=<span class="keyword">null</span>;<span class="comment">//类文件属性，可以在类文件中所有的方法中使用</span></span><br><span class="line">    <span class="comment">//静态语句块 static&#123;&#125;</span></span><br><span class="line">    <span class="comment">//在当前类文件第一次被加载到JVM时，JVM将会自动调用当前类文件静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//1.注册数据库服务器提供的Driver接口实现类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装Connection对象创建细节 不需要考虑使用对象创建细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Connection  <span class="title">createCon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection对象创建失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象创建细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createStatement</span><span class="params">(String sql)</span></span>&#123;</span><br><span class="line">        Connection con = createCon();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = con.prepareStatement(sql);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象与Connection对象销毁细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ps!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象与Connection对象与ResultSet对象销毁细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DAO接口实现（命名为表名+Dao，实现CRUD功能）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  JdbcUtil util = <span class="keyword">new</span> JdbcUtil();</span><br><span class="line">    <span class="comment">//添加数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(String deptNo,String dname,String loc)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;insert into dept (deptNo,dname,loc) values(?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setInt(<span class="number">1</span>, Integer.valueOf(deptNo));</span><br><span class="line">            ps.setString(<span class="number">2</span>, dname);</span><br><span class="line">            ps.setString(<span class="number">3</span>, loc);</span><br><span class="line">            result=ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String deptNo)</span></span>&#123;</span><br><span class="line">        String sql =<span class="string">&quot;delete from dept where deptno=?&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setInt(<span class="number">1</span>, Integer.valueOf(deptNo));</span><br><span class="line">            result = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String deptNo,String dname,String loc)</span></span>&#123;</span><br><span class="line">        String  sql =<span class="string">&quot;update dept set dname=?,loc=? where deptno=?&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setString(<span class="number">1</span>, dname);</span><br><span class="line">            ps.setString(<span class="number">2</span>, loc);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, Integer.valueOf(deptNo));</span><br><span class="line">            result = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql =<span class="string">&quot;select * from dept&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">//将是临时表数据行转换为实体类实例对象保管</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">int</span> deptNo = rs.getInt(<span class="string">&quot;deptno&quot;</span>);</span><br><span class="line">                String dname = rs.getString(<span class="string">&quot;dname&quot;</span>);</span><br><span class="line">                String loc = rs.getString(<span class="string">&quot;loc&quot;</span>);</span><br><span class="line">                Dept dept = <span class="keyword">new</span> Dept(deptNo, dname, loc);</span><br><span class="line">                list.add(dept);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库 / MySQL</title>
    <url>/2021/10/09/mysql/</url>
    <content><![CDATA[<blockquote>
<p>MySQL，最流行的关系型数据库管理系统。</p>
</blockquote>
<span id="more"></span>
<h2 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show database;  #查看现有的数据库</span><br><span class="line">create database bjpowernode; #创建数据库</span><br><span class="line">use bjpowernode;  #指定当前缺省数据库</span><br><span class="line">select database;  #查看当前使用的库</span><br><span class="line">drop database bjpowernode; #删除数据库</span><br></pre></td></tr></table></figure>
<h2 id="数据表基本操作"><a href="#数据表基本操作" class="headerlink" title="数据表基本操作"></a>数据表基本操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;  #查看当前库中的表</span><br><span class="line">show tables from &lt;database name&gt;;  #查看其他库中的表</span><br><span class="line">desc &lt;table name&gt;;  #查看表的结构</span><br><span class="line"></span><br><span class="line">#创建表,create table,表名在数据库当中一般建议以t_或者tbl_开始。</span><br><span class="line">create table t_student(</span><br><span class="line">    no bigint,</span><br><span class="line">    name varchar(255),</span><br><span class="line">    sex char(1),</span><br><span class="line">    classno varchar(255),</span><br><span class="line">    birth char(10)</span><br><span class="line">);</span><br><span class="line"># 将查询结果当做表创建出来。		</span><br><span class="line">create table 表名 as select语句;</span><br><span class="line">		</span><br><span class="line">#删除数据表 DROP TABLE		</span><br><span class="line">DROP TABLE if exists t_student; </span><br><span class="line"></span><br><span class="line">#插入数据 insert into</span><br><span class="line">insert into t_student</span><br><span class="line">	(no,name,sex,classno,birth) </span><br><span class="line">values</span><br><span class="line">	(3,&#x27;rose&#x27;,&#x27;1&#x27;,&#x27;gaosi2ban&#x27;,&#x27;1952-12-14&#x27;),</span><br><span class="line">	(4,&#x27;laotie&#x27;,&#x27;1&#x27;,&#x27;gaosi2ban&#x27;,&#x27;1955-12-14&#x27;);</span><br><span class="line"># 除name字段之外，剩下的所有字段自动插入NULL	</span><br><span class="line">insert into t_student(name) values(&#x27;wangwu&#x27;); </span><br><span class="line"># 字段可以省略不写，但是后面的value对数量和顺序都有要求。</span><br><span class="line">insert into t_student values(1,&#x27;jack&#x27;,&#x27;0&#x27;,&#x27;gaosan2ban&#x27;,&#x27;1986-10-23&#x27;);</span><br><span class="line"># 将查询结果插入到一张表中</span><br><span class="line">insert into dept1 select...</span><br><span class="line"></span><br><span class="line">#修改数据，update...set...，没有条件整张表数据全部更新。</span><br><span class="line">update 表名 set 字段名1=值1,字段名2=值2... where 条件;</span><br><span class="line">update dept1 set loc = &#x27;SHANGHAI&#x27;, dname = &#x27;RENSHIBU&#x27; where deptno = 10;</span><br><span class="line"></span><br><span class="line">#删除数据，delete from，没有条件全部删除。</span><br><span class="line">delete from 表名;</span><br><span class="line">delete from 表名 where 条件;</span><br><span class="line">delete from dept1 where deptno = 10;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MySQL当中字段的常见数据类型：<br>        int        整数型(java中的int)<br>        bigint    长整型(java中的long)<br>        float        浮点型(java中的float double)<br>        char        定长字符串(String)<br>        varchar    可变长字符串(StringBuffer/StringBuilder)<br>        date        日期类型 （对应Java中的java.sql.Date类型）<br>        BLOB        二进制大对象（存储图片、视频等流媒体信息） Binary Large OBject （对应java中的Object）<br>        CLOB        字符大对象（存储较大文本，比如，可以存储4G的字符串。） Character Large OBject（对应java中的Object）</p>
<p>char和varchar？<br>当某个字段中的数据长度不发生改变的时候，是定长的，例如：性别、生日等采用char。当一个字段的数据长度不确定，例如：简介、姓名等用varchar。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查</span><br><span class="line"></span><br><span class="line">	select		5</span><br><span class="line">		...</span><br><span class="line">	from			1</span><br><span class="line">		...		</span><br><span class="line">	where			2</span><br><span class="line">		...	</span><br><span class="line">	group by		3</span><br><span class="line">		...</span><br><span class="line">	having		4</span><br><span class="line">		...</span><br><span class="line">	order by		6</span><br><span class="line">		...</span><br><span class="line">	limit			7</span><br><span class="line">		...;</span><br><span class="line"></span><br><span class="line">select empno, ename from emp;</span><br><span class="line">select * from emp;</span><br><span class="line">select empno, ename, sal*12 from emp; #select语句中可以使用运算符</span><br><span class="line">select empno as ‘员工编号’, ename as ‘员工姓名’, sal*12 as ‘年薪’ from emp;</span><br><span class="line">SELECT * from runoob_tbl  WHERE runoob_author LIKE &#x27;%COM&#x27;; # LIKE 子句中使用 % 字符来表示任意字符,类似正则表达式中 *</span><br><span class="line">select distinct deptno,job from emp; # distinct关键字去除重复记录。distinct只能出现在所有字段的最前面。</span><br><span class="line"></span><br><span class="line">#条件查询where</span><br><span class="line">select empno, ename, sal from emp where sal=5000;</span><br><span class="line">select empno, ename from emp where job=&quot;manager&quot;; #字符串加&quot; &quot;或&#x27; &#x27;,不区分大小写</span><br><span class="line"></span><br><span class="line">#排序，系统默认由小到大 order by</span><br><span class="line">select * from emp order by sal;</span><br><span class="line">select * from emp order by job,sal; #按照多个字段排序，首先按照job排序，再按照sal排序</span><br><span class="line">select * from emp order by sal asc/desc; #小到大/大到小</span><br><span class="line"></span><br><span class="line">#union，将查询结果集相加</span><br><span class="line">select ename,job from emp where job = &#x27;MANAGER&#x27;</span><br><span class="line">union</span><br><span class="line">select ename,job from emp where job = &#x27;SALESMAN&#x27;;</span><br><span class="line"></span><br><span class="line">#分组,对分组之后的数据进行再次过滤 group by...having...</span><br><span class="line">#分组函数/多行处理函数/聚合函数，count sum avg max min</span><br><span class="line">#分组函数不可直接使用在where子句当中,在group by语句执行结束之后才会执行,一般用在select子句中</span><br><span class="line"># 当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段。</span><br><span class="line"></span><br><span class="line">#连接查询</span><br><span class="line">#语法：</span><br><span class="line">		...</span><br><span class="line">			A</span><br><span class="line">		join</span><br><span class="line">			B</span><br><span class="line">		on</span><br><span class="line">			连接条件</span><br><span class="line">		where</span><br><span class="line">			...</span><br><span class="line"># limit startIndex, length,分页查询,取结果集中的部分数据,从0开始，0表示第一条数据</span><br><span class="line">#取出工资前5名的员工</span><br><span class="line">select ename,sal from emp order by sal desc limit 0, 5;</span><br><span class="line">select ename,sal from emp order by sal desc limit 5;</span><br><span class="line">#找出工资排名在第4到第9名的员工</span><br><span class="line">select ename,sal from emp order by sal desc limit 3,6;</span><br><span class="line">#通用的标准分页sql,每页显示3条记录,pageSize = 3,pageNo是显示第几页</span><br><span class="line">limit (pageNo - 1) * pageSize, pageSize</span><br></pre></td></tr></table></figure>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><blockquote>
<p>笛卡尔积现象，也称交叉连接。返回左表中的每一行与右表中的所有行组合。</p>
</blockquote>
<h3 id="内连接（等值连接）"><a href="#内连接（等值连接）" class="headerlink" title="内连接（等值连接）"></a>内连接（等值连接）</h3><p>组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集部分。<strong>显示部分数据</strong>。</p>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>以主表为基准(将主表的数据全部显示)，从表显示与主表对应的数据，如果对应的没有，则以null补齐。即<strong>结果全部显示</strong>。</p>
<h4 id="左"><a href="#左" class="headerlink" title="左"></a>左</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM a_table a </span><br><span class="line">left join b_table b # 左的左是左表</span><br><span class="line">ON a.a_id = b.b_id;</span><br></pre></td></tr></table></figure>
<p>左表（主）(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。</p>
<h4 id="右"><a href="#右" class="headerlink" title="右"></a>右</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM a_table a </span><br><span class="line">right outer join b_table b # 右的右是右表</span><br><span class="line">on a.a_id = b.b_id;</span><br></pre></td></tr></table></figure>
<p>右表（主）(b_table)的记录将会全部表示出来,左表(a_table)只会显示符合搜索条件的记录。左表记录不足的地方均为NULL。</p>
<h4 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h4><p>全连接=左连接+右连接，<code>full join</code></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>非空约束(not null)：约束的字段不能为NULL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line">    id int,</span><br><span class="line">    username varchar(255) not null,</span><br><span class="line">    password varchar(255)</span><br><span class="line">);</span><br><span class="line"># not null约束只有列级约束。没有表级约束。</span><br></pre></td></tr></table></figure>
<p>唯一约束(unique)：约束的字段不能重复，可以为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line">    id int,</span><br><span class="line">    username varchar(255) unique # 列级约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table t_user(</span><br><span class="line">    id int, </span><br><span class="line">    usercode varchar(255),</span><br><span class="line">    username varchar(255),</span><br><span class="line">    unique(usercode,username) # 多个字段联合起来添加1个约束unique 【表级约束】</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="主键约束-primary-key"><a href="#主键约束-primary-key" class="headerlink" title="主键约束(primary key)"></a>主键约束(primary key)</h3><p>主键值是这行记录在这张表当中的唯一标识。约束的字段<strong>既不能为NULL，也不能重复</strong>（简称PK）。一张表的主键约束只能有1个。第一范式要求任何一张表都应该有主键。</p>
<p><strong>主键的分类</strong></p>
<p>根据主键字段的字段数量来划分：<br>            单一主键（推荐的，常用的。）<br>            复合主键（多个字段联合起来添加一个主键约束）（复合主键不建议使用，因为违背三范式。）</p>
<p>根据主键性质来划分：<br>            自然主键：<strong>主键值最好就是一个和业务没有任何关系的自然数。</strong>（这种方式是推荐的）<br>            业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用）最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 建表时添加主键约束</span><br><span class="line">create table t_user(</span><br><span class="line">    id int primary key,</span><br><span class="line">    username varchar(255),</span><br><span class="line">    email varchar(255)</span><br><span class="line">);</span><br><span class="line">		</span><br><span class="line">#mysql提供主键值自增</span><br><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">    id int primary key auto_increment, # id字段自动维护一个自增的数字，从1开始，以1递增。</span><br><span class="line">    username varchar(255)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="外键约束-foreign-key"><a href="#外键约束-foreign-key" class="headerlink" title="外键约束(foreign key)"></a>外键约束(foreign key)</h3><p>（简称FK）外键值可以为NULL。外键字段引用其他表的某个字段的时候，被引用的字段不一定是主键，但至少具有unique约束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_class(</span><br><span class="line">    cno int,</span><br><span class="line">    cname varchar(255),</span><br><span class="line">    primary key(cno)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table t_student(</span><br><span class="line">    sno int,</span><br><span class="line">    sname varchar(255),</span><br><span class="line">    classno int,</span><br><span class="line">    primary key(sno),</span><br><span class="line">    foreign key(classno) references t_class(cno)</span><br><span class="line">);</span><br><span class="line"># t_student中的classno字段引用t_class表中的cno字段，此时t_class表叫做父表。t_student表叫做子表。</span><br></pre></td></tr></table></figure>
<h2 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h2><p>一个事务是一个完整的业务逻辑单元，不可再分。事务的存在是为了保证数据的完整性，安全性。和事务相关的语句只有：DML语句。（insert delete update）</p>
<blockquote>
<p>比如：银行账户转账，从A账户向B账户转账10000.需要执行两条update语句：<br>        update t_act set balance = balance - 10000 where actno = ‘act-001’;<br>        update t_act set balance = balance + 10000 where actno = ‘act-002’;<br>以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。<br>要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。</p>
</blockquote>
<h3 id="事务包括四大特性：ACID"><a href="#事务包括四大特性：ACID" class="headerlink" title="事务包括四大特性：ACID"></a>事务包括四大特性：ACID</h3><blockquote>
<p>A: 原子性：事务是最小的工作单元，不可再分。<br>C: 一致性：事务必须保证多条DML语句同时成功或者同时失败。<br>I：隔离性：事务A与事务B之间具有隔离。<br>D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。</p>
</blockquote>
<h3 id="事务隔离性存在隔离级别"><a href="#事务隔离性存在隔离级别" class="headerlink" title="事务隔离性存在隔离级别"></a>事务隔离性存在隔离级别</h3><p>理论上隔离级别包括4个</p>
<ul>
<li><p>第一级别：读未提交（read uncommitted）对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。<br>读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。</p>
</li>
<li><p>第二级别：读已提交（read committed）对方事务提交之后的数据我方可以读取到。<br>解决了: 脏读。<br>存在的问题是：不可重复读。</p>
</li>
<li><p>第三级别：可重复读（repeatable read）<br>解决了：不可重复读。<br>存在的问题是：幻读，读取到的数据是幻象。</p>
</li>
<li><p>第四级别：序列化读/串行化读（serializable）<br>解决了所有问题。效率低。需要事务排队。</p>
</li>
</ul>
<blockquote>
<p>oracle 数据库默认的隔离级别是：读已提交。<br>MySQL 数据库默认的隔离级别是：可重复读。</p>
</blockquote>
<p>MySQL 事务默认情况下是自动提交，只要执行任意一条DML语句则提交一次。<br>关闭自动提交：<code>start transaction;</code>提交语句：<code>commit;</code>回滚：<code>rollback;</code></p>
<h3 id="隔离性如何实现-MVCC-多版本并发控制-和锁"><a href="#隔离性如何实现-MVCC-多版本并发控制-和锁" class="headerlink" title="隔离性如何实现:  MVCC(多版本并发控制)和锁"></a>隔离性如何实现:  MVCC(多版本并发控制)和锁</h3><p>提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。</p>
<h4 id="MVCC-multiple-version-concurrent-control"><a href="#MVCC-multiple-version-concurrent-control" class="headerlink" title="MVCC(multiple version concurrent control)"></a>MVCC(multiple version concurrent control)</h4><p>一种控制并发的方法，主要用来提高数据库的并发性能。在了解MVCC时应该先了解当前读和快照读：</p>
<blockquote>
<p>当前读：读取的是数据库的最新版本，并且在读取时要保证其他事务不会修改当前记录，所以会对读取的记录加锁。<br>快照读：不加锁读取操作即为快照读，使用MVCC来读取快照中的数据，避免加锁带来的性能损耗。</p>
</blockquote>
<p>MVCC的作用就是在避免加锁的情况下最大限度解决读写并发冲突的问题，它可以实现提交读和可重复度两个隔离级。不能解决丢失修改问题。<br>实现原理：</p>
<ul>
<li>版本号<ul>
<li>系统版本号：一个自增的ID，每开启一个事务，系统版本号都会递增</li>
<li>事务版本号：事务版本号就是事务开始时的系统版本号，可以通过事务版本号的大小判断事务的时间顺序。</li>
</ul>
</li>
<li>undo日志<ul>
<li>MVCC使用到的快照会存储在Undo日志中，该日志通过回滚指针将一个一个数据行的所有快照连接起来。</li>
</ul>
</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul>
<li><p>表级锁、行级锁与页面锁</p>
<blockquote>
<p>按照锁的粒度可以将MySQL锁分为三种：<br><img src="https://notes.sjtu.edu.cn/uploads/upload_706e769f8dbc49a66417d8e29879ebba.png" alt=""><br>MyISAM默认采用表级锁，InnoDB默认采用行级锁。</p>
</blockquote>
</li>
<li><p>共享锁和排他锁</p>
<blockquote>
<p>共享锁：共享锁又称读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X锁。<br>排他锁：排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁。</p>
</blockquote>
</li>
<li><p>乐观锁和悲观锁（逻辑上的锁）</p>
<blockquote>
<p>乐观锁：对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。<br>悲观锁：对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。</p>
</blockquote>
</li>
<li><p>死锁</p>
<blockquote>
<p>如何解决数据库死锁<br>预先检测到死锁的循环依赖，并立即返回一个错误。<br>当查询的时间达到锁等待超时的设定后放弃锁请求。</p>
</blockquote>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是数据库当中的对象，使用索引可以快速访问数据表中的特定信息。</p>
<blockquote>
<p>优点：大大加快数据检索的速度，将随机I/O变成顺序I/O(因为B+树的叶子节点是连接在一起的) 加速表与表之间的连接<br>缺点：从空间角度考虑，建立索引需要占用物理空间；从时间角度考虑，创建和维护索引都需要花费时间，例如对数据进行增删改的时候都需要维护索引，有维护成本。</p>
</blockquote>
<p>添加索引是给某一个字段，或者说某些字段添加索引。<br>创建索引对象：<code>create index 索引名称 on 表名(字段名);</code><br>删除索引对象：<code>drop index 索引名称 on 表名;</code></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>对于中大型表建立索引非常有效，对于非常小的表，一般全部表扫描速度更快些。</li>
<li>对于超大型的表，建立和维护索引的代价也会变高，这时可以考虑分区技术。</li>
</ul>
<h3 id="设计原则（添加索引需满足什么条件）"><a href="#设计原则（添加索引需满足什么条件）" class="headerlink" title="设计原则（添加索引需满足什么条件）"></a>设计原则（添加索引需满足什么条件）</h3><ul>
<li>数据量庞大</li>
<li>该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）</li>
<li>该字段经常出现在where子句中。（经常根据哪个字段查询）</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>主要有B+树和哈希表。<br>InnoDB引擎的索引类型有B+树索引和哈希索引，默认为B+树索引。</p>
<ul>
<li>B+ Tree。详情：<a href="https://aoif-hikari.github.io/2021/11/25/多路查找树/">数据结构 / 多路查找树 | 心臓から花が咲くように (aoif-hikari.github.io)</a></li>
<li>哈希索引，基于哈希表实现。对于每一行数据，存储引擎会对索引列通过哈希算法进行hash得到hash code，作为哦哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是o(1)。详情：<a href="https://aoif-hikari.github.io/2021/11/25/hash/">数据结构/Hash | 心臓から花が咲くように (aoif-hikari.github.io)</a><ul>
<li>多用于精确查找</li>
<li>不支持排序，因为哈希表是无序的。</li>
<li>不支持范围查找。</li>
<li>不支持模糊查询及多列索引的最左前缀匹配。</li>
<li>性能是不稳定，因为哈希表中存在哈希冲突。B+树索引的性能是相对稳定 的，每次查询都是从根节点到叶子节点。</li>
</ul>
</li>
</ul>
<h3 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h3><blockquote>
<p>主键索引：数据列不允许重复，不能为NULL，一个表只能有一个主键索引<br>组合索引：由多个列值组成的索引。<br>唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。<br>全文索引：对文本的内容进行搜索。<br>普通索引：基本的索引类型，可以为NULL</p>
</blockquote>
<p>主键和具有unique约束的字段自动会添加索引。根据主键查询效率较高。尽量根据主键检索。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模糊查询的时候，第一个通配符使用的是%，此时索引是失效的。</span><br><span class="line">select ename from emp where ename like &#x27;%A%&#x27;; # 索引失效的情况</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>聚簇索引与非聚簇索引</p>
</blockquote>
<p>最主要的区别是数据和索引是否分开存储。</p>
<ul>
<li>聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。</li>
<li>非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。</li>
</ul>
<p>在InnoDB存储引擎中，默认的索引为B+树索引，利用主键创建的索引为主索引，也是聚簇索引，在主索引之上创建的索引为辅助索引，也是非聚簇索引。为什么说辅助索引是在主索引之上创建的呢，因为辅助索引中的叶子节点存储的是主键。</p>
<p>在MyISAM存储引擎中，默认的索引也是B+树索引，但主索引和辅助索引都是非聚簇索引，也就是说索引结构的叶子节点存储的都是一个指向数据行的地址。并且使用辅助索引检索无需访问主键的索引。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>建表的时候可以指定存储引擎，也可以指定字符集。mysql默认使用的存储引擎是InnoDB，默认采用的字符集是UTF8。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_x(</span><br><span class="line">    id int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8; # 完整的建表语句</span><br></pre></td></tr></table></figure>
<ul>
<li><p>MyISAM<br>MySQL5.1及之前，MyISAM 是默认存储引擎。MyISAM不支持事务，Myisam支持表级锁，不支持行级锁，表不支持外键，该存储引擎存有表的行数，count运算会更快。适合查询频繁，不适合对于增删改要求高的情况</p>
</li>
<li><p>InnoDB<br>InnoDB 是 MySQL 的默认事务型引擎，支持事务，表是基于聚簇索引建立的。支持表级锁和行级锁，支持外键，适合数据增删改查都频繁的情况。InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 REPEATABLE READ，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。</p>
</li>
</ul>
<h2 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h2><ul>
<li>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。</li>
<li>第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。</li>
<li>第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</li>
</ul>
<p>在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。</p>
<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>窗口函数 over (partition by 用于分列的列名 order by 用于排序的列名）；<br>原则上一般写在<strong>select子句</strong>中。</p>
<p><code>over</code>用来指定函数执行的窗口范围，若后面括号中什么都不写，则意味着窗口包含满足WHERE条件的所有行，窗口函数基于所有行进行计算。如果不为空，则支持以下4中语法来设置窗口。</p>
<p>①window_name：给窗口指定一个别名。如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读；<br>②PARTITION BY 子句：窗口按照哪些字段进行分组，窗口函数在不同的分组上分别执行；<br>③ORDER BY子句：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号；<br>④FRAME子句：FRAME是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用。</p>
<ul>
<li>解决排名问题，e.g.每个班级按成绩排名<br>序号函数：<br><code>ROW_NUMBER()</code>：顺序排序——1、2、3<br><code>RANK()</code>：并列排序，跳过重复序号——1、1、3<br><code>DENSE_RANK()</code>：并列排序，不跳过重复序号——1、1、2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT stu_id,</span><br><span class="line">       ROW_NUMBER() OVER (PARTITION BY stu_id ORDER BY score DESC) AS score_order,       </span><br><span class="line">FROM ...</span><br><span class="line"></span><br><span class="line"># 为窗口设置别名</span><br><span class="line">SELECT ROW_NUMBER() OVER w AS rk,</span><br><span class="line">       stu_id, lesson_id, score</span><br><span class="line">FROM ...</span><br><span class="line">WHERE ...</span><br><span class="line">WINDOW w AS (PARTITION BY stu_id ORDER BY score)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>解决TOP N问题，e.g.每个班级前两名的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询每个学生成绩最高的两个科目</span><br><span class="line">SELECT *</span><br><span class="line">FROM </span><br><span class="line">	(SELECT*,row_number() over (PARTITION BY 姓名 ORDER BY 成绩 DESC) AS ranking </span><br><span class="line">     FROM test1) </span><br><span class="line">     AS newtest</span><br><span class="line">WHERE ranking&lt;=2;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>聚合函数作为窗口函数</strong><br><strong>作用</strong>：聚合函数作为窗口函数，是起到”<strong>累加/累计</strong>“的效果，比如，就是截止到本行，最大值？最小值是多少<br><strong>与专用窗口函数的区别</strong>：括号中需要有指定列，不能为空</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java / Servlet规范</title>
    <url>/2021/07/19/servlet/</url>
    <content><![CDATA[<blockquote>
<p>Servlet规范，来自于JAVAEE规范中的一种。</p>
</blockquote>
<span id="more"></span>
<p>Servlet规范指定【动态资源文件】开发步骤；Http服务器调用动态资源文件规则；Http服务器管理动态资源文件实例对象规则。<br>Tomcat服务器下lib文件中<code>servlet-api.jar</code>存放Servlet接口（javax.servlet.Servlet接口）<br>Servlet规范任务中，Http服务器能调用的【动态资源文件】必须是一个<strong>Servlet接口实现类</strong></p>
<h2 id="Servlet规范开发步骤"><a href="#Servlet规范开发步骤" class="headerlink" title="Servlet规范开发步骤"></a>Servlet规范开发步骤</h2><ul>
<li>创建一个Java类继承HttpServlet父类，使之成为一个Servlet接口实现类</li>
<li>重写两个方法，doGet或则doPost</li>
<li>将Servlet接口实现类信息【注册】到Tomcat服务器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /web/WEB-INF/web.xml文件中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将Servlet接口实现类类路径地址交给Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span><span class="comment">&lt;!--声明servlet接口实现类类路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    Tomcat  String mm = &quot;com.bjpowernode.controller.OneServlet&quot;</span><br><span class="line">    <span class="comment">&lt;!--为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/one<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--设置简短请求别名,别名在书写时必须以&quot;/&quot;为开头--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期"></a>Servlet对象生命周期</h2><ul>
<li>网站中所有的Servlet接口实现类的实例对象，只能由Http服务器(如Tomcat，相当于servlet的容器)负责额创建。 开发人员不能手动创建。</li>
<li>在默认的情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时，自动创建这个Servlet接口实现类的实例对象；在手动配置情况下，要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--手动配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>30<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span><span class="comment">&lt;!--填写一个大于0的整数即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在Http服务器运行期间，一个Servlet接口实现类只能被创建出一个实例对象</li>
<li>在Http服务器关闭时刻，自动将网站中所有的Servlet对象进行销毁</li>
</ul>
<h2 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h2><p>来自于Servlet规范，在Tomcat中存在servlet-api.jar，实现类由Http服务器负责提供。负责将doGet/doPost方法<strong>执行结果</strong>写入到【响应体】交给浏览器。惯于将HttpServletResponse接口修饰的对象称为【<strong>响应对象</strong>】<br>主要功能:</p>
<ul>
<li>执行结果以二进制形式写入到【响应体】</li>
<li>设置响应头中[content-type]属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">         String result=<span class="string">&quot;Java&lt;br/&gt;Mysql&lt;br/&gt;HTML&lt;br/&gt;&quot;</span>; <span class="comment">//既有文字信息又有HTML标签命令</span></span><br><span class="line">        <span class="comment">//设置响应头content-type</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//向Tomcat索要输出流</span></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">//通过输出流将结果写入到响应体</span></span><br><span class="line">        out.print(result);</span><br><span class="line">    &#125;<span class="comment">//doGet执行完毕，Tomcat将响应包推送给浏览器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置响应头中【location】属性，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String result =<span class="string">&quot;http://www.baidu.com?userName=mike&quot;</span>;</span><br><span class="line">    <span class="comment">//通过响应对象，将地址赋值给响应头中location属性</span></span><br><span class="line">    response.sendRedirect(result);<span class="comment">//[响应头  location=&quot;http://www.baidu.com&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//浏览器在接收到响应包之后，如果发现响应头中存在location属性，自动通过地址栏向location指定网站发送请求。sendRedirect方法远程控制浏览器请求行为【请求地址，请求方式，请求参数】</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h2><p>来自于Servlet规范中，在Tomcat中存在servlet-api.jar，接口实现类由Http服务器负责提供。负责在doGet/doPost方法运行时读取Http请求协议包中信息，修饰的对象称为【请求对象】<br>作用:</p>
<ul>
<li>读取Http请求协议包中【请求行】信息</li>
<li>读取保存在Http请求协议包中【请求头】或则【请求体】中请求参数信息</li>
<li>代替浏览器向Http服务器申请资源文件调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象，读取【请求行】中【url】信息</span></span><br><span class="line">         String url = request.getRequestURL().toString();</span><br><span class="line">        <span class="comment">//2.通过请求对象，读取【请求行】中【method】信息</span></span><br><span class="line">         String method = request.getMethod();</span><br><span class="line">        <span class="comment">//3.通过请求对象，读取【请求行】中uri信息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * URI：资源文件精准定位地址，在请求行并没有URI这个属性。</span></span><br><span class="line"><span class="comment">        *      实际上URL中截取一个字符串，这个字符串格式&quot;/网站名/资源文件名&quot;</span></span><br><span class="line"><span class="comment">        *      URI用于让Http服务器对被访问的资源文件进行定位</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String uri =  request.getRequestURI();<span class="comment">// substring</span></span><br><span class="line">        System.out.println(<span class="string">&quot;URL &quot;</span>+url);</span><br><span class="line">        System.out.println(<span class="string">&quot;method &quot;</span>+method);</span><br><span class="line">        System.out.println(<span class="string">&quot;URI &quot;</span>+uri);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.通过请求对象获得【请求头】中【所有请求参数名】</span></span><br><span class="line">        Enumeration paramNames =request.getParameterNames(); </span><br><span class="line">        <span class="comment">//将所有请求参数名称保存到一个枚举对象进行返回</span></span><br><span class="line">        <span class="keyword">while</span>(paramNames.hasMoreElements())&#123;</span><br><span class="line">            String paramName = (String)paramNames.nextElement();</span><br><span class="line">            <span class="comment">//2.通过请求对象读取指定的请求参数的值</span></span><br><span class="line">            String value = request.getParameter(paramName);</span><br><span class="line">            System.out.println(<span class="string">&quot;请求参数名 &quot;</span>+paramName+<span class="string">&quot; 请求参数值 &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        浏览器以GET方式发送请求,请求参数保存在【请求头】,在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求头二进制内容由Tomcat负责解码，Tomcat9.0默认使用【utf-8】字符集，可以解释一切国家文字</span></span><br><span class="line"><span class="comment">	浏览器以POST方式发送请求，请求参数保存在【请求体】,在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求体二进制内容由当前请求对象（request）负责解码。request默认使用[ISO-8859-1]字符集，一个东欧语系字符集，此时如果请求体参数内容是中文，将无法解码只能得到乱码</span></span><br><span class="line"><span class="comment">	解决方案:在Post请求方式下，在读取请求体内容之前，应该通知请求对象使用utf-8字符集对请求体内容进行一次重新解码*/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通知请求对象，使用utf-8字符集对请求体二进制内容进行一次重写解码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//通过请求对象，读取【请求体】参数信息</span></span><br><span class="line">        String value = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;从请求体得到参数值 &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请求对象和响应对象生命周期<br>在Http服务器接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】<br>-在Http服务器调用doGet/doPost方法时，负责将【请求对象】和【响应对象】作为实参传递到方法，确保doGet/doPost正确执行<br>-在Http服务器准备推送Http响应协议包之前，负责将本次请求关联的【请求对象】和【响应对象】销毁<br>【请求对象】和【响应对象】生命周期贯穿一次请求的处理过程中</p>
</blockquote>
<h2 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h2><p>由三位数字组成的一个符号。Http服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中【状态行】上。<br>如果Http服务器针对本次请求，返回了对应的资源文件，通过Http状态码通知浏览器应该如何处理这个结果<br>如果Http服务器针对本次请求，无法返回对应的资源文件，通过Http状态码向浏览器解释不能提供服务的原因</p>
<p>分类：<br>100—-599组成；分为5个大类<br>100; 通知浏览器本次返回的资源文件并不是一个独立的资源文件，需要浏览器在接收响应包之后，继续向Http服务器所要依赖的其他资源文件<br>200，通知浏览器本次返回的资源文件是一个完整独立资源文件，浏览器在接收到之后不需要所要其他关联文件<br>302，通知浏览器本次返回的不是一个资源文件内容而是一个资源文件地址，需要浏览器根据这个地址自动发起请求来索要这个资源文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;资源文件地址&quot;</span>) <span class="comment">//写入到响应头中location</span></span><br><span class="line"><span class="comment">//而这个行为导致Tomcat将302状态码写入到状态行</span></span><br></pre></td></tr></table></figure>
<p>404: 通知浏览器，由于在服务端没有定位到被访问的资源文件 因此无法提供帮助<br>405：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet），但是这个Servlet对于浏览器采用的请求方式不能处理<br>500:通知浏览器，在服务端已经定位到被访问的资源文件（Servlet）这个Servlet可以接收浏览器采用请求方式，但是Servlet在处理请求期间，由于Java异常导致处理失败</p>
<h2 id="多个Servlet之间调用规则"><a href="#多个Servlet之间调用规则" class="headerlink" title="多个Servlet之间调用规则"></a>多个Servlet之间调用规则</h2><p>多个Servlet:</p>
<ul>
<li>前提条件：某些来自于浏览器发送请求，往往需要服务端中多个Servlet协同处理。但是浏览器一次只能访问一个Servlet，导致用户需要手动通过浏览器发起多次请求才能得到服务。这样增加用户获得服务难度，导致用户放弃访问当前网站</li>
<li>提高用户使用感受规则：无论本次请求涉及到多少个Servlet,用户只需要【手动】通知浏览器发起一次请求即可</li>
</ul>
<h3 id="重定向解决方案"><a href="#重定向解决方案" class="headerlink" title="重定向解决方案"></a>重定向解决方案</h3><p>用户第一次通过【手动方式】通知浏览器访问OneServlet。OneServlet工作完毕后，将TwoServlet地址写入到响应头location属性中，导致Tomcat将302状态码写入到状态行。浏览器接收到响应包之后，读取到302状态。此时浏览器自动根据响应头中location属性地址【自动】发起第二次请求，访问TwoServlet去完成请求中剩余任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;请求地址&quot;</span>) <span class="comment">//将地址写入到响应包中响应头中location属性</span></span><br></pre></td></tr></table></figure>
<ul>
<li>请求地址：既可以把当前网站内部的资源文件地址发送给浏览器 （/网站名/资源文件名）也可以把其他网站资源文件地址发送给浏览器(<a href="http://ip地址:端口号/网站名/资源文件名">http://ip地址:端口号/网站名/资源文件名</a>)</li>
<li>请求次数：浏览器至少发送两次请求，只有第一次请求是用户手动发送。后续请求都是浏览器自动发送的。</li>
<li>请求方式：通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】</li>
<li>缺点:重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间</li>
</ul>
<h3 id="请求转发解决方案"><a href="#请求转发解决方案" class="headerlink" title="请求转发解决方案"></a>请求转发解决方案</h3><p> 用户第一次通过手动方式要求浏览器访问OneServlet。OneServlet工作完毕后，通过当前的请求对象代替浏览器向Tomcat发送请求，申请调用TwoServlet。Tomcat接收到这个请求之后，自动调用TwoServlet完成剩余任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求对象代替浏览器向Tomcat发送请求</span></span><br><span class="line"><span class="comment">//1.通过当前请求对象生成资源文件申请报告对象</span></span><br><span class="line">RequestDispatcher  report = request.getRequestDispatcher(<span class="string">&quot;/资源文件名&quot;</span>); <span class="comment">//一定要以&quot;/&quot;为开头</span></span><br><span class="line"><span class="comment">//2.将报告对象发送给Tomcat</span></span><br><span class="line">report.forward(request, response)</span><br></pre></td></tr></table></figure>
<ul>
<li>无论本次请求涉及到多少个Servlet,用户只需要手动通过浏览器发送一次请求</li>
<li>Servlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数增加处理服务速度</li>
</ul>
<p>请求次数：在请求转发过程中，浏览器只发送一次请求<br>请求地址：只能向Tomcat服务器申请调用当前网站下资源文件地址<br>请求方式：在请求转发过程中，浏览器只发送一个了个Http请求协议包。参与本次请求的所有Servlet共享同一个请求协议包，因此这些Servlet接收的请求方式与浏览器发送的请求方式保持一致</p>
<h2 id="多个Servlet之间数据共享实现方案"><a href="#多个Servlet之间数据共享实现方案" class="headerlink" title="多个Servlet之间数据共享实现方案"></a>多个Servlet之间数据共享实现方案</h2><p>数据共享：OneServlet工作完毕后，将产生数据交给TwoServlet来使用<br>Servlet规范中提供四种数据共享方案</p>
<h3 id="ServletContext接口"><a href="#ServletContext接口" class="headerlink" title="ServletContext接口"></a>ServletContext接口</h3><p>来自于Servlet规范中一个接口。在Tomcat中存在servlet-api.jar，在Tomcat中负责提供这个接口实现类。<br>如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享。<br>习惯于将ServletContext对象称为【全局作用域对象】。</p>
<blockquote>
<p>每一个网站都存在一个全局作用域对象。 这个全局作用域对象【相当于】一个Map.在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中其他Servlet此时都可以从全局作用域对象得到这个数据进行使用。<br>生命周期：全局作用域对象生命周期贯穿网站整个运行期间</p>
</blockquote>
<p>在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象<br>在Http服务器运行期间时，一个网站只有一个全局作用域对象，全局作用域对象一直处于存活状态<br>在Http服务器准备关闭时，负责将当前网站中全局作用域对象 进行销毁处理          </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令实现： 【同一个网站】OneServlet将数据共享给TwoServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象向Tomcat索要当前网站全局作用域对象</span></span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="comment">//2.将数据添加到全局作用域对象，作为共享数据</span></span><br><span class="line">        application.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="number">100</span>);<span class="comment">// map: key-value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象向Tomcat索要当前网站全局作用域对象</span></span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="comment">//2.从全局作用域对象得到指定关键字对应的值</span></span><br><span class="line">        Integer money=(Integer)application.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cookie类"><a href="#Cookie类" class="headerlink" title="Cookie类"></a>Cookie类</h3><p>来自于Servlet规范中一个工具类，存在于Tomcat提供servlet-api.jar中。如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于Cookie对象进行数据共享</p>
<p>Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量。在现实生活场景中，Cookie相当于用户在服务端得到【会员卡】</p>
<p>原理: 用户通过浏览器第一次向MyWeb网站发送请求申请OneServlet。OneServlet在运行期间创建一个Cookie存储与当前用户相关数据。OneServlet工作完毕后，【<strong>将Cookie写入到响应头</strong>】交还给当前浏览器。浏览器收到响应响应包之后，将cookie存储在浏览器的缓存一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时。【<strong>浏览器需要无条件的将myWeb网站之前推送过来的Cookie，写入到请求头</strong>】发送过去。此时TwoServlet在运行时，可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现命令:  同一个网站 OneServlet 与  TwoServlet 借助于Cookie实现数据共享</span></span><br><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个cookie对象，保存共享数据（当前用户数据）</span></span><br><span class="line">        Cookie card = <span class="keyword">new</span> Cookie(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;abc&quot;</span>);<span class="comment">// Cookie(String name,String value)</span></span><br><span class="line">        Cookie card1= <span class="keyword">new</span> Cookie(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">		<span class="comment">//cookie相当于一个map,一个cookie中只能存放一个键值对</span></span><br><span class="line">        <span class="comment">//这个键值对的key与value只能是String,键值对中key不能是中文</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.【发卡】将cookie写入到响应头，交给浏览器</span></span><br><span class="line">        resp.addCookie(card);</span><br><span class="line">        resp.addCookie(card1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TwoServlet&#123;			 </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象从请求头得到浏览器返回的Cookie</span></span><br><span class="line">        Cookie  cookieArray[] = request.getCookies();</span><br><span class="line">        <span class="comment">//2.循环遍历数据得到每一个cookie的key 与 value</span></span><br><span class="line">        <span class="keyword">for</span>(Cookie card:cookieArray)&#123;</span><br><span class="line">            String key =   card.getName(); <span class="comment">//读取key  &quot;key1&quot;</span></span><br><span class="line">            String value = card.getValue();<span class="comment">//读取value &quot;abc&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Cookie销毁时机</p>
</blockquote>
<p>在默认情况下，Cookie对象存放在浏览器的缓存中。只要浏览器关闭，Cookie对象就被销毁</p>
<p>在手动设置情况下，可以要求浏览器将接收的Cookie 存放在客户端计算机上硬盘上，同时需要指定Cookie在硬盘上存活时间。在存活时间范围内，关闭浏览器关闭客户端计算机，关闭服务器，都不会导致Cookie被销毁。在存活时间到达时，Cookie自动从硬盘上被删除</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cookie</span>.setMaxAge(<span class="number">60</span>); //cookie在硬盘上存活<span class="number">1</span>分钟</span><br></pre></td></tr></table></figure>
<p>Cookie域保存在自己浏览器内部，与别人互不干扰，但因为是客户端技术，所以安全性不高。</p>
<h3 id="HttpSession接口"><a href="#HttpSession接口" class="headerlink" title="HttpSession接口"></a>HttpSession接口</h3><p>来自于Servlet规范下一个接口。存在于Tomcat中servlet-api.jar，其实现类由Http服务器提供。Tomcat提供实现类存在于servlet-api.jar。如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于HttpSession对象进行数据共享。习惯于将HttpSession接口修饰对象称为【会话作用域对象】</p>
<blockquote>
<p>HttpSession 与  Cookie 区别：<br>存储位置:Cookie：存放在客户端计算机（浏览器内存/硬盘）。HttpSession：存放在服务端计算机内存<br>数据类型：Cookie对象存储共享数据类型只能是String。HttpSession对象可以存储任意类型的共享数据Object<br>数据数量: 一个Cookie对象只能存储一个共享数据。HttpSession使用map集合，可以存储任意数量共享数据<br>参照物：Cookie相当于客户在服务端【会员卡】。HttpSession相当于客户在服务端【私人保险柜】</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令实现:   同一个网站（myWeb）下OneServlet将数据传递给TwoServlet</span></span><br><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//2.将数据添加到用户私人储物柜</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;key1&quot;</span>,共享数据)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浏览器访问/myWeb中TwoServlet</span></span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//2.从会话作用域对象得到OneServlet提供的共享数据</span></span><br><span class="line">        Object 共享数据 = session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Http服务器如何将用户与HttpSession关联：cookie</p>
<blockquote>
<p>getSession()  与  getSession(false)<br>getSession(): 如果当前用户在服务端已经拥有了自己的私人储物。要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。要求tocmat为当前用户创建一个全新的私人储物柜<br>getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜.要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。此时Tomcat将返回null</p>
</blockquote>
<p>HttpSession销毁时机:</p>
<p>用户与HttpSession关联时使用的Cookie只能存放在浏览器缓存中，在浏览器关闭时，意味着用户与他的HttpSession关系被切断。由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会让Tomcat将浏览器关联的HttpSession进行销毁。为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】，空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟，此时Tomcat认为用户已经放弃了自己的HttpSession，Tomcat就会销毁这个HttpSession</p>
<h3 id="HttpServletRequest接口-1"><a href="#HttpServletRequest接口-1" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h3><p>在同一个网站中，如果两个Servlet之间通过【请求转发】方式进行调用，彼此之间共享同一个请求协议包。而一个请求协议包只对应一个请求对象。因此servlet之间共享同一个请求对象，此时可以利用这个<strong>请求对象</strong>在两个Servlet之间实现数据共享。</p>
<p>将请求对象称为【请求作用域对象】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OneServlet通过请求转发申请调用TwoServlet时，需要给TwoServlet提供共享数据</span></span><br><span class="line">OneServlet&#123;				 </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.将数据添加到【请求作用域对象】中attribute属性</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;key1&quot;</span>,数据); <span class="comment">//数据类型可以任意类型Object</span></span><br><span class="line">        <span class="comment">//2.向Tomcat申请调用TwoServlet</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/two&quot;</span>).forward(req,response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从当前请求对象得到OneServlet写入到共享数据</span></span><br><span class="line">        Object 数据 = req.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;				 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监听器接口"><a href="#监听器接口" class="headerlink" title="监听器接口"></a>监听器接口</h2><p>一组来自于Servlet规范下接口，共有8个接口。在Tomcat存在servlet-api.jar包。监听器接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类。监听器接口用于监控【<strong>作用域对象</strong>生命周期变化时刻】以及【作用域对象共享数据变化时刻】</p>
<blockquote>
<p>作用域对象：在Servlet规范中，认为在<strong>服务端内存</strong>中可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】<br>Servlet规范下作用域对象:</p>
<ul>
<li>ServletContext：全局作用域对象</li>
<li>HttpSession:  会话作用域对象</li>
<li>HttpServletRequest: 请求作用域对象<br>(cookie存放在客户端，故不属于作用域对象)</li>
</ul>
</blockquote>
<p>监听器接口实现类开发规范：根据监听的实际情况，选择对应监听器接口进行实现；重写监听器接口声明【监听事件处理方法】；在web.xml文件将监听器接口实现类注册到Http服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将监听器接口实现类注册到Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.bjpoewrnode.listener.OneListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ServletContextListener接口</li>
</ul>
<p>合法的检测全局作用域对象被初始化时刻以及被销毁时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitlized</span><span class="params">(ServletContextEvent sce)</span><span class="comment">//在全局作用域对象被Http服务器初始化被调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestory</span><span class="params">(ServletContextEvent sce)</span><span class="comment">//在全局作用域对象被Http服务器销毁时触发调用</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>ServletContextAttributeListener接口</li>
</ul>
<p>合法的检测全局作用域对象共享数据变化时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextAdd</span><span class="params">()</span> <span class="comment">//在全局作用域对象添加共享数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextReplaced</span><span class="params">()</span> <span class="comment">//在全局作用域对象更新共享数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextRemove</span><span class="params">()</span> <span class="comment">//在全局作用域对象删除共享数据</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局作用域对象共享数据变化时刻</span></span><br><span class="line">ServletContext application = request.getServletContext();</span><br><span class="line">application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="number">100</span>); <span class="comment">//新增共享数据</span></span><br><span class="line">application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="number">200</span>); <span class="comment">//更新共享数据</span></span><br><span class="line">application.removeAttribute(<span class="string">&quot;key1&quot;</span>);  <span class="comment">//删除共享数据</span></span><br></pre></td></tr></table></figure>
<h2 id="过滤器接口"><a href="#过滤器接口" class="headerlink" title="过滤器接口"></a>过滤器接口</h2><p>来自于Servlet规范下接口，在Tomcat中存在于servlet-api.jar包。Filter接口实现类由开发人员负责提供，Http服务器不负责提供。Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截。</p>
<blockquote>
<p>拦截Http服务器，帮助Http服务器检测当前请求合法性；对当前请求进行增强操作</p>
</blockquote>
<p>Filter接口实现类开发步骤：创建一个Java类实现Filter接口；重写Filter接口中doFilter方法；web.xml将过滤器接口实现类注册到Http服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//合法请求</span></span><br><span class="line">        <span class="comment">//将拦截请求对象和响应对象交还给Tomcat,由Tomcat继续调用资源文件</span></span><br><span class="line">        <span class="keyword">if</span>(...)&#123; </span><br><span class="line">        <span class="comment">//增强功能，通知拦截的请求对象，使用UTF-8字符集对当前请求体信息进行一次重新编辑(POST())</span></span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);<span class="comment">//FilterChain的doFilter方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则过滤器代替Http服务器拒绝本次请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--将过滤器类文件路径交给Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>oneFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.bjpowernode.filter.OneFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通知Tomcat在调用何种资源文件时需要被当前过滤器拦截--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>oneFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>拦截地址<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用某一个具体文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/mm.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用某一个文件夹下所有的资源文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用任意文件夹下某种类型文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用网站中任意文件时，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用过滤器避免恶意登录（避开登陆界面直接通过地址栏访问网站内资源文件）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用Dao将查询验证信息推送到数据库服务器上</span></span><br><span class="line">        result = dao.login(userName, password);</span><br><span class="line">        <span class="keyword">if</span>(result ==<span class="number">1</span>)&#123;<span class="comment">//用户存在</span></span><br><span class="line">            <span class="comment">//在判定来访用户身份合法后，通过请求对象向Tomcat申请为当前用户申请一个HttpSession令牌</span></span><br><span class="line">            HttpSession session = request.getSession();</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myWeb/index.html&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myWeb/login_error.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)servletRequest;</span><br><span class="line">        <span class="comment">// 与login相关的不过滤</span></span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        <span class="keyword">if</span>(uri.indexOf(<span class="string">&quot;login&quot;</span>) != -<span class="number">1</span> || <span class="string">&quot;/myWeb/&quot;</span>.equals(uri))&#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.拦截后，通过请求对象向Tomcat索要当前用户的HttpSession。</span></span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜.要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。此时Tomcat将返回null</span></span><br><span class="line">        <span class="comment">//2.判断来访用户身份合法性</span></span><br><span class="line">        <span class="keyword">if</span>(session == <span class="keyword">null</span>)&#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/login_error.html&quot;</span>)</span><br><span class="line">                .forward(servletRequest, servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--通知Tomcat在调用任意文件之前都要调用当前过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode / 二叉树</title>
    <url>/2021/07/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>二叉树与递归有着千丝万缕的联系，二叉树在定义时就使用了递归的概念：一棵二叉树可能是空树，如果不是空树，那么它的左右子树都是二叉树。</p>
</blockquote>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span></span>&#123;</span><br><span class="line">    Object element;</span><br><span class="line">    BinaryNode left;</span><br><span class="line">    BinaryNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基础：二叉树的遍历"><a href="#基础：二叉树的遍历" class="headerlink" title="基础：二叉树的遍历"></a>基础：二叉树的遍历</h2><p>遍历时均无返回值，所以遍历要另写函数，把需要返回的作为参数传入。</p>
<h3 id="DFS-深度优先"><a href="#DFS-深度优先" class="headerlink" title="DFS, 深度优先"></a>DFS, 深度优先</h3><h4 id="先序遍历：根左右（文件目录结构）"><a href="#先序遍历：根左右（文件目录结构）" class="headerlink" title="先序遍历：根左右（文件目录结构）"></a>先序遍历：根左右（文件目录结构）</h4><p>常规迭代</p>
<ul>
<li>初始化栈，并将根节点入栈；</li>
<li>当栈不为空时：<ul>
<li>弹出栈顶元素 node，并将值添加到结果中；</li>
<li>如果 node 的右子树非空，将右子树入栈；</li>
<li>如果 node 的左子树非空，将左子树入栈；<br>由于栈是“先进后出”的顺序，所以入栈时先将右子树入栈，这样使得前序遍历结果为 “根-&gt;左-&gt;右”的顺序。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1600934720-bMXWmu-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代，非递归实现,本质使用栈模拟递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//初始化栈，并将根节点入栈；</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">	<span class="comment">//当栈不为空时：</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//弹出栈顶元素 node，并将值添加到结果中；</span></span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        System.out.print(node.val); </span><br><span class="line">        <span class="comment">//如果 node 的右子树非空，将右子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">        <span class="comment">//如果 node 的左子树非空，将左子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板迭代</p>
<ul>
<li>先将根节点 <code>cur</code> 和所有的左孩子入栈并加入结果中，直至 <code>cur</code> 为空</li>
<li>每弹出一个栈顶元素 <code>tmp</code>，就到达它的右孩子，再将这个节点当作 <code>cur</code> 重新按上面的步骤来一遍，直至栈为空。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//将根节点cur和所有的左孩子入栈并加入结果中，直至cur为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(cur.val); </span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每弹出一个栈顶元素tmp,就到达它的右孩子,再将这个节点当作cur</span></span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        cur = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder_Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;        </span><br><span class="line">    <span class="comment">//访问节点的逻辑代码块</span></span><br><span class="line">    System.out.print(root.val+<span class="string">&quot; &quot;</span>);       </span><br><span class="line">    preorder_Traversal(root.left);</span><br><span class="line">    preorder_Traversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历：左根右"><a href="#中序遍历：左根右" class="headerlink" title="中序遍历：左根右"></a><strong>中序遍历：左根右</strong></h4><p>模板迭代：</p>
<ul>
<li>先将根节点 <code>cur</code> 和所有的左孩子入栈中，直至 <code>cur</code> 为空</li>
<li>每弹出一个栈顶元素 <code>tmp</code>，加入结果中，并到达它的右孩子，再将这个节点当作 <code>cur</code> 重新按上面的步骤来一遍，直至栈为空。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//将根节点cur和所有的左孩子入栈中，直至cur为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每弹出一个栈顶元素tmp,加入结果中，并到达它的右孩子,再将这个节点当作cur</span></span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        System.out.print(temp.val); </span><br><span class="line">        cur = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder_Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    inorder_Traversal(root.left);        </span><br><span class="line">    <span class="comment">//访问节点的逻辑代码块</span></span><br><span class="line">    System.out.print(root.val+<span class="string">&quot; &quot;</span>);       </span><br><span class="line">    inorder_Traversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后续遍历：左右根"><a href="#后续遍历：左右根" class="headerlink" title="后续遍历：左右根"></a><strong>后续遍历：左右根</strong></h4><p>对前序遍历的（根左右）修改为（根右左），再倒序输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规倒序输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//初始化栈，并将根节点入栈；</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; resStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">	<span class="comment">//当栈不为空时：</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//弹出栈顶元素 node，并将值添加到结果中；</span></span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        resStack.push(node);</span><br><span class="line">        <span class="comment">//如果 node 的右子树非空，将右子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        <span class="comment">//如果 node 的左子树非空，将左子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!resStack.isEmpty())&#123;</span><br><span class="line">        res.add(resStack.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板倒序输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; resStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="comment">//将根节点cur和所有的右孩子入栈并加入结果中，直至cur为空</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !s.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            resStack.push(cur); <span class="comment">// root</span></span><br><span class="line">            s.push(cur); </span><br><span class="line">            cur = cur.right; <span class="comment">// right</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//弹出一个栈顶元素tmp，并到达它的左孩子，再将这个节点当作cur</span></span><br><span class="line">        cur = s.pop();</span><br><span class="line">        cur = cur.left; <span class="comment">// left</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反向输出</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!resStack.isEmpty())&#123;</span><br><span class="line">        res.add(resStack.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder_Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    postorder_Traversal(root.left);</span><br><span class="line">    postorder_Traversal(root.right);        </span><br><span class="line">    <span class="comment">//访问节点的逻辑代码块</span></span><br><span class="line">    System.out.print(root.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS-广度优先（层次遍历）"><a href="#BFS-广度优先（层次遍历）" class="headerlink" title="BFS, 广度优先（层次遍历）"></a>BFS, 广度优先（层次遍历）</h3><p>广度优先搜索的步骤为：</p>
<ul>
<li>初始化队列 q，并将根节点 root 加入到队列中；</li>
<li>当队列不为空时：<ul>
<li>队列中弹出节点 node，加入到结果中；</li>
<li>如果左子树非空，左子树加入队列；</li>
<li>如果右子树非空，右子树加入队列；</li>
</ul>
</li>
</ul>
<p><img src="/img/tree/bfs1.gif"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列实现,分层次，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; LaywerTraversal(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 初始化队列 q，并将根节点 root 加入到队列中；</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">//当队列不为空时：</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="comment">//队列中弹出节点 node，加入到结果中；</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="comment">//如果左子树非空，左子树加入队列；</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="comment">//如果右子树非空，右子树加入队列；</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/tree/bfs2.gif"/></p>
<p>BFS常用于找最短路径。</p>
<p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p>
<p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p>
<blockquote>
<p>表达式树：分别对应前缀表达式/中缀表达式/后缀表达式<br>树叶是操作数值，其他节点是操作符。</p>
</blockquote>
<p>后缀表达式转树：操作数压栈，操作符弹栈</p>
<h2 id="对应例题"><a href="#对应例题" class="headerlink" title="对应例题"></a>对应例题</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>144 二叉树的先序遍历<br>589 N 叉树的前序遍历</p>
<blockquote>
<p><strong>606 根据先序遍历结果构造字符串</strong></p>
<ul>
<li>在先序遍历中，对每个非空访问元素，在进行处理时，先形成字符串”(“+ root.val；</li>
</ul>
<p>例如，对于[1,2,3,4]，得到”(1(2(4”</p>
<ul>
<li>如果当前访问的节点的左子树为空且右子树不为空，就在字符串中添加一个”()”<br>这样得到, “(1(2(4()”</li>
<li>同时，对于每轮递归中，在最终返回前，补全右括号”)”<br>这样得到 “(1(2(4())(3))”<br>由此，基本输出形式已经完成。剩下处理头尾两个多余括号。</li>
</ul>
<p><strong>331 验证是否是合法先序遍历结果</strong></p>
<ul>
<li>二叉树看成有向图，一条有向边带来一个入度和一个出度，二叉树的总入度等于总出度，也等于边数。即，遍历到最后，总入度肯定等于总出度。</li>
<li>还没遍历到最后时，肯定不会出现 入度 &gt;= 出度 的时刻。<br>提供 1 个出度可以理解为提供一个挂载点，提供 1 个入度为消耗一个挂载点。入度 &gt;= 出度，意味着当前已遍历的节点，消耗的挂载点已经大于等于提供的挂载点。说明已经没法挂载接下来遍历的节点了，还有要挂的，但挂满了，是不合法的。</li>
</ul>
</blockquote>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>94 基本的中序遍历<br>173 二叉搜索树迭代器</p>
<p>中序遍历一般会和BST（二叉搜索树）结合使用，这样访问的顺序是升序</p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>145 基本的二叉树的后序遍历<br>590 N 叉树的后序遍历</p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>102 二叉树的层序遍历<br>103 二叉树的锯齿形层序遍历（每层加flag或用双端队列）<br>107  二叉树的层序遍历 II（自底向上）<br>429 N 叉树的层序遍历</p>
<h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><p>递归三步：确定递归函数的参数和返回值；确定终止条件（if(root == null) return;）；确定单层递归逻辑（对哪个节点进行什么递归操作）；</p>
<p>226 翻转二叉树（对于每个节点，交换其左右子树，递归其左右子树）<br>100 相同的树（对于每个节点，判断其值是否相等，递归其左右子树）<br>572 另一个树的子树(一个树是另一个树的子树，要么这两个树相等；要么这个树是左树的子树；要么是右树的子树。)</p>
<blockquote>
<p><strong>剑指 Offer 26 树的子结构</strong></p>
<ul>
<li>先序遍历树 A中的每个节点；（对应函数 <code>isSubStructure(A, B)</code>）<ul>
<li>特例处理： 当 树 A为空 <strong>或</strong> 树 B 为空 时，直接返回 false；</li>
<li>返回值： 若树 BB 是树 AA 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<br>以 节点 A为根节点的子树 包含树 B ，对应 <code>recur(A, B)</code>；<br>树 B 是 树 A 左子树 的子结构，对应 <code>isSubStructure(A.left, B)</code>；<br>树 B 是 树 A 右子树 的子结构，对应 <code>isSubStructure(A.right, B)</code>;</li>
</ul>
</li>
<li>判断树A中 以当前节点为根节点的子树 是否包含树B。（对应函数 <code>recur(A, B)</code>）<ul>
<li>终止条件：<br>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；<br>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；<br>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li>
<li>返回值：<br>判断 A 和 B 的左子节点是否相等，即 <code>recur(A.left, B.left)</code> ；<br>判断 A 和 B 的右子节点是否相等，即 <code>recur(A.right, B.right)</code> ；</li>
</ul>
</li>
</ul>
</blockquote>
<p>101 对称二叉树/剑指 Offer 28（添加辅助函数，对于每个节点的左右孩子，判断其左的右和右的左，左的左和右的右是否相等，递归其左的右和右的左，左的左和右的右）<br>617 合并二叉树<br>965 单值二叉树<br>104 二叉树的最大深度/559 N 叉树的最大深度/111 二叉树的最小深度/110 平衡二叉树(一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1 )<br>257 二叉树的所有路径</p>
<h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><blockquote>
<p>基础操作：创建，判断 BST 的合法性、增、删、查。删较复杂<br>性质：中序遍历为升序/投射x轴后有序。<br><img src="/img/tree/x.png"/></p>
</blockquote>
<p><strong>创建</strong></p>
<p>95 不同的二叉搜索树 II<br>108 将有序数组转换为二叉搜索树<br>109 有序链表转换二叉搜索树</p>
<p><strong>合法性</strong></p>
<p>98 验证二叉搜索树（<strong>中序遍历为升序</strong>/左子树不空，左子树上所有节点的值均小于根节点的值； 若右子树不空，则右子树上所有节点的值均大于根节点的值；左右子树也为二叉搜索树。）<br>剑指33  判断数组是不是某二叉搜索树的后序遍历结果</p>
<p><strong>查</strong></p>
<p>700 二叉搜索树中的搜索</p>
<p><strong>增</strong></p>
<p>701 二叉搜索树中的插入操作</p>
<p><strong>删（合并删除/排序删除）</strong></p>
<blockquote>
<p>450.删除二叉搜索树中的节点</p>
<p><strong>合并删除：实质是将被删节点的的左子树合并到右子树上（反之也可），导致树的高度发生变化，极其容易导致树结构的不平衡。</strong></p>
<ul>
<li>没找到删除的节点，遍历到空节点直接返回</li>
<li><p>找到删除的节点</p>
<ul>
<li>左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>左右孩子节点都不为空，则将删除节点左孩子放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子。</li>
</ul>
<p><img src="/img/tree/450.删除二叉搜索树中的节点.gif"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左右孩子节点都不为空的情况</span></span><br><span class="line">TreeNode cur = root.right;</span><br><span class="line"><span class="keyword">while</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cur = cur.left;</span><br><span class="line">&#125;</span><br><span class="line">cur.left = root.left;</span><br><span class="line">root = root.right;</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>复制删除：不删除这个结点，而是让这个节点被覆盖。没有改变树的深度，对于树的删除是更优。</strong></p>
<p>后继节点：大于删除结点的最小结点（删除结点的右子树最左结点）<br>前驱节点：小于删除结点的最大结点（删除结点的左子树最右结点）<br>即中序遍历后被删节点的前驱和后继。</p>
<ul>
<li>没找到删除的节点，遍历到空节点直接返回</li>
<li><p>找到删除的节点</p>
<ul>
<li>左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>若删除结点只有一个子结点，用子结点替换删除结点</li>
<li><p>若删除结点有两个子结点，用后继结点替换删除结点（前驱结点替代也可以，但习惯上拿后继结点来替代），再删除该后继节点。</p>
<p><img src="/img/tree/copydele.png"/></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) root = root.left;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点有两个子结点的情况</span></span><br><span class="line">root.val = successor(root); <span class="comment">// 把 root.val 改成 successor</span></span><br><span class="line">root.right = deleteNode(root.right, root.val); <span class="comment">// 删除 successor</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h3><p>一个二叉查找树，每个节点的左右两个子树的高度差的绝对值不超过 1。</p>
<blockquote>
<p><strong>平衡因子</strong>： 某个结点的左子树的高度减去右子树的高度得到的差值。</p>
</blockquote>
<h4 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h4><p>对于一般的二叉搜索树，其期望高度（即为一棵平衡树时）为$log_2n$，其各操作的时间复杂度$O(log_2n)$</p>
<p>但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即$O(n)$。</p>
<p>我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</p>
<p>例如：按顺序将一组数据{1,2,3,4,5,6}分别插入到一颗空二叉查找树和AVL树中，插入的结果如下图：</p>
<p><img src="/img/tree/avl1.png"/></p>
<p><img src="/img/tree/avl2.png"/></p>
<p>由图可知，同样的结点，由于插入方式不同导致树的高度也有所不同。<br>特别是在带插入结点个数很多且正序的情况下，会导致二叉树的高度是$O(N)$.<br>而AVL树就不会出现这种情况，树的高度始终是$O(logN)$。</p>
<h4 id="how？"><a href="#how？" class="headerlink" title="how？"></a>how？</h4><p>平衡化有两大基础操作： 左旋和右旋。这两种操作都是从<strong>失去平衡的最小子树根结点</strong>开始的(即离插入结点最近且平衡因子超过1的祖结点)。</p>
<p><strong>左旋</strong>： y 结点变为该部分子树的根结点，同时 x 结点（连同其左子树 a）移动至 y 结点的左孩子。若 y 结点有左孩子 b，由于 x 结点需占用其位置，所以调整至 x 结点的右孩子处。<br><strong>右旋</strong>：x 结点变为根结点，同时 y 结点连同其右子树 c 作为 x 结点的右子树，原 x 结点的右子树 b 变为 y 结点的左子树。</p>
<p><img src="/img/tree/rotate.png"/></p>
<p>需要平衡的四种情况：（y为失衡节点）</p>
<ul>
<li>LL，向左子树（L）的左孩子（L）中插入新节点后导致不平衡。处理方法：右旋</li>
</ul>
<p><img src="/img/tree/ll.png"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node y)</span></span>&#123;</span><br><span class="line">	Node x = y.left;</span><br><span class="line">	Node t3 = x.right;</span><br><span class="line">	x.right = y;</span><br><span class="line">	y.left = t3;</span><br><span class="line">	<span class="comment">//更新height</span></span><br><span class="line">	y.height = Math.max(getHeight(y.left),getHeight(y.right))+<span class="number">1</span>;</span><br><span class="line">	x.height = Math.max(getHeight(x.left),getHeight(x.right))+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RR，向右子树（R）的右孩子（R）中插入新节点后导致不平衡。处理方法：左旋</li>
</ul>
<p><img src="/img/tree/rr.png"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node y)</span></span>&#123;</span><br><span class="line">	Node x = y.right;</span><br><span class="line">	Node t2 = x.left;</span><br><span class="line">	x.left = y;</span><br><span class="line">	y.right = t2;</span><br><span class="line">	<span class="comment">//更新height</span></span><br><span class="line">	y.height = Math.max(getHeight(y.left),getHeight(y.right))+<span class="number">1</span>;</span><br><span class="line">	x.height = Math.max(getHeight(x.left),getHeight(x.right))+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LR，处理方法：先左旋（变为LL情况）再右旋</li>
</ul>
<p><img src="/img/tree/lr.png"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左右情况旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">LR</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    y.left = leftRotate(y.left);</span><br><span class="line">    <span class="keyword">return</span> rightRotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RL，处理方法：先右旋（变为RR情况）再左旋</li>
</ul>
<p><img src="/img/tree/rl.png"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右左情况旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">RL</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    y.right = rightRotate(y.right);</span><br><span class="line">    <span class="keyword">return</span> leftRotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeRebalance</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factor = root.balaceFactor;</span><br><span class="line">    <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; root.left.balaceFactor &gt; <span class="number">0</span>) <span class="keyword">return</span> rightRotate(root); <span class="comment">//LL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; root.left.balaceFactor &lt;= <span class="number">0</span>) <span class="keyword">return</span> LR(root); <span class="comment">//LR</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &lt; -<span class="number">1</span> &amp;&amp; root.right.balanceFactor &lt;= <span class="number">0</span>) <span class="keyword">return</span> leftRotate(root); <span class="comment">//RR</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &lt; -<span class="number">1</span> &amp;&amp; root.right.balanceFactor &gt; <span class="number">0</span>) <span class="keyword">return</span> RL(root); <span class="comment">//RL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root; <span class="comment">// Nothing happened.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非旋转方法：二叉排序树 -&gt; 中序遍历得升序数组 -&gt; AVL树（leetcode 108）</p>
</blockquote>
<h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">AVL Tree Visualzation (usfca.edu)</a></p>
<h3 id="红黑树（RBT）"><a href="#红黑树（RBT）" class="headerlink" title="红黑树（RBT）"></a>红黑树（RBT）</h3><p>红黑树本身是一棵二叉查找树，在其基础上附加了两个要求：</p>
<ol>
<li>树中的每个结点增加了一个用于存储颜色的标志域；</li>
<li>树中没有一条路径比其他任何路径长出两倍，整棵树要接近于“平衡”的状态。</li>
</ol>
<blockquote>
<p>这里所指的路径，指的是从任何一个结点开始，一直到其子孙的叶子结点的长度；<br>接近于平衡：红黑树并不是平衡二叉树，只是由于对各路径的长度之差有限制，所以近似于平衡的状态。</p>
</blockquote>
<p>红黑树节点属性：父节点，子节点（两个，左子节点和右子节点），颜色，value<br>树上的每个节点都遵循下面的规则:</p>
<ul>
<li>每个节点都有红色或黑色</li>
<li>树的根始终是黑色的</li>
<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
<li>没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点）</li>
<li>从节点（包括根）到其任何后代NULL节点的每条路径都具有相同数量的黑色节点（即自平衡）</li>
</ul>
<p><img src="/img/tree/rbt.png"/></p>
<blockquote>
<p>注意：图中每个结点附带一个整形数值，表示的是此结点的黑高度（从该结点到其子孙结点中包含的黑结点数，用 bh(x) 表示（x 表示此结点）），nil 的黑高度为 0，颜色为黑色（在编程时为节省空间，所有的 nil 共用一个存储空间）。在计算黑高度时，也看做是一个黑结点。</p>
</blockquote>
<p>红黑树中每个结点都有各自的黑高度，整棵树也有自己的黑高度，即为根结点的黑高度，如图中的红黑树的黑高度为 3。对于一棵具有 n 个结点的红黑树，树的高度至多为：<code>2lg(n+1)</code>。</p>
<h4 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h4><p>对于高度为 <code>h</code> 的二叉查找树的运行时间为<code>O(h)</code>，而包含有 <code>n</code> 个结点的红黑树本身就是最高为 <code>lgn</code>（简化之后）的查找树<code>（h=lgn）</code>，所以红黑树的时间复杂度为<code>O(lgn)</code>。</p>
<p>红黑树，虽隶属于二叉查找树，但二叉查找树的时间复杂度会受到其树深度的影响，而红黑树可以保证在最坏情况下的时间复杂度仍为<code>O(lgn)</code>。当数据量多到一定程度时，使用红黑树比二叉查找树的效率要高。</p>
<p>相比于AVL树，牺牲了部分平衡性，以换取删除/插入操作时少量的旋转次数，整体来说，性能优于AVL树。</p>
<blockquote>
<p>红黑树利用了缓存，等价于2-3树。</p>
<p><img src="/img/tree/2-3.jpg"/></p>
<p>其中2-节点 等价于普通平衡二叉树的节点，<strong>3-节点 本质上是非平衡性的缓存</strong>。<br>要再平衡（rebalance）时，增删操作时，2-节点与3-节点的转化会吸收不平衡性,减少旋转次数,使再平衡尽快结束。在综合条件下,增删操作相当时,数据的随机性强时,3-节点的非平衡性缓冲效果越明显。因此红<br>黑树的综合性能更优。<br><strong>本质上是用空间换时间。</strong></p>
</blockquote>
<p>查找方法同BST树。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>换色</strong>：即红变黑，黑变红，只需要让某个对象的属性改变<br><strong>旋转</strong>，分为左旋和右旋，同二叉排序树转平衡二叉树的旋转原理完全相同。</p>
<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><blockquote>
<p>红黑树在插入数据时，插入的位置肯定在底部，不可能在中间突然插入一个值。<br>插入的数据一定是红色的（遵守红黑树规则5，如果有一条分支增加了一个黑色节点，就会打破该规则）<br>插入之后，为了满足规则4，就需要用到换色与左旋、右旋的操作</p>
</blockquote>
<p>当创建一个红黑树或者向已有红黑树中插入新的数据时，执行以下 3 步：</p>
<ul>
<li>按照二叉查找树插入结点的方法，找到新结点插入的位置；</li>
<li>将新插入的结点结点初始化，颜色设置为红色后插入到指定位置；</li>
<li><p>调整二叉查找树，想办法通过旋转以及修改树中结点的颜色，使其重新成为红黑树。分为以下情况：</p>
<ul>
<li>插入位置为整棵树的树根。处理办法：将插入结点的颜色改为黑色。</li>
<li>插入位置的双亲结点的颜色为黑色。处理方法：此种情况不需要做任何工作</li>
<li><p>插入位置的双亲结点的颜色为红色。处理方法：此时需要结合其<strong>祖父结点</strong>和祖父结点的另一个孩子结点（父结点的兄弟结点，此处称“<strong>叔叔结点</strong>”）的状态，分为 3 种情况：</p>
<ul>
<li>当前结点的父节点是红色，且叔叔结点也是红色：破坏了红黑树的第 4 条性质，解决方案为：将父结点颜色改为黑色；将叔叔结点颜色改为黑色；将祖父结点颜色改为红色；下一步将祖父结点认做当前结点，继续判断，处理结果如下图所示：</li>
</ul>
<p><img src="/img/tree/insert1.png"/></p>
<ul>
<li>当前结点的父结点颜色为红色，叔叔结点颜色为黑色，且当前结点是父结点的右孩子。解决方案：将父结点作为当前结点做左旋操作，此种情况就转变成了第 3 种情况，处理过程转情况 3 </li>
</ul>
<p><img src="/img/tree/insert2.png"/></p>
<ul>
<li>当前结点的父结点颜色为红色，叔叔结点颜色为黑色，且当前结点是父结点的左孩子。解决方案：将父结点颜色改为黑色，祖父结点颜色改为红色，从祖父结点处进行右旋处理。</li>
</ul>
<p><img src="/img/tree/insert3.png"/></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>祖宗根节点必黑，允许黑连黑，不许红连红；新增红，爸叔通红就变色，爸红叔黑就旋转，哪黑往哪旋</p>
</blockquote>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>需要完成 2 步操作：</p>
<ul>
<li>将红黑树按照BST删除结点的方法删除指定结点；<ul>
<li>若该删除结点本身是叶子结点，则直接删除，返回NULL为根节点</li>
<li>若只有一个孩子结点（左孩子或者右孩子），则让其孩子结点顶替该删除结点；</li>
<li>若有两个孩子结点，则将删除节点左孩子放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子。</li>
</ul>
</li>
<li><p>判断删除该结点是否会破坏红黑树的性质。判断的依据是：如果删除结点的颜色为红色，则不会破坏；如果删除结点的颜色为黑色，则破坏性质5，调整删除结点后的树，使之重新成为红黑树。调整方案分 4 种情况讨论</p>
<ul>
<li><p>删除结点的兄弟结点颜色是红色，调整措施为：将兄弟结点颜色改为黑色，父亲结点改为红色，以父亲结点来进行左旋操作，同时更新删除结点的兄弟结点（左旋后兄弟结点发生了变化），如下图所示：</p>
<p><img src="/img/tree/dele1.png"/></p>
</li>
<li><p>删除结点的兄弟结点及其孩子全部都是黑色的，调整措施为：将删除结点的兄弟结点设为红色，同时设置删除结点的父结点标记为新的结点，继续判断；</p>
<p><img src="/img/tree/dele2.png"/></p>
</li>
<li><p>删除结点的兄弟结点是黑色，其左孩子是红色，右孩子是黑色。调整措施为：将兄弟结点设为红色，兄弟结点的左孩子结点设为黑色，以兄弟结点为准进行右旋操作，最终更新删除结点的兄弟结点；</p>
<p><img src="/img/tree/dele3.png"/></p>
</li>
<li><p>删除结点的兄弟结点是黑色，其右孩子是红色（左孩子不管是什么颜色），调整措施为：将删除结点的父结点的颜色赋值给其兄弟结点，然后再设置父结点颜色为黑色，兄弟结点的右孩子结点为黑色，根据其父结点做左旋操作，最后设置替换删除结点的结点为根结点；</p>
<p><img src="/img/tree/dele4.png"/></p>
</li>
</ul>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>Java中TreeSet和TreeMap的实现，以及JDK 8以后，HashMap的设计</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统 / 内存管理</title>
    <url>/2021/08/06/%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<blockquote>
<p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理，如果高速CPU直接和慢速的外存进行数据的交互，有速度矛盾。</p>
</blockquote>
<span id="more"></span>
<ul>
<li>内存地址从0开始，每个地址对应一个存储单元</li>
<li>内存中也有一个一个的“小房间”，每个小房间就是以一个存储单元</li>
<li>如果计算机“按字节编址”，则每个存储单元大小为<strong>1字节</strong>，即1B，即<strong>8个二进制位</strong></li>
<li>如果字长16位的计算机“按字编址”，则每个存储单元大小为<strong>1个字</strong>，每个字的大小为<strong>16个二进制位</strong></li>
</ul>
<p>操作系统的内存管理有以下四大功能：</p>
<h2 id="操作系统负责内存空间的分配与回收"><a href="#操作系统负责内存空间的分配与回收" class="headerlink" title="操作系统负责内存空间的分配与回收"></a>操作系统负责内存空间的分配与回收</h2><p>连续分配：为用户进程分配的必须是一个连续的内存空间。<br>非连续分配：为用户进程分配的可以是一些分散的内存空间。</p>
<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><blockquote>
<p>内部碎片，分配给某进程的内存区域中，有些部分没有用上。<br>外部碎片，是指内存中的某些空闲分区由于太小而难以利用。</p>
</blockquote>
<h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>内存被分为系统区和用户区。</p>
<ul>
<li><p>系统区通常位于内存的低地址部分，用于存放操作系统相关数据；</p>
</li>
<li><p>用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。</p>
</li>
</ul>
<blockquote>
<p>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC 操作系统MS-DOS）。<br>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p>
</blockquote>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p>为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。</p>
<blockquote>
<p>分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合<br>（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）<br>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分<br>（比如：划分多个小分区、适量中等分区、少量大分区）</p>
</blockquote>
<p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。</p>
<p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。用数据结构的数组（或链表）即可表示这个表</p>
<p><img src="/img/memory/biao.jpg" style="zoom: 67%;" /></p>
<blockquote>
<p>优点：实现简单，无外部碎片。<br>缺点：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b. 会产生内部碎片，内存利用率低。</p>
</blockquote>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>又称为可变分区分配。不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p>
<p>1 系统要用什么样的数据结构记录内存的使用情况？</p>
<p><img src="/img/memory/dynamic.jpg" style="zoom: 67%;" /></p>
<p>2 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？<br>按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>首次适应</th>
<th>最佳适应</th>
<th style="text-align:left">最坏适应</th>
<th style="text-align:left">邻近适应</th>
</tr>
</thead>
<tbody>
<tr>
<td>从头到尾找适合的分区</td>
<td>优先使用更小的分区，以保留更多大分区</td>
<td style="text-align:left">优先使用更大的分区，以防止产生太小的不可用的碎片</td>
<td style="text-align:left">由首次适应演变而来，每次从上次查找结束位置开始查找</td>
</tr>
<tr>
<td>空闲分区以地址递增次序排列</td>
<td>以容量递增次序排列</td>
<td style="text-align:left">以容量递减次序排列</td>
<td style="text-align:left">以地址递增次序排列（可排列成循环链表）</td>
</tr>
<tr>
<td>综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td style="text-align:left">可以减少难以利用的小碎片</td>
<td style="text-align:left">不用每次都从低地址的小分区开始检索。算法开销小（原因同首次适应）</td>
</tr>
<tr>
<td></td>
<td>会产生很多太小的、难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序</td>
<td style="text-align:left">大分区容易被用完，不利于大进程；算法开销大（原因同左）</td>
<td style="text-align:left">会使高地址的大分区也被用完</td>
</tr>
</tbody>
</table>
</div>
<p>3 如何进行分区的分配与回收操作？</p>
<p><strong>分配</strong>：？</p>
<p><strong>回收</strong>：相邻的空闲分区要合并</p>
<p>情况一：回收区的后面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个<br>情况二：回收区的前面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个<br>情况三：回收区的前、后各有一个相邻的空闲分区，三个相邻的空闲分区合并为一个<br>情况四：回收区的前、后都没有相邻的空闲分区，新增一个表项。注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。</p>
<blockquote>
<p>动态分区分配没有内部碎片，但是有外部碎片。<br>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。</p>
</blockquote>
<h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3><h4 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h4><ul>
<li>页框：将<strong>内存空间</strong>分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，每个页框有一个编号，即“页框号”，页框号从0开始。（页框=页帧=内存块=物理块=物理页面）</li>
<li>页/页面：将<strong>进程的逻辑地址空间</strong>也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，页号也是从0开始。</li>
</ul>
<p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。<br>也即<strong>进程的页面</strong>与<strong>内存的页框</strong>有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中。</p>
<blockquote>
<p>注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费</p>
</blockquote>
<p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong>。页表通常存在PCB（进程控制块）中。</p>
<p><img src="/img/memory/yebiao.jpg" style="zoom: 50%;" /></p>
<p>页表记录进程页面和实际存放的内存块之间的映射关系。每个页表项的长度相同。</p>
<ol>
<li>每个页表项多大？占几个字节？</li>
<li>如何通过页表实现逻辑地址到物理地址的转换？</li>
</ol>
<p><strong>快表</strong>，又称联想寄存器（TLB， translation lookaside buffer ），是一种访问速度比内存快很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p>
<blockquote>
<p>TLB 和普通Cache 的区别——TLB 中只有页表项的副本，而普通Cache 中可能会有其他各种数据的副本。</p>
</blockquote>
<p>引入快表后，地址的变换过程？</p>
<p><strong>单级页表存在的的问题</strong></p>
<ul>
<li><p>问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。<br>两级页表，把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表。<br>如何实现地址变换？</p>
</li>
<li><p>问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。<br>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存。</p>
</li>
</ul>
<p>可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。若想访问的页面不在内存中，则产生缺页中断（内中断/异常），然后将目标页面从外存调入内存</p>
<h4 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h4><blockquote>
<p>与“分页”最大的区别就是——离散分配时所分配地址空间的基本单位不同</p>
</blockquote>
<p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。<br>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p>
<p>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。</p>
<p>地址变换过程？</p>
<p><strong>分页与分段的区别</strong></p>
<ul>
<li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li>
<li>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li>
<li>分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</li>
</ul>
<blockquote>
<p>访问一个逻辑地址需要几次访存？<br>分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存<br>分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存<br>与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。</p>
</blockquote>
<h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><h2 id="操作系统需要提供某种技术从逻辑上对内存空间扩充"><a href="#操作系统需要提供某种技术从逻辑上对内存空间扩充" class="headerlink" title="操作系统需要提供某种技术从逻辑上对内存空间扩充"></a>操作系统需要提供某种技术从逻辑上对内存空间扩充</h2><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><blockquote>
<p>早期的计算机内存很小，经常会出现内存大小不够的情况。引入覆盖技术，解决“程序大小超过物理内存总和”的问题。</p>
</blockquote>
<p>覆盖技术的思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“固定区”和若干个“覆盖区”。</p>
<ul>
<li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）。</li>
<li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。</li>
<li>必须由程序员声明覆盖结构，操作系统完成自动覆盖。</li>
</ul>
<p>缺点：对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）。<br>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。<br>暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）。挂起态又可以进一步细分为就绪挂起、阻塞挂起。</p>
<ul>
<li>应该在<strong>外存</strong>（磁盘）的什么位置保存被换出的进程？</li>
</ul>
<p>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。</p>
<blockquote>
<p>文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；<br>对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。</p>
</blockquote>
<p>由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式（文件管理章节）。总之，对换区的I/O速度比文件区的更快。</p>
<ul>
<li><p>什么时候应该交换？<br>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。<br>例如：发现许多进程运行时经常发生缺页，说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，可以暂停换出。</p>
</li>
<li><p>应该换出哪些进程？<br>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…（注意：PCB 会常驻内存，不会被换出外存）</p>
</li>
</ul>
<h3 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h3><h4 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h4><p><strong>一次性：</strong>作业必须一次性全部装入内存后才能开始运行。<br>这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。<br><strong>驻留性：</strong>一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</p>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）<br><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p>
<p><img src="/img/memory/jubu.jpg" style="zoom: 50%;" /></p>
<p><strong>高速缓冲技术</strong>的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。</p>
<p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序（请求调页功能）。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存（页面置换功能）。</p>
<p><strong>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</strong></p>
<blockquote>
<p>虚拟内存有一下三个主要特征：<br>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。<br>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。<br>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</p>
</blockquote>
<p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>请求分页存储管理</li>
</ul>
<p><strong>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序（请求调页）</strong></p>
<blockquote>
<ul>
<li><p><strong>何时调入页面？</strong></p>
<ul>
<li>预调页策略：运行前调入。根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如 果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页 面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入， 由程序员指出应该先调入哪些部分。</li>
<li>请求调页策略：运行时调入。进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会 被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。</li>
</ul>
</li>
<li><p><strong>从何处调页？</strong></p>
<ul>
<li>系统拥有足够的对换区空间：页面的调入、调 出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前， 需将进程相关的数据从文件区复制到对换区。</li>
<li>系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</li>
<li>UNIX 方式：运行之前进程有关的数据全部放在 文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存（页面置换）</strong></p>
<blockquote>
<p><strong>页面置换算法</strong>决定应该换出哪个页面。页面换入换出需要磁盘IO，开销较大，所以好的页面置换算法因该追求更少的缺页率。<br>最佳置换算法；先进先出置换算法；最近最久未使用置换算法；时钟置换算法；改进型的时钟置换算法</p>
</blockquote>
<p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个<strong>缺页中断</strong>（属于内中断），然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p>
<p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p>
<p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p>
<p>一条指令在执行期间，可能产生多次缺页中断。</p>
<blockquote>
<p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为<strong>抖动</strong>，或颠簸。<br>产生<strong>抖动</strong>的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）</p>
</blockquote>
<p><strong>请求分页存储管理</strong>与<strong>基本分页存储管理</strong>的主要区别：<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p>
<p><strong>页面分配、置换策略</strong></p>
<blockquote>
<p>驻留集：指请求分页存储管理中给进程分配的物理块的集合。</p>
</blockquote>
<p>固定分配VS可变分配：区别在于进程运行期间驻留集大小是否可变<br>局部置换ⅤS全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出<br>固定分配局部置换：进程运行前就分配一定数量物理块,缺页时只能换出进程自己的某一页<br>可变分配全局置换：只要缺页就分配新物理块,可能来自空闲物理块,也可能需换出别的进程页面<br>可变分配局部置换：频繁缺页的进程,多分配一些物理块;缺页率很低回收一些物理块。直到缺页率合适</p>
<ul>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
<h2 id="操作系统需要提供地址转换功能"><a href="#操作系统需要提供地址转换功能" class="headerlink" title="操作系统需要提供地址转换功能"></a>操作系统需要提供地址转换功能</h2><p>负责程序的逻辑地址与物理地址的转换。逻辑地址到物理地址的转换称地址重定位</p>
<p>数据的实际存放地址（物理地址），但在实际中生产机器指令的时候并不知道该进程的数据会被放到什么位置，所以编译生成的指令一般使用的是逻辑地址（相对地址）</p>
<p>从写程序到程序运行：</p>
<p><img src="/img/memory/run.jpg" style="zoom: 50%;" /></p>
<ol>
<li><strong>编译</strong>：由编译程序将用户源代码文件（<em> .c文件）编译成若干个目标模块（</em> .o文件）（编译就是把高级语言翻译成机器语言）</li>
<li><strong>链接</strong>：由连接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</li>
</ol>
<blockquote>
<p><strong>静态链接</strong>：在程序运行之前，将各个目标模块以及它们所需的库函数链接成一个完整的可执行文件（装入模块），之后便不再拆开<br><strong>装入时动态链接</strong>：将各个目标模块装入内存时，边装入边链接的链接方式<br><strong>运行时动态链接</strong>：在程序执行中需要该目标模块时，才对他进行链接。其优点是便于修改和更新，便于实现对目标模块的分享</p>
</blockquote>
<ol>
<li><strong>装入</strong>：由装入程序将装入模块装入内存运行</li>
</ol>
<blockquote>
<p><strong>绝对装入</strong>：单道程序环境，此时还没产生操作系统，编译、链接后得到的装入模块的指令直接就使用了绝对地址<br><strong>静态重定位（可重定位装入）</strong>：用于早期的多道批处理操作系统。</p>
<ul>
<li>编译、链接后的装入模块的地址都是从0开始的，</li>
<li><strong>指令中</strong>使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。</li>
<li>装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换在装入时一次完成的）。<br>特点：在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。<br><strong>动态重定位（动态运行时装入）</strong>：现代操作系统。</li>
<li>编译、链接后的装入模块的地址都是从0开始的。</li>
<li>装入内存后所有的<strong>指令中</strong>使用的地址依然是逻辑地址，需设置重定位寄存器。（装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。）<br>允许程序在内存中发生移动。</li>
</ul>
</blockquote>
<h2 id="操作系统需要提供内存保护功能"><a href="#操作系统需要提供内存保护功能" class="headerlink" title="操作系统需要提供内存保护功能"></a>操作系统需要提供内存保护功能</h2><p>保证各个进程在各自的存储空间内运行，互不干扰。两种方法：</p>
<p><img src="/img/memory/protect1.jpg" style="zoom: 50%;" /></p>
<h3 id="设置上下限寄存器"><a href="#设置上下限寄存器" class="headerlink" title="设置上下限寄存器"></a>设置上下限寄存器</h3><p>在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p>
<p><img src="/img/memory/protect2.jpg" style="zoom:50%;" /></p>
<h3 id="利用重定位寄存器、界地址寄存器进行判断"><a href="#利用重定位寄存器、界地址寄存器进行判断" class="headerlink" title="利用重定位寄存器、界地址寄存器进行判断"></a>利用重定位寄存器、界地址寄存器进行判断</h3><p>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</p>
<p><img src="/img/memory/protect3.jpg" style="zoom:50%;" /></p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>图与网络 / 贪心算法</title>
    <url>/2021/07/12/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<blockquote>
<p>贪心算法在对问题求解时，总是做出在当前看来是最好的选择。</p>
</blockquote>
<span id="more"></span>
<h2 id="最小生成树问题-Minimum-spanning-trees-MST"><a href="#最小生成树问题-Minimum-spanning-trees-MST" class="headerlink" title="最小生成树问题(Minimum spanning trees,MST)"></a>最小生成树问题(Minimum spanning trees,MST)</h2><blockquote>
<p><strong>生成树</strong>：指一个连通子图，它含有图中全部$n$个顶点，但只有足以构成一棵树的$n-1$条边。<br><strong>最小生成树</strong>：在所有生成树中，所有边的权重和最小的生成树。<br>假设有一个连通的无向的图$G=(V,E)$，及权值函数$w: E\rightarrow R$。考虑贪婪的方法找出$MST$。</p>
</blockquote>
<p>这个贪心策略由下面的“一般型”算法延伸，该算法<strong>每次只增长最小生成树的一条边</strong>。</p>
<p>该算法管理边集$A$，$A$不断加$1$条边，需要做$n-1$次循环。在每次迭代之前，$A$是最小生成树的子集。在每一步，我们确定可以添加到$A$的边${u,v}$，在不违背这个不变式的情况下，$A\cup \{u，v\}$还是最小生成树的一个子集。</p>
<p>称这样的边为A的安全边（$safe\  edge$），因为它可以在保持不变的情况下添加到$A$。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">GENERIC-MST</span>(G,w)</span><br><span class="line"><span class="selector-tag">A</span> ← ?</span><br><span class="line"><span class="selector-tag">while</span> <span class="selector-tag">A</span> <span class="selector-tag">does</span> <span class="selector-tag">not</span> <span class="selector-tag">form</span> <span class="selector-tag">a</span> <span class="selector-tag">spanning</span> <span class="selector-tag">tree</span></span><br><span class="line">    <span class="selector-tag">do</span> <span class="selector-tag">find</span> <span class="selector-tag">an</span> <span class="selector-tag">edge</span> <span class="selector-tag">e</span> <span class="selector-tag">that</span> <span class="selector-tag">is</span> <span class="selector-tag">safe</span> <span class="selector-tag">for</span> <span class="selector-tag">A</span></span><br><span class="line">        <span class="selector-tag">A</span> ← <span class="selector-tag">A</span> ∪ <span class="selector-tag">e</span></span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如何找到安全的边？</strong></p>
</blockquote>
<p><strong>定义</strong>: 无向图$G=(V,E)$的一个$cut(S,V-S)$是$V$的一个$cut$。</p>
<p>如果一条在$E$中的边$(u, v)$它的一个端点在$S$中，另一个端点在$V-S$中，我们说这条边穿过这个$cut(S,V-S)$</p>
<p>如果$A$中的边没有与该$cut$相交，则该$cut\ respects\ A$的边。</p>
<p>如果边的权值是任何边穿过$cut$的最小值，则边就是穿过$cut$的轻边($light\ edge$)。注意，可以有更多轻边，那么选择其中一条即可。</p>
<p>简单来说，就是$A∪safe\ edge$就是最小生成树的子集，$A$中的点没有穿过$cut$，再在$cut$中找到轻边作为安全边，得到新的$A$，然后再找到新的$cut$，满足$A$没有穿过$cut$，循环此过程，直至找到$n-1$条边。</p>
<blockquote>
<p>定理：设$G=(V,E)$是连通的具有权重$w$的无向图，令$A$是$E$的子集，包含在$G$的最小生成树中。设$(S, V-S)$为任意$cut(respect\ A)$，设$(u,v)$为穿过$(S, V-S)$的轻边。那么$(u,v)$是$A$的安全边。</p>
</blockquote>
<p><strong>证明</strong>:</p>
<p>设$T$是一个最小生成树，包含$A$。</p>
<ul>
<li>若$T$包含轻边$(u,v)$，则$A\cup \{u，v\} \in T$,</li>
<li>若$T$不包含轻边$(u,v)$，构造另一棵最小生成树$T’$，对于当前生成树$T，u，v$之间没有直接的边相连，但可以通过路径$p$连通，按图中将$G$分割为$cut$两部分，使得$u， v$在$cut$不同的点集，那么必然存在这样 的$x，y$也被划分在$cut$两部分，边$(u,v)(x,y)$都穿过该$cut$，$(u,v)$是轻边，连接$(u,v)$，断开$(x,y)$，得到新的生成树$T’$，$T’=T-(x,y)\cup (u,v)$。因为$(u,v)$是一个轻边，$w(u,v)\leq w(x,y)$。因此,$w (T’) = w (T) - w (x, y) + w (u, v) \leq w (T)$。由于$T$是最小生成树，所以$T’$也必须是最小生成树。</li>
</ul>
<p><strong>Kruskal , Prim使用特定的规则来确定安全边。</strong></p>
<ul>
<li><strong>kruaskal算法</strong>找到安全边的方法是，在所有连接森林中两颗不同树的边里面，找到权重最小的边$(u,v)$。</li>
</ul>
<div align="center">
    <img src="/img/greedy/2.jpg"/>
</div>

<ul>
<li><strong>Prim算法</strong>所具有的一个性质是集合$A$中边总是构成一棵树。这颗树从一个任意的根节点r开始，一直长大到覆盖$V$中的所有结点时为止。算法每一步在连接集合$A$和$A$之外的节点所有边中，选择一条轻边加入到$A$中。</li>
</ul>
<div align="center">
    <img src="/img/greedy/3.jpg"/>
</div>



<h2 id="最大独立集-Maximum-independent-set"><a href="#最大独立集-Maximum-independent-set" class="headerlink" title="最大独立集(Maximum independent set)"></a>最大独立集(Maximum independent set)</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Greedy independent <span class="keyword">set</span></span><br><span class="line"><span class="keyword">input</span> Graph G=(V,E);</span><br><span class="line">output independent <span class="keyword">set</span> V<span class="string">&#x27; in G;</span></span><br><span class="line"><span class="string">begin</span></span><br><span class="line"><span class="string">    V&#x27;</span>:=ф</span><br><span class="line">    U:=V</span><br><span class="line">    <span class="keyword">while</span> U <span class="keyword">is</span> <span class="keyword">not</span> empty <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        x: vertex <span class="keyword">of</span> minimum degree <span class="keyword">in</span> graph induced <span class="keyword">by</span> U</span><br><span class="line">        V<span class="string">&#x27;:=V&#x27;</span>U(x);</span><br><span class="line">        eliminate x <span class="keyword">and</span> <span class="keyword">all</span> its neighbors <span class="keyword">from</span> U</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> V<span class="string">&#x27;</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>贪心算法找不到最大独立集的例子：</p>
<div align="center">
    <img src="/img/greedy/1.png"/>
</div>

<p>贪心结果：${a, e}$<br>实际结果：${b, c, d}$</p>
</blockquote>
<p>可以看出，随着左部和中部图中点数的增加，贪心所得到的解与最优值可以相差任意远。可以使用图的密度函数判断贪心算法的表现。</p>
<blockquote>
<p>定理：假设图$G$有$n$个点和$m$条边，记$\delta =\frac{m}{n}$为图G的密度。贪心算法求得的解$m_{Gr}(G)\geq \frac{n}{(2\delta +1)}$</p>
</blockquote>
<p><strong>证明：</strong></p>
<p>设$x_i$为程序while循环第$i$次迭代时选定的顶点，$d_i$为$x_i$的度。<br>该算法将$x_i$及其所有$d_i$邻居从$G$中删除。第$i$步删除$d_{i+1}$个点，得到</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}(d_i+1)=n.........(1)</script><p>又因为删除点的同时会删除边，那么与$x_i$相连的$d_i$个点至少度是$d_i$，那么删除的边有$(d_i+1)d_i$，又$d_i$个点之间可能存在互相连接的情况，那么删除的边至少有$(di+1)di/2$，删除的边数一定小于总边数，得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}(d_i+1)\frac{d_i}{2}\leq m=\delta n..........(2)</script><p>$(2)*2+(1)$得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}(d_i+1)^2\leq n(2\delta +1)</script><p>利用柯西斯瓦格不等式，对于所有的$i$，当$d_i+1=\frac{n}{m_{Gr}(G)}$时，不等式的左边取得极小值。</p>
<script type="math/tex; mode=display">
n(2\delta +1)\geq \sum_{i=1}^{m_{Gr}(G)}(d_i+1)^2\geq \frac{n^2}{m_{Gr}(G)}</script><p>得证。</p>
<p>下面的定理提供了最优解与贪婪算法求得的解之间的关系。</p>
<blockquote>
<p>定理：有$n$个顶点和$m$的图$G$，设$\delta =\frac{m}{n}$。可以找到一个独立的集合$m_{Gr}(G)$，令最优解$\frac{m^*(G)}{m_{Gr}(G)}\leq (\delta +1)$</p>
</blockquote>
<p><strong>证明</strong>:</p>
<p>本证明与前一证明相似。在本例中，确定一个最大的独立集合${V^<em>}$，令$k_i$为在第$i$次循环中所删除$d_{i+1}$个顶点并在${V^</em>}$中的顶点数。显然</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}k_i=|V^*|=m^*(G)............(3)</script><p>由于贪心算法选择的顶点最小度，删除的顶点的度的和至少是$d_i(d_i+1)$。</p>
<p>因为一条边的两个端点不可能都在$V^<em>$</em>中，*它这样删除边的数目至少为$\frac{(d_i(d_i+1)+k_i(k_i-1))}{2}$，这里可以修改$(2)$，得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}\frac{d_i(d_i+1+ki(k_i-1))}{2}\leq \delta n...........(4)</script><p>$(2)+(3)+2*(4)$得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}((d_i+1)^2+k_i^2)\leq n(2\delta +1)+m^*(G)</script><p>应用$C-S$不等式，当$d_i+1=\frac{n}{m_{Gr}(G)}\ and\ k_i=\frac{m^*(G)}{m_{Gr}(G)}$，上述不等式左边最小，因此</p>
<script type="math/tex; mode=display">
n(2\delta +1)+m^*(G)\geq \sum_{i=1}^{m_{Gr}(G)}((d_i+1)^2+k_i^2)\geq \frac{n^2+m^*(G)^2}{m_{Gr}(G)}</script><p>即</p>
<script type="math/tex; mode=display">
m_{Gr}(G)\geq m^*(G)\frac{\frac{n}{m^*(G)}+\frac{m^*(G)}{n}}{2\delta +1+\frac{m^*(G)}{n}}</script><p>当$m^*(G)=n$时，不等式最小。把这一项代入，定理成立。</p>
<h2 id="背包问题-Greedy-knapsack"><a href="#背包问题-Greedy-knapsack" class="headerlink" title="背包问题(Greedy knapsack)"></a>背包问题(Greedy knapsack)</h2><p>输入:集合$X$的$n$个元素，对于$X$中的每个$x_i$，价值$p_i$，重量$w_i$，正整数$b$；<br>输出:子集$Y\in X$使得$\sum_{x_i\in Y}w_i\leq b,max\ {\sum_{x_i\in Y}} p_i$<br>按$\frac{p_i}{w_i}$的规则进行贪心选择。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    sort X <span class="keyword">in</span> non-increasing <span class="keyword">order</span> <span class="keyword">with</span> respect <span class="keyword">to</span> the ratio pi/wi;</span><br><span class="line">    Y:=<span class="keyword">empty</span> <span class="keyword">set</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> b&gt;=wi <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        Y=YU<span class="comment">&#123;xi&#125;</span></span><br><span class="line">        b=b-wi</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    return Y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>找不到最优解的例子：<br>令$p_i=w_i=1，i=1,2，..，n-1, p_n=b-1, w_n=b=k_n$，其中$k$是一个任意大的数。<br>在这种情况下，最优解$m^*(x)=b-1$;而贪心算法找到的解的值为$n-1$。因此</p>
<script type="math/tex; mode=display">
\frac{m^*(x)}{m_{Gr}(x)} > k</script><p>贪心算法的劣势是由于算法没有将价值最高的元素包含在解中，而最优的元素正是价值最高的。这表明一个简单的修改贪心的程序有更好的性能。</p>
<blockquote>
<p>定理：给定一个背包的实例$x$，令$m_H(x)=max(P_{max}，m_{Gr}(x))$，其中$P_{max}$是$x$中一个项目的最大价值，$m_H(x)$满足以下不等式:$\frac{m^*(x)}{m_H(x)}&lt; 2$。</p>
</blockquote>
<p><strong>证明</strong>：设$j$为根据贪心选择第一个装不进背包物品的下标，此时背包转装入的物品价值为</p>
<script type="math/tex; mode=display">
\overline{p_j}=\sum_{i=1}^{j-1}\leq m_{Gr}(x)</script><p>重量为</p>
<script type="math/tex; mode=display">
\overline{w_j}=\sum_{i=1}^{j-1}w_i\leq b</script><p>首先证明任何最优解必须满足以下条件不等式:<br>$m^*(x)&lt;\overline{p_j}+p_j$，</p>
<p>因为装入前j-1个物品后，容量还剩余$b-\overline{w_j}&lt; w_j$，贪心选择在装入$j-1$个物品后，无法装入$j$，其密度为$\frac{p_j}{w_j}$，那么如果剩余容量按最优的去放，$(b-\overline{w_j})\frac{p_j}{w_j}&lt;w_j\frac{p_j}{w_j}=p_j$</p>
<p>如果$p_j&lt;\overline{p_j}$，那么$m^*(x)&lt;2\overline{p_j}\leq 2m_{Gr}(x)\leq 2m_H(x)$；</p>
<p>如果$p_j&gt;\overline{p_j}$，那么$P_{max}&gt;\overline{P_j}$，有$m^*(x)\leq \overline{p_j}+p_j\leq 2{p_j}\leq 2P{max}\leq 2m_H(x)$</p>
<h2 id="The-Stein-Lovasz-Theorem"><a href="#The-Stein-Lovasz-Theorem" class="headerlink" title="The Stein-Lovasz Theorem"></a>The Stein-Lovasz Theorem</h2><blockquote>
<p>The stein-lovasz Theorem 理论最基本的模型是解决集合的元素覆盖问题。使用贪心算法，以获得一个使用最少列元完成最大行覆盖的方案。<br>假设$(0,1)$矩阵$A$的大小是$N×M$ ,矩阵$A$的特征是每行至少具有$v$个$1$，每列最多$a$个$1$。假设现在从其中抽取一个子矩阵$C⊂A$,大小是$N×K$，使得子矩阵的每行元素都不是全零行，证明$K$存在一个上界，<br>$K≤\frac{N}{a}+(\frac{M}{v})lna≤(\frac{M}{v})(1+lna)$<br>分析：能不能使用一种抽取列数尽可能少的方案，如果使用的列数目比给定的边界条件$\frac{N}{a}+(\frac{M}{v})lna$小，那么原来的问题就自然获得证明。</p>
</blockquote>
<p><strong>贪心算法思路描述如下</strong></p>
<ol>
<li>初始化矩阵$(0,1)$矩阵$A$，每列的$1$权重值$c_i∈\{1,2,3,……,a\}$,然后按照列权重按照 $a,a-1,a-2,…,1$ 执行降序排序，此时的矩阵命名为$A_a$;</li>
<li>从最左边权重最高为$a$的第一列开始，删除这一列，并且这列对应的$1$所在相应的$a$个行也统一删掉。在删除$1$列和$a$行后的矩阵$A$，重新划定权重，继续寻找左边最高权重为$a$的列，继续删除。在删除$2$列和$2∗a$行后的矩阵$A$，重新划定权重，继续寻找左边最高权重为$a$的列，继续删除。重复$K_a$次后，把最高权重为$a$的列及对应的$a∗K_a$行都删掉了，此时的矩阵变成了$A_{a−1}$;</li>
<li>以矩阵$A_{a−1}$开始，从左边权重最高为$a-1$的第一列开始，删除这一列，并且这列所对应的$a−1$行也统一删掉。删完后，重新划定权重，继续寻找左边最高权重为$a-1$的列，继续删除。重复$K_{a−1}$次后，把最高权重为$a-1$的列及其对应的$(a−1)∗K_{a−1}$行都删掉了，此时的矩阵变成了$A_{a−2}$.</li>
<li>重复步骤3，删除权重为$a-2,a-3,…,1$的列，直到矩阵$A_1$变成了空。<br>将之前删除的所有列元集中起来重新组合成$N×K$矩阵，$K=\sum_{i=1}^a K_i$</li>
</ol>
<p><strong>证明</strong>：</p>
<p>假设$A_a=A_{N*M}$表示由$a$个1且每列的1互不重合的列组成的矩阵</p>
<p>$A_{a-1}’$表示由a-1个1且每列的1互不重合的列组成的矩阵。$|A_a’|=K_a$，那么删除覆盖的$K_a\cdot a$行得到新的矩阵$A_{a-1}=A_{(N-aK_a)\times (M-K_a)}$，那么每一列至多有$a-1$个$1$，</p>
<p>$|A_{a-1}’|=K_{a-1}$，那么删除覆盖的$K_{a-1}\cdot (a-1)$行得到新的矩阵$A_{a-2}$。</p>
<p>以此类推，$A_{i-1}$，每行至少$v$个1，每列至多$i-1$个$1$，那么有$N-aK_a-(a-1)K_{a-1}-…-iK_i$行，记为$k_i$行，有$M-K_a-…-K_i$列。</p>
<p>$k_a=N-aK_a$，即$K_a=\frac{N-k_a}{a}$，令$N=k_{a+1}$，则$K_a=\frac{k_{a+1}-k_a}{a}$，以此类推得到</p>
<script type="math/tex; mode=display">
K_i=\frac{k_{i+1}-k_i}{i}</script><script type="math/tex; mode=display">
\sum_{i=1}^{a}K_i=\sum_{i=1}^{a}\frac{k_{i+1}-k}{i}=\frac{k_{a+1}}{a}-\frac{k_a}{a}+\frac{k_a}{a-1}-\frac{k_{a-1}}{a-1} +...+\frac{k_2}{1}=\frac{N}{a}+\frac{k_a}{a(a-1)}+\frac{k_{a-1}}{(a-1)(a-2)}+...+\frac{k_2}{2\times 1}</script><p>使用双计数，分别对行和列进行计数，对于$A_{i-1}$，每一行至少$v$个1，而每列至多$i-1$个$1$，可得对$1$进行行计数不会超过进行列计数，即</p>
<script type="math/tex; mode=display">
k_i\times v\leq (M-K_a-...-K_i)\times (i-1)\leq M\times (i-1) \frac{k_i}{i-1}\leq \frac{M}{v}</script><p>那么</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{a}K_i\leq \frac{N}{a}+\frac{1}{a}\frac{M}{v}+\frac{1}{a-1}\frac{M}{v}+...+\frac{1}{2}\frac{M}{v}=\frac{N}{a}+\frac{M}{v}(\frac{1}{a}+\frac{1}{a-1}+...+\frac{1}{2})\leq \frac{N}{a}+\frac{M}{v}lna\leq \frac{M}{v}+\frac{M}{v}lna=\frac{M}{v}(1+lna)​</script><h3 id="应用1：完美哈希族函数（Perfect-Hash-Function）"><a href="#应用1：完美哈希族函数（Perfect-Hash-Function）" class="headerlink" title="应用1：完美哈希族函数（Perfect Hash Function）"></a>应用1：完美哈希族函数（Perfect Hash Function）</h3><blockquote>
<p>$(n,m,w)$-完美哈希族是一个函数F集合，使得$|Y|=n$， $|X|=m$,<br>$f:Y\rightarrow X$对于$F$中的每一个$f$，对于任何$C\subseteq \{1,2,…,n\}$使得$|C|=w$，$C$是$Y$的$w$元子集合，并且至少存在一个$F$中的$f$使得$f|C$是一一对应的。如果$|F|=N$那么完美哈希族可以记作$PHF(N;n,m,w)$。<br>求满足条件的函数数目的一个上界。</p>
</blockquote>
<div align="center">
    <img src="/img/greedy/3.png"/>
</div>

<p>$|F|=N$，如上图，假设$w=3$，那么任选$Y$中的三列，有$\binom{n}{3}$种选择，要求其中存在一行使得三个函数值各不同，例如取$1，2，3$列，$f_{11}$，$f_{12}$，$f_{13}$互不相同就满足要求一一映射。<br>$f:Y\rightarrow X$，$n$个$Y$对应到$m$个$X$，每一个$Y$有$m$种选择，那么有$m^n$个函数。从中挑出最少的函数(即N越小越好)使得对于任何的$C$可以满足一一对应要求。</p>
<ul>
<li>套用ST定理：<br>$N:\binom{n}{w}$，从$M:m^n$个函数中挑选出最少的函数满足要求，那么得到的矩阵就是$NxM$的$(0,1)$矩阵$A$，$A_{ij}=1$的含义就是当$|w|=i$，$f_j$是可以满足一一映射要求的。</li>
</ul>
<p>$v:\binom{m}{w}w!\cdot m^{n-w}$，表示从$m$个值中选取$w$的值排列放入选择的$w$个，剩余未赋值的$n-w$个，就任意赋值。<br>$a:\binom{n}{w}$，每一个函数至多覆盖$a$个。</p>
<p>套用S-T定理得</p>
<script type="math/tex; mode=display">
N\leq \frac{m}{w!\binom{m}{w}}(1+log\binom{n}{w})</script><ul>
<li>使用概率方法:<br>从$m^n$个函数中随机选择$N$个函数出来，构造一张随机的函数表，考虑坏概率，在函数表中没有一个函数可以使$w$存在一一映射关系，对于一个函数坏概率为存在一一对应关系的对立事件，取出$N$个函数，得<script type="math/tex; mode=display">
(1-\frac{\binom{m}{w}w!m^(n-w)}{m^n})^N\binom{n}{w}</script>使其小于1，那么一定存在完美哈希族。(两边取对数求解)</li>
</ul>
<h3 id="应用2：分割系统-Splitting-Systems"><a href="#应用2：分割系统-Splitting-Systems" class="headerlink" title="应用2：分割系统(Splitting Systems)"></a>应用2：分割系统(Splitting Systems)</h3><p><strong>在某个域中，$\alpha ^n=\beta$，$\alpha ,\beta$已知且为离散的，那么如何求解$n$？</strong></p>
<p><strong>分割系统的提出就是为了解决离散对数问题。</strong></p>
<blockquote>
<p>假设$n,t$为偶数，$X$是点集合,$B$是超边集合。<br>a) $|X|=n$,$B$是$X$的$\frac{n}{2}$子集的集合，称为区组<br>b)对于每一个$Y\subseteq X$中存在区组$B$，使得$|B\cap Y|=\frac{t}{2}$。<br>取最少$N$个$B$使得上面的条件满足。</p>
</blockquote>
<ul>
<li>使用S-T定理<br>$N:\binom{n}{t}$，对所有的t元子集合进行分割;<br>$M:\binom{n}{\frac{n}{2} }$，完成的方法总数;</li>
</ul>
<p>接下来确定$v$，那么对于某一行有多少$\frac{n}{2}$元子集合可以分割$t_i$，$t$个位置中一半放$1$，剩余一半放$0$，问题是一个$n$元集合，此时还剩$n-t$个位置没有放数，且还缺少$\frac{n-t}{2}$个1，那么得到子集合个数$\binom{t}{ \frac{t}{2} }\cdot \binom{n-t}{\frac{n-t}{2}}$；</p>
<p>确定$a$，对于固定的$\frac{n}{2}$元子集合可以分割多少$t$，$\binom{\frac{n}{2}}{\frac{t}{2}}\binom{\frac{n}{2}}{\frac{t}{2}}$，套用S-T定理，</p>
<script type="math/tex; mode=display">
N\leq \frac{\binom{n}{\frac{n}{2}}}{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}(1+2ln\binom{\frac{n}{2}}{\frac{t}{2}})</script><div align="center">
    <img src="/img/greedy/2.png"/>
</div>

<ul>
<li>使用概率方法：<br>定义$A_i$，第$i$个$t$元子集合未被分割。对于一个$t$元集合没有分割的概率是分割时间的对立事件，为<script type="math/tex; mode=display">
1-\frac{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}{\binom{n}{\frac{n}{2}}}</script>共有$N$个$\frac{n}{2} $元子集合未被分割，为<script type="math/tex; mode=display">
(1-\frac{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}{\binom{n}{\frac{n}{2} }})^N=P(A_i)</script>那么至少有一个$t$元集合未被分割的概率为<script type="math/tex; mode=display">
P(\cup A_i)\leq \sum P(A_i)=\binom{n}{t}P(A_i)<1</script>令其小于$1$，那么没有未被分割的情况概率大于$0$。</li>
</ul>
<p>参考：<a href="https://www.codenong.com/cs106200371/">图论学习笔记五贪心算法 | 码农家园 (codenong.com)</a></p>
]]></content>
      <tags>
        <tag>图与网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode / dp</title>
    <url>/2021/12/27/dp/</url>
    <content><![CDATA[<blockquote>
<p>记录前边问题结果，利用递推公式求解，空间换时间。</p>
</blockquote>
<span id="more"></span>
<h2 id="一维数组dp"><a href="#一维数组dp" class="headerlink" title="一维数组dp"></a>一维数组dp</h2><blockquote>
<p>509  斐波那契数 / 70. 爬楼梯 / 矩形覆盖<br>338  比特位计数(dp + 位运算)<br>55  跳跃游戏<br>45  跳跃游戏 II（dp/贪心）<br>198  打家劫舍<br>213 打家劫舍 II<br>121  最佳买卖股票时机 (一次买卖)<br>122  买卖股票的最佳时机 II (多次买卖)<br>264/剑指49 丑数【数学】<br>650 <strong>只有两个键的键盘</strong></p>
<ul>
<li>对每一个格子 i（i个A），如果i可以被j除尽，说明 j 个A可以通过复制粘贴得到 i 个A，复制粘贴次数为 i / j</li>
</ul>
</blockquote>
<h3 id="子序列与子串"><a href="#子序列与子串" class="headerlink" title="子序列与子串"></a>子序列与子串</h3><p>子序列：子序列不要求元素连续。</p>
<blockquote>
<p>300  最长递增子序列<br>516 最长回文子序列<br>1143/剑指95 最长公共子序列</p>
</blockquote>
<p>子串：要求数组元素必须连续</p>
<blockquote>
<p>53/剑指42 连续子数组的最大和 (子串最大和)<br>674 最长递增子串<br>5  最长回文子串<br>最长公共子串</p>
</blockquote>
<h2 id="二维数组dp"><a href="#二维数组dp" class="headerlink" title="二维数组dp"></a>二维数组dp</h2><blockquote>
<p>62  不同路径<br>63  不同路径 II<br>剑指47  礼物的最大价值(最大路径和) / 64  最小路径和<br>120  三角形最小路径和</p>
</blockquote>
<h2 id="dp背包"><a href="#dp背包" class="headerlink" title="dp背包"></a>dp背包</h2><ul>
<li>给定一个背包容量 target，一个数组 nums(物品)，能否按一定方式选取 nums 中的元素得到target。背包容量 target 和物品 nums 的类型可能是数，也可能是字符串</li>
<li>target可能题目已经给出(显式)，也可能需要从题目的信息中挖掘出来(非显式)(常见的非显式 target 比如sum/2 等)</li>
<li>选取方式有常见的以下几种：每个元素选一次/每个元素选多次/选元素进行排列组合<br>1、0/1背包：每个元素最多选取一次, 外循环 nums,内循环 target, target 倒序且 target&gt;=nums[i];<br>2、完全背包：每个元素可以重复选择, 外循环 nums,内循环 target, target 正序且 target&gt;=nums[i];<br>3、组合背包：背包中的物品要考虑顺序, 外循环target,内循环 nums, target 正序且 target&gt;=nums[i];<br>4、分组背包：不止一个背包，需要遍历每个背包, 三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板</li>
</ul>
<p>而每个背包问题要求的也是不同的，按照所求问题分类，又可以分为以下几种：<br>1、最值：要求最大值/最小值</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">dp<span class="comment">[i]</span> = max/min(dp<span class="comment">[i]</span>, dp<span class="comment">[i-nums]</span>+1)或dp<span class="comment">[i]</span> = max/min(dp<span class="comment">[i]</span>, dp<span class="comment">[i-num]</span>+nums);</span><br></pre></td></tr></table></figure>
<p>2、存在：是否存在…，满足…</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">// boolean</span><br><span class="line">dp<span class="comment">[i]</span>=dp<span class="comment">[i]</span>||dp<span class="comment">[i-num]</span>;</span><br></pre></td></tr></table></figure>
<p>3、组合：求所有满足……的排列组合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i]+=dp[i-num];</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二维dp背包，自底向上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack_bottom_up</span><span class="params">(<span class="keyword">int</span>[] weights,<span class="keyword">int</span>[] values, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = weights.length;</span><br><span class="line">    <span class="comment">// dp[i][w]: 对于第i个物品，总重不超过x的最大价值</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][capicity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; capacity; j++) dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; n; x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span>; y &lt; capacity; y++)&#123;</span><br><span class="line">            <span class="keyword">int</span> w = weights[x];</span><br><span class="line">            <span class="keyword">int</span> v = values[x];</span><br><span class="line">            <span class="keyword">if</span>(y &lt; w) dp[x][y] = dp[x-<span class="number">1</span>][y]; <span class="comment">// 第i个物品的重量w超出限制y</span></span><br><span class="line">            <span class="keyword">else</span> dp[x][y] = Math.max(dp[x-<span class="number">1</span>][y], dp[x-<span class="number">1</span>][y-w]+v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][capacity-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode / Math</title>
    <url>/2021/12/27/Math/</url>
    <content><![CDATA[<blockquote>
<p>…</p>
</blockquote>
<span id="more"></span>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><blockquote>
<ul>
<li>54/剑指29  螺旋矩阵<br>【矩阵为空时需特判，定义四个边界左,上,右,下,<br>顺时针打印的顺序：从左到右；从上到下；从右到左；从下到上<br>每个方向的打印需要做三件事：打印当前下标的值；边界收缩；判断打印是否结束】</li>
<li>59  螺旋矩阵-II</li>
<li>剑指04/ 240 二维数组中的查找/搜索二维矩阵 II（右上角，二叉搜索树）</li>
<li>74 搜索二维矩阵<br>【右上角或左下角开始，二叉搜索树；二分，二维矩阵映射为一维】</li>
</ul>
</blockquote>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul>
<li>204 统计质数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>367 有效的完全平方数 / 69 Sqrt(x) 【二分】</li>
<li>365 水壶问题【找最大公约数】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 辗转相除法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> remainder = x % y;</span><br><span class="line">    <span class="keyword">while</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = remainder;</span><br><span class="line">        remainder = x % y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>650 <strong>只有两个键的键盘</strong>【数学 - 因数分解】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += i;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">1</span>) ans += n;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>263 丑数</li>
<li>264/剑指49 丑数【因数只含2、3、5的数】</li>
<li>470 用 Rand7() 实现 Rand10()</li>
</ul>
<blockquote>
<p>已知 rand_N() 可以等概率的生成[1, N]范围的随机数<br>那么：(rand_X() - 1) × Y + rand_Y() ==&gt; 可以等概率的生成[1, X * Y]范围的随机数<br>即实现了 rand_XY()</p>
<p>如何利用一个小范围随机数，得到一个大范围等概率随机数？<br>采用随机数的 k 进制，对于 randN，采用 N 进制，即：(randN - 1) * N + randN 得到了一个 N * N 范围的等概率随机数，如果还不够大，可以继续在 randN 或生成的 randN * N 上使用这个</p>
<p>如何利用一个小范围随机数，得到一个确定范围的等概率随机数？<br>先采用随机数的 k 进制，得到一个不小于确定范围的随机数 randK，然后<strong>对超过确定范围数进行拒绝</strong>。 </p>
<p>对于随机数 randN，只要 K 是 N 的约数（或者说 N 是 K 的整数倍），都可以通过 randN 一步得到 randK：randK = (randN % K) + 1;</p>
</blockquote>
<ul>
<li>7  整数反转</li>
</ul>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Coding / Inter Prediction</title>
    <url>/2021/12/27/Video%20Coding%20_%20Inter%20Prediction/</url>
    <content><![CDATA[<blockquote>
<p>Inter Prediction</p>
</blockquote>
<span id="more"></span>
<h2 id="H-265"><a href="#H-265" class="headerlink" title="H.265"></a>H.265</h2><p>inter prediction 以 inter PU 为单位进行。</p>
<blockquote>
<p>inter PU 划分方式：</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_1fa7e682dc597fa5200b19a48bc54df8.png" alt=""></p>
</blockquote>
<h3 id="运动估计"><a href="#运动估计" class="headerlink" title="运动估计"></a>运动估计</h3><blockquote>
<p>为当前帧的每个 PU 在已编码帧（参考图像）中搜索一个最优匹配块，计算运动向量（MV）</p>
</blockquote>
<ul>
<li><p>MV的表示：当前块左上角坐标和参考块左上角坐标之差</p>
</li>
<li><p>哪些帧可以作为参考帧？</p>
<ul>
<li>从参考列表中搜</li>
</ul>
</li>
</ul>
<ul>
<li>如何理解匹配？</li>
</ul>
<ul>
<li><p>如何搜索MV？</p>
<ul>
<li>全搜索：搜到的一定最优，复杂度高</li>
<li><p>TZSearch：不是标准的一部分，在HM种作为快速搜索算法。</p>
<ul>
<li>确定搜索起点：在以下几个位置选择RD-cost最小的作为搜索起点：median prediction MV，左/上/右上块的MV,（0，0）</li>
<li>搜索：用棱形模板或正方形模板搜索，下图中 0 的位置为搜索起点，向外扩散，步长以2的次幂增加，选择RDcost最小的点。步长=1：4点搜索；步长&lt;=8: 8点搜索；步长 &gt; 8: 16点搜索</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_288f7fb2a26fb379982864d18707dff7.png" alt=""></li>
<li>补充搜索：避免陷入局部最优。<ul>
<li>若步骤2选出的最优点对应的步长为1，则需要在该点周围进行二点搜索，目的是补充搜索最优点周围尚未搜索的点；</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_226c34f2925cfd00b8327e181678d252.png" alt=""></li>
<li>若步骤2选出的最优点对应的步长大于某个阈值（HM默认5），则以该最优点为中心，在一定范围内做全搜索（搜索该范围内的所有点），选择率失真代价最小的作为最优点；</li>
<li>以步骤4得到的最优点为起始点，重复步骤2-4，细化搜索。当相邻两次细化搜索得到的最优点一致时停止细化搜索。此时得到的MV即为最终MV。</li>
</ul>
</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_acc60a5f1fd71722db46a59aee9f21fa.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>提高MV精度：非整数像素<ul>
<li>HEVC支持1/4亮度亚像素插值<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_e4d1cb423fb5f0ab6afa302189755eb4.png" alt=""></li>
<li>A为整像素处，b、h为1/2像素处，a -&gt; 1/4, c-&gt; 3/4</li>
<li>a -&gt; 7抽头滤波器，用同一行的整数位置7个相邻像素值</li>
<li><script type="math/tex; mode=display">
  \begin{array}{l}
  \mathrm{a}_{0,0}=\left(-\mathrm{A}_{-3,0}+4 * \mathrm{~A}_{-2,0}-10 * \mathrm{~A}_{-1,0}+58 * \mathrm{~A}_{0,0}+17 * \mathrm{~A}_{1,0}-5 * \mathrm{~A}_{2,0}+\mathrm{A}_{3,0}\right)>>\operatorname{shift} 1 \\
  \mathrm{~b}_{0,0}=\left(-\mathrm{A}_{-3,0}+4 * \mathrm{~A}_{-2,0}-11 * \mathrm{~A}_{-1,0}+40 * \mathrm{~A}_{0,0}+40 * \mathrm{~A}_{1,0}-11 * \mathrm{~A}_{2,0}+4 * \mathrm{~A}_{3,0}-\mathrm{A}_{4,0}\right)>>\operatorname{shift1} \\
  \mathrm{c}_{0,0}=\left(\mathrm{A}_{-2,0}-5 * \mathrm{~A}_{-1,0}+17 * \mathrm{~A}_{0,0}+58 * \mathrm{~A}_{1,0}-10 * \mathrm{~A}_{2,0}+4 * \mathrm{~A}_{3,0}-\mathrm{A}_{4,0}\right)>>\operatorname{shiftl} \\
  \mathrm{d}_{0,0}=\left(-\mathrm{A}_{0,-3}+4 * \mathrm{~A}_{0,-2}-10 * \mathrm{~A}_{0,-1}+58 * \mathrm{~A}_{0,0}+17 * \mathrm{~A}_{0,1}-5 * \mathrm{~A}_{0,2}+\mathrm{A}_{0,3}\right)>>\operatorname{shiftl} \\
  \mathrm{h}_{0,0}=\left(-\mathrm{A}_{0,-3}+4 * \mathrm{~A}_{0,-2}-11 * \mathrm{~A}_{0,-1}+40 * \mathrm{~A}_{0,0}+40 * \mathrm{~A}_{0,1}-11 * \mathrm{~A}_{0,2}+4 * \mathrm{~A}_{0,3}-\mathrm{A}_{0,4}\right)>>\operatorname{shiftl} \\
  \mathrm{n}_{0,0}=\left(\mathrm{A}_{0,-2}-5 * \mathrm{~A}_{0,-1}+17 * \mathrm{~A}_{0,0}+58 * \mathrm{~A}_{0,1}-10 * \mathrm{~A}_{0,2}+4 * \mathrm{~A}_{0,3}-\mathrm{A}_{0,4}\right)>>\operatorname{shiftl} \\
  \qquad shift1 = \min \left(4, \text { BitDepth }_{L}-8\right)
  \end{array}</script></li>
<li><script type="math/tex; mode=display">
  \begin{array}{l}
  \mathrm{e}_{0,0}=\left(-\mathrm{a}_{0,-3}+4 * \mathrm{a}_{0,-2}-10 * \mathrm{a}_{0,-1}+58 * \mathrm{a}_{0,0}+17 * \mathrm{a}_{0,1}-5 * \mathrm{a}_{0,2}+\mathrm{a}_{0,3}\right)>>\operatorname{shift} 2 \\
  \mathrm{i}_{0,0}=\left(-\mathrm{a}_{0,-3}+4 * \mathrm{a}_{0,-2}-11 * \mathrm{a}_{0,-1}+40 * \mathrm{a}_{0,0}+40 * \mathrm{a}_{0,1}-11 * \mathrm{a}_{0,2}+4 * \mathrm{a}_{0,3}-\mathrm{a}_{0,4}\right)>>\operatorname{shift} 2 \\
  \mathrm{p}_{0,0}=\left(\mathrm{a}_{0,-2}-5 * \mathrm{a}_{0,-1}+17 * \mathrm{a}_{0,0}+58 * \mathrm{a}_{0,1}-10 * \mathrm{a}_{0,2}+4 * \mathrm{a}_{0,3}-\mathrm{a}_{0,4}\right)>>\operatorname{shift} 2 \\
  \mathrm{f}_{0,0}=\left(-\mathrm{b}_{0,-3}+4 * \mathrm{~b}_{0,-2}-10 * \mathrm{~b}_{0,-1}+58 * \mathrm{~b}_{0,0}+17 * \mathrm{~b}_{0,1}-5 * \mathrm{~b}_{0,2}+\mathrm{b}_{0,3}\right)>>\operatorname{shift} 2 \\
  \mathrm{j}_{0,0}=\left(-\mathrm{b}_{0,-3}+4 * \mathrm{~b}_{0,-2}-11 * \mathrm{~b}_{0,-1}+40 * \mathrm{~b}_{0,0}+40 * \mathrm{~b}_{0,1}-11 * \mathrm{~b}_{0,2}+4 * \mathrm{~b}_{0,3}-\mathrm{b}_{0,4}\right)>>\operatorname{shift} 2 \\
  \mathrm{q}_{0,0}=\left(\mathrm{b}_{0,-2}-5 * \mathrm{~b}_{0,-1}+17 * \mathrm{~b}_{0,0}+58 * \mathrm{~b}_{0,1}-10 * \mathrm{~b}_{0,2}+4 * \mathrm{~b}_{0,3}-\mathrm{b}_{0,4}\right)>>\operatorname{shift} 2 \\
  \mathrm{~g}_{0,0}=\left(-\mathrm{c}_{0,-3}+4 * \mathrm{c}_{0,-2}-10 * \mathrm{c}_{0,-1}+58 * \mathrm{c}_{0,0}+17 * \mathrm{c}_{0,1}-5 * \mathrm{c}_{0,2}+\mathrm{c}_{0,3}\right)>>\operatorname{shift} 2 \\
  \mathrm{k}_{0,0}=\left(-\mathrm{c}_{0,-3}+4 * \mathrm{c}_{0,-2}-11 * \mathrm{c}_{0,-1}+40 * \mathrm{c}_{0,0}+40 * \mathrm{c}_{0,1}-11 * \mathrm{c}_{0,2}+4 * \mathrm{c}_{0,3}-\mathrm{c}_{0,4}\right)>>\mathrm{shift} 2 \\
  \mathrm{r}_{0,0}=\left(\mathrm{c}_{0,-2}-5 * \mathrm{c}_{0,-1}+17 * \mathrm{c}_{0,0}+58 * \mathrm{c}_{0,1}-10 * \mathrm{c}_{0,2}+4 * \mathrm{c}_{0,3}-\mathrm{c}_{0,4}\right)>>\operatorname{shift} 2 \\
  \quad S h i f t 2 =\mathrm{6}
  \end{array}</script></li>
</ul>
</li>
<li>色度1/8亚像素插值<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_0b92d51dff7c5b7e2ead3cf07366117c.png" alt=""></li>
<li><script type="math/tex; mode=display">
  \begin{array}{l}
  \mathrm{ab}_{0,0}=\left(-2 * \mathrm{~B}_{-1,0}+58 * \mathrm{~B}_{0,0}+10 * \mathrm{~B}_{1,0}-2 * \mathrm{~B}_{2,0}\right)>>\text { shift1 } \\
  \mathrm{ac}_{0,0}=\left(-4 * \mathrm{~B}_{-1,0}+54 * \mathrm{~B}_{0,0}+16 * \mathrm{~B}_{1,0}-2 * \mathrm{~B}_{2,0}\right)>>\text { shift1 } \\
  \mathrm{ad}_{0,0}=\left(-6 * \mathrm{~B}_{-1,0}+46 * \mathrm{~B}_{0,0}+28 * \mathrm{~B}_{1,0}-4 * \mathrm{~B}_{2,0}\right)>>\text { shift1 } \\
  \mathrm{ae}_{0,0}=\left(-4 * \mathrm{~B}_{-1,0}+36 * \mathrm{~B}_{0,0}+36 * \mathrm{~B}_{1,0}-4 * \mathrm{~B}_{2,0}\right)>>\text { shift1 } \\
  \mathrm{af}_{0,0}=\left(-4 * \mathrm{~B}_{-1,0}+28 * \mathrm{~B}_{0,0}+46 * \mathrm{~B}_{1,0}-6 * \mathrm{~B}_{2,0}\right)>>\text { shift1 } \\
  \mathrm{ag}_{0,0}=\left(-2 * \mathrm{~B}_{-1,0}+16 * \mathrm{~B}_{0,0}+54 * \mathrm{~B}_{1,0}-4 * \mathrm{~B}_{2,0}\right)>>\text { shift1 } \\
  \mathrm{ah}_{0,0}=\left(-2 * \mathrm{~B}_{-1,0}+10 * \mathrm{~B}_{0,0}+58 * \mathrm{~B}_{1,0}-2 * \mathrm{~B}_{2,0}\right)>>\text { shift1 } \\
  \qquad \operatorname{shift} 1=\min \left(4, \text { BitDepth }_{C}-8\right)
  \end{array}</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>MV 如何表示？<ul>
<li>残差MVD: MVD = MV - MVP<ul>
<li>如何预测得到MVP？高级运动向量预测AMVP(Advanced Motion Vector Prediction)模式</li>
<li>构建候选列表，包括空域候选项和时域候选项<ul>
<li>空域候选项：按照扫描顺序，选择第一个可用的MV加入候选列表：</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_efedf839b9a5b45cdefa08a219e7c477.png" alt=""></li>
<li><blockquote>
<p>scaled：MV缩放<br><img src="https://notes.sjtu.edu.cn/uploads/upload_7674ed50f290feed171e739517d62dcd.png" alt=""></p>
</blockquote>
</li>
<li>如果空域候选项合并，不足2个候选MV，需补充时域候选项</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_6850426fe9938dcd9b6a6f9f81543180.png" alt=""></li>
<li>选择同位块C1的MV，C1不可用选C0</li>
<li>根据情况MV也需要缩放</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_d02cd040884b4fa3d1f47ce0e56861b8.png" alt=""></li>
</ul>
</li>
<li>从候选列表中的2个选择一个作为MVP</li>
<li>码流需要传输：残差，MVD, MVP idx</li>
</ul>
</li>
<li>把候选集里的MV作为当前的MV，直接传索引：Merge模式<ul>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_8f5ab8defe0044138fc1ba029fee9b50.png" alt=""></li>
<li>时域最多提供一个候选项，根据情况缩放，同上</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_6b5c50c6b68cc1b090823fdbd05c1a35.png" alt=""></li>
<li>a: 对PU2, A1无效，否则PU1 PU2相同MV，相当于没有划分PU</li>
<li>b: 对PU2, B1无效</li>
<li>从候选集选MV作为当前的MV，直接传索引</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_98f487d6413abb2637256d9bd8ed72de.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><ul>
<li>运动估计搜到的块直接作为预测块，与当前块相减得到残差</li>
<li>加权预测：通过权值因子w和偏移值offset修正预测像素<ul>
<li>默认加权预测：不用传权值</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_f4b2099173951db68527b8c7f8f85eae.png" alt=""></li>
<li>显示加权预测：需要传权值</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_9aef6d3a5f633d8470a32345e268a416.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="H-266"><a href="#H-266" class="headerlink" title="H.266"></a>H.266</h2><blockquote>
<p>运动估计：VVC中采用全搜索和TZSearch搜索算法。</p>
</blockquote>
<h3 id="AMVP"><a href="#AMVP" class="headerlink" title="AMVP"></a>AMVP</h3><p>AMVP的候选列表长度为2，候选MV总共有4种类型：</p>
<ul>
<li>基于空间相邻块的空域MVP（最多允许两个）</li>
<li>基于时域同位块的时域MVP（和Merge模式时域MV的推导相同）</li>
<li>基于历史信息构建的HMVP</li>
<li>零MV</li>
</ul>
<p>相比HEVC多了candidate：HMVP</p>
<h4 id="Symmetric-MVD-coding，SMVD"><a href="#Symmetric-MVD-coding，SMVD" class="headerlink" title="Symmetric MVD coding，SMVD"></a>Symmetric MVD coding，SMVD</h4><p>对于包含双向运动信息的AMVP模式，可以使用SMVD编码模式。</p>
<p>使用条件：</p>
<ul>
<li>AMVP候选包含双向运动信息</li>
<li>当前CU的前向参考帧列表List0中距离最近的参考图像和后向参考帧列表List1中距离最近的参考图像正好处于当前图像的两侧</li>
</ul>
<p>具体的，在编码时，仅需要编码前向MVD0，后向的MVD1可由MVD1=（-MVD0）推导得到。</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_3af769cdf454d8d5be9c3ce36c8bc259.png" alt=""></p>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><ul>
<li><p>Extended merge prediction: VVC在HEVC的基础上，扩展了Merge模式构造Merge List的方法，Merge List最多可以包含6个候选MV，构造方法如下：</p>
<ul>
<li>同HEVC: 空域MVP（最多提供4个候选MV）</li>
<li>同HEVC: 时域MVP（最多提供1个候选MV）</li>
<li><p>基于历史信息的HMVP（不限个数，直到填充到Merge List包含5个候选MV）</p>
<ul>
<li>HMVP候选项来自于一个先进先出的表，表的长度为6，这个表通过已经编码块的运动信息构建，每到新的一行CTU时，这个表就要重置，即清空操作。</li>
<li>每遇到一个帧间编码的CU（非子块）时，它相关的运动信息就会加到这个表的最后一项成为一个新的HMVP候选项。</li>
<li>每当插入一个新的候选项时，首先要进行冗余性检查即检查待插入的项的运动信息和表中已有项的运动信息是否相同，如果不相同，则按照先进先出的规则进行插入操作；如果相同，则将相同的HMVP从维护的FIFO（先进先出）表中移除，其后所有的项都向前移动一位，将待插入的候选项插入到HMVP的表的末端。</li>
<li>在使用HMVP候选项构建Merge候选列表时，按顺序检查HMVP列表中最新的HMVP候选（从后向前检查），在和Merge列表中现存的候选检查完冗余之后将不重复的HMVP候选添加到Merge列表中去。直到候选列表的长度达到5个。</li>
<li>为了减少冗余性检查操作，进行了以下的简化操作：</li>
<li>用于构建Merge list的HMVP候选项数量设为 （N&lt;=4)?M:(8-N)，其中N表示Merge list中已有项的数目，M表示HMVP表中候选项数目。一旦Merge list中候选项的数目达到了最大允许候选项数目减一（即6-1=5），则停止从HMVP生成merge候选项的过程</li>
</ul>
</li>
<li><p>成对平均MVP（由Merge List中前两个候选MV平均得到）</p>
<ul>
<li>使用Merge候选列表中前两个候选项对来生成成对平均候选。Merge列表中的第一项和第二项分别定义为p0Cand和p1Cand。对于每个参考帧列表，分别根据p0Cand和p1Cand的MV是否可用来计算平均MV。即：</li>
<li>如果两个MV在一个列表中可用，则即使这两个MV指向不同的参考帧，也对它们进行平均，并且其参考帧被设置为p0Cand对应的参考帧；</li>
<li>如果只有一个MV可用，直接使用那一个；</li>
<li>如果没有可用的运动矢量，则保持此列表无效。</li>
<li>如果p0Cand和p1Cand的半像素插值滤波器指数不同，则将其滤波器指数设置为0。</li>
</ul>
</li>
<li><p>零MV</p>
<ul>
<li>如果计算完平均候选项后Merge还未填满，则用0MV填充候选列表，直到候选列表达到最大长度。</li>
</ul>
</li>
</ul>
</li>
<li><p>Merge mode with MVD：VVC在常规Merge模式基础上，增加了“运动矢量差的”Merge模式。</p>
<ul>
<li>该模式是将常规Merge模式构建得到的Merge列表中的前两个候选MV作为初始MV，在上下左右四个方向上，进行8种步长的搜索，即在初始MV基础上加上一定的偏移MVD得到2x4x8=64个MV，并从中选出RD-Cost最小的MV作为最终的细化MV。</li>
<li>在编码端，将初始MV在Merge List中的索引、搜索方向索引和搜素步长索引传给解码端。</li>
</ul>
</li>
<li><p>Skip：Skip模式是一种特殊的Merge模式。</p>
<ul>
<li>若当前CU被标识为Skip模式，则编码器只需要传送选中的Merge候选索引，而不需要传输变换量化后的残差。相应的在解码器只需要解析出该索引下的运动信息，然后通过运动补偿得到的预测像素值直接作为重建像素值。</li>
</ul>
</li>
<li><p>Non regular merge with CIIP</p>
</li>
<li>Non regular merge with GPM</li>
<li>Sub block merge list based TMVP (SbTMVP)</li>
</ul>
<h3 id="Affine"><a href="#Affine" class="headerlink" title="Affine"></a>Affine</h3><h4 id="Affine基础知识"><a href="#Affine基础知识" class="headerlink" title="Affine基础知识"></a>Affine基础知识</h4><ul>
<li>仿射变换（Affine Transformation）是另外两种简单变换的叠加：线性变换 R，平移变换 T</li>
</ul>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{ccc}
R_{00} & R_{01} & T_{x} \\
R_{10} & R_{11} & T_{y} \\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]</script><ul>
<li><p>仿射变换变化包括：</p>
<ul>
<li>平移(translation)、缩放（Scale）</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_8bda874759b95f9e70ab5012e75c1ca1.png" alt=""></li>
<li>旋转(rotate)、shear mapping</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_119aacd43276edef7f0ce05aff892988.png" alt=""></li>
<li>反射（reflection）</li>
<li><img src="https://notes.sjtu.edu.cn/uploads/upload_715adf0217a1225716d480b19c032397.png" alt=""></li>
</ul>
</li>
<li><p>仿射变换中集合中的一些性质保持不变：<br>（1）凸性<br>（2）共线性：若几个点变换前在一条线上，则仿射变换后仍然在一条线上<br>（3）平行性：若两条线变换前平行，则变换后仍然平行<br>（4）共线比例不变性：变换前一条线上两条线段的比例，在变换后比例不变</p>
</li>
</ul>
<h4 id="VVC中引入了基于块的仿射运动补偿技术"><a href="#VVC中引入了基于块的仿射运动补偿技术" class="headerlink" title="VVC中引入了基于块的仿射运动补偿技术"></a>VVC中引入了基于块的仿射运动补偿技术</h4><p>之前的帧间预测的运动估计仅考虑了简单的平移运动，无法有效表示缩放等。</p>
<p>VVC中引入了基于块的放射运动补偿技术，利用块中的两个控制点（四参数模型）或者三个控制点（六参数模型）的MV，来推导出整个块中每个4x4子块的MV，之后分别根据每个子块的MV通过运动补偿得到每个子块的预测值。</p>
<p>基于块的仿射运动补偿方式如下：<br>1.首先将块划分为4x4的亮度子块。<br>2.对每个亮度子块按下式，由控制点的MV(CPMV)计算其中心像素$(x, y)$的MV，然后四舍五入到1/16精度。</p>
<ul>
<li>四参数模型</li>
</ul>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
m v_{x}=\frac{m v_{1 x}-m v_{0 x}}{W} x+\frac{m v_{1 y}-m v_{0 y}}{W} y+m v_{0 x} \\
m v_{y}=\frac{m v_{1 y}-m v_{0 y}}{W} x+\frac{m v_{1 y}-m v_{0 x}}{W} y+m v_{0 y}
\end{array}\right.</script><ul>
<li>六参数模型</li>
</ul>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
m v_{x}=\frac{m v_{1 x}-m v_{0 x}}{W} x+\frac{m v_{2 x}-m v_{0 x}}{W} y+m v_{0 x} \\
m v_{y}=\frac{m v_{1 y}-m v_{0 y}}{W} x+\frac{m v_{2 y}-m v_{0 y}}{H} y+m v_{0 y}
\end{array}\right.</script><p>$（mv_{0x}，mv_{0y}）$ 是左上角控制点的MV，$（mv_{1x}，mv_{1y}）$是右上角控制点的MV，$（mv_{2x}，mv_{2y}）$是左下角控制点的MV。这些MV根据已编码的块的运动信息，用RDO选出来的</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_8a7f3a6bf699f65854c43c2ae4da036c.png" alt=""></p>
<p>3.每个子块计算出运动向量后（如下图），根据运动向量进行运动补偿插值滤波得到每个子块的预测值。</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_1b184a635c2ef24eac3947ba815726b0.png" alt=""></p>
<p>色度分量也划分为4x4的子块。 将4×4色度子块的MV计算为其相应的8x8亮度区域中左上和右下亮度子块的MV的平均值。</p>
<p>和传统的帧间预测模式类似，Affine模式也分为Affine Merge模式和Affine AMVP模式。</p>
<h5 id="Affine-Merge"><a href="#Affine-Merge" class="headerlink" title="Affine Merge"></a>Affine Merge</h5><blockquote>
<p>Affine Merge 通过相邻块的MV得到当前块的MV；</p>
</blockquote>
<ul>
<li>对于宽度和高度都大于或等于8的CUs，可以采用AF_MERGE模式。</li>
<li>在AF_MERGE下，当前CU的CPMV（CPMV, control point motion vector）是基于空间相邻CU的运动信息生成的。</li>
<li>最多可以有五个CPMVP候选，并用一个索引指示当前CU使用的索引。</li>
<li>以下三种类型的CPVM候选者用于形成Affine Merge候选列表：<ul>
<li>继承Affine Merge候选项：继承其相邻CU的CPMV候选项</li>
<li>构造Affine Merge候选项：使用相邻CU的平移运动的MVs构造CPMVPs候选项</li>
<li>零MVs</li>
</ul>
</li>
</ul>
<h5 id="Affine-AMVP"><a href="#Affine-AMVP" class="headerlink" title="Affine AMVP"></a>Affine AMVP</h5><ul>
<li>Affine AMVP 根据相邻块的MV预测当前MV，得MVP，再以预测的CPMV作为搜索起点进行运动估计，得到最佳的CPMV，并将二者的差值和预测CPMV在候选列表中的索引传给解码端。</li>
</ul>
<ul>
<li><p>Affine AMVP模式可应用于宽度和高度均大于或等于16的CU。在比特流中发信号通知CU级别的Affine标志以指示是否使用Affine AMVP模式，然后发信号通知另一个标志以指示是4参数Affine或6参数Affine模型。</p>
</li>
<li><p>在Affine AMVP模式下，需要传输其预测CPMV在候选列表中的索引以及它和运动搜索得到的实际CPMV的残差。Affine AVMP候选列表大小为2，它通过依次使用以下5种CPMV候选类型生成：</p>
<ul>
<li>继承AMVP候选项：继承其相邻CU的CPMV候选项<ul>
<li>其构建方法与Affine Merge继承AMVP候选项相同。 唯一的区别是，对于AVMP候选项，相邻CU的参考帧必须和当前帧一样。 将继承的AMVP候选项插入候选列表时，不应用修剪过程。</li>
</ul>
</li>
<li>构造Affine AMVP候选项：使用相邻CU的平移运动的MVs构造CPMVPs候选项</li>
<li>直接使用相邻CU的平移MV</li>
<li>同位块的时域MV</li>
<li>零MV</li>
</ul>
</li>
</ul>
<p>构造Affine候选项的产生和Affine Merge构造方法一样。 并且需要检查相邻块的参考图片索引,要选择扫描顺序中第一个帧间编码且和当前CU有相同参考图像的块。 当当前CU用4参数Affine模式编码时，mv0和mv1都可用时，才把它们加入Affine AMVP候选列表。 当当前CU用6参数Affine模式编码时，并且所有三个CPMV均可用时，才把它们加入Affine AMVP候选列表。 否则，将构造的AMVP候选项设置为不可用。</p>
<ul>
<li><p>如果在插入类型1和类型2的AMVP候选项之后，Affine AMVP列表候选项仍小于2，则将按顺序将平移运动MV mv0, mv1 和 mv2 (第i个MV存在时,i=0,1,2)作为当前CU所有控制点的MV。</p>
</li>
<li><p>如果Affine AMVP列表仍小于2且开启时域MV预测，则使用同位块的时域MV作为当前所有控制点的MV。其时域MV的获取和常规Merge模式一致。</p>
</li>
</ul>
<h5 id="SbtMVP"><a href="#SbtMVP" class="headerlink" title="SbtMVP"></a>SbtMVP</h5><h3 id="Adaptive-motion-vector-resolution，AMVR"><a href="#Adaptive-motion-vector-resolution，AMVR" class="headerlink" title="Adaptive motion vector resolution，AMVR"></a>Adaptive motion vector resolution，AMVR</h3><p>由于实际运动通常是连续的，因此整像素精度通常不能很好地表示物体的运动。</p>
<ul>
<li>在HEVC中，亮度分量的运动矢量使用1/4像素精度，色度分量的运动矢量使用1/8像素精度；</li>
<li>在VVC中，进一步提高了像素精度，亮度分量的运动矢量使用1/16像素精度，色度分量的运动矢量使用1/32像素精度。</li>
</ul>
<p>随着像素精度的增长，预测精度增长，但随之需要大量的编码比特。</p>
<p>综合考虑预测精度和编码比特消耗，VVC提出了自适应运动矢量精度AMVR技术，在CU级对亮度分量MVD采用不同的像素精度进行编码。</p>
<p>根据当前CU<strong>帧间预测模式</strong>的不同，亮度分量MVD编码精度有不同的选取策略：</p>
<ul>
<li>常规AMVP模式：1/4亮度像素精度，1/2亮度像素精度，整数亮度像素精度或四倍亮度像素精度。</li>
<li>仿射AMVP模式：1/4亮度像素精度，整数亮度像素精度或1/16亮度像素精度。</li>
</ul>
<p>在编码端，需要比较各个精度下的RD-Cost并选出代价最小的编码精度作为当前CU的最优精度。为了降低编码端复杂度，避免对每个MVD精度进行四次（Affine AMVP为三次）CU级的率失真代价的比较，在VVC中使用一些快速算法来跳过除了1/4精度以外某些MVD精度的率失真代价检查。</p>
<h3 id="预测：帧间加权预测"><a href="#预测：帧间加权预测" class="headerlink" title="预测：帧间加权预测"></a>预测：帧间加权预测</h3><blockquote>
<p>在HEVC中，通过对从两个不同参考帧获得的两个预测信号求平均和/或使用两个不同运动矢量来生成双向预测信号。但实际中，同一内容随着时间的变化有可能会产生光线强弱变化或阴影等现象，导致不同帧之间背景相似度很大，但是明暗差别较大，采用简单的平均方式预测误差较大。</p>
</blockquote>
<p>HEVC中使用了帧级加权预测WP技术，VVC在此基础上，引入了CU级双向加权预测技术。</p>
<ul>
<li>CU级双向加权预测(Bi-prediction with CU-level weight，BCW)</li>
<li>加权预测（WP）</li>
</ul>
<h3 id="解码端技术：帧间预测后处理"><a href="#解码端技术：帧间预测后处理" class="headerlink" title="解码端技术：帧间预测后处理"></a>解码端技术：帧间预测后处理</h3><p>为了进一步提高帧间预测的准确性，VVC采用了多种帧间预测后处理技术值，以修正帧间预测的预测像素，提高预测性能。主要包含三个：</p>
<ul>
<li>DMVR(Decoder side motion vector refinement，DMVR)技术：用于修正常规Merge模式双向预测MV，以Merge列表中的双向MV为初始MV，在一定范围内进行镜像搜索，以获得更精确的MV。</li>
<li>BDOF(Bi-directional optical flow，BDOF)技术：使用双向光流技术来修正双向预测的预测值。</li>
<li>PROF(Prediction refinement with optical flow for affine mode,PROF)技术：使用光流技术来细化基于子块的Affine运动补偿预测。</li>
</ul>
<p>参考：<a href="https://blog.csdn.net/bigdream123/article/details/119742552">https://blog.csdn.net/bigdream123/article/details/119742552</a></p>
]]></content>
      <tags>
        <tag>video coding</tag>
      </tags>
  </entry>
</search>
