<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/06/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a></p>
</blockquote>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode/链表</title>
    <url>/2021/07/07/Leetcode-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>常用数据结构—链表</p>
</blockquote>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">// 设预指针pre的下一个节点指向head，防止空节点</span></span><br><span class="line">ListNode pre = <span class="keyword">new</span> ListNode(); </span><br><span class="line">pre.next = head;</span><br><span class="line"><span class="comment">// 设置动态当前指针cur</span></span><br><span class="line">ListNode cur = head; </span><br></pre></td></tr></table></figure>
<p>19/剑指 Offer 22 删除链表的倒数第 N 个结点（快慢指针）</p>
<p>61 旋转链表（快慢指针）</p>
<p>剑指 Offer 06. 从尾到头打印链表（栈）</p>
<p>21/ 剑指 Offer 25 合并两个有序链表</p>
<p>24 两两交换链表中的结点</p>
<p>剑指 Offer 18. 删除链表的节点</p>
<p>83 删除排序链表中的重复元素(相同节点保留一个)</p>
<p><strong>82 删除排序链表中的重复元素 II(相同节点全部删除)</strong></p>
<p>86 分隔链表</p>
<p>206/剑指 Offer 24. 反转链表</p>
<p>92 反转链表 II</p>
<p><strong>138/剑指 Offer 35. 复杂链表的复制</strong></p>
<ul>
<li><strong>hashmap</strong></li>
</ul>
<p><strong>剑指 Offer 52. 两个链表的第一个公共节点</strong></p>
<ul>
<li><strong>集合set</strong></li>
<li><strong>快慢指针（先统计两个链表的长度，如果长度不一样，让链表长的先走，直到两个链表长度一样，这此时两个链表同时每次后移一步，看节点是否一样）</strong></li>
<li><strong>双指针</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>hexo配置</title>
    <url>/2021/07/07/hexo/</url>
    <content><![CDATA[<blockquote>
<p>hexo，快速、简洁且高效的博客框架</p>
</blockquote>
<span id="more"></span>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="regexp">//</span> 清除缓存</span><br><span class="line">hexo g <span class="regexp">//</span> 创建静态文件</span><br><span class="line">hexo s <span class="regexp">//</span> 本地运行</span><br><span class="line">hexo d <span class="regexp">//</span> 部署到远程</span><br></pre></td></tr></table></figure>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>主题文件夹放在<code>./theme/</code> 下，<code>_config.yml</code> 中<code>theme:</code> 改成主题文件夹名</p>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>文章存放路径<code>/source/_posts/*.md</code></p>
<ul>
<li>文章头部</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="string">/8/3</span> <span class="number">18</span><span class="string">:20:00</span> <span class="string">//发布时间</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">hexo</span> <span class="string">//分类</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span> <span class="string">//使用mathjax渲染公式</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">hexo博客</span> <span class="string">//标题</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文章折叠</li>
</ul>
<p>需要折叠的部分之前加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>公式</li>
</ul>
<p>卸载原有公式渲染引擎 <code>npm uninstall hexo-renderer-marked --save</code> </p>
<p>安装kramed <code>npm install hexo-renderer-kramed --save</code></p>
<blockquote>
<p>问题1：kramed对<code>\,&#123;,&#125;</code>有转义，无法正常显示</p>
<p>解决方法：</p>
<p>定位到博客根目录，找到<code>/node_modules/kramed/lib/rules/inline.js</code>文件，进行部分修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,      第11行，将其修改为</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    第20行，将其修改为</span></span><br><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<p>问题2：公式中以下符号会解析错误<code>&#123;&#123;` `&#125;&#125;</code> <code>&#123;%` `%&#125;</code></p>
<p>解决方法：中间加空格，变为<code>&#123; &#123;</code> <code>&#125; &#125;</code> <code>&#123; %</code> <code>% &#125;</code></p>
</blockquote>
<ul>
<li>图片居中(md支持html语法)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/img/...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="多分支管理"><a href="#多分支管理" class="headerlink" title="多分支管理"></a>多分支管理</h2><p>同时管理了两个分支：</p>
<ul>
<li>master -负责展示静态网页</li>
<li>hexo -备份本地hexo文件（默认分支）</li>
</ul>
<p>执行<code>hexo d</code>时，自动更新master分支（config文件中deploy配置）</p>
<p>add, commit, pull更新hexo分支需要备份的源文件</p>
<h2 id="中文目录无法跳转"><a href="#中文目录无法跳转" class="headerlink" title="中文目录无法跳转"></a>中文目录无法跳转</h2><p><a href="https://github.com/theme-next/hexo-theme-next/pull/1540/files">fix: Chinese TOC cannot jump by jiangtj · Pull Request #1540 · theme-next/hexo-theme-next (github.com)</a></p>
<p>解决方法：在 <code>themes/next/source/js/util.js</code> 中增加两行代码，删除两行代码。保存后<code>hexo clean &amp; hexo g &amp; hexo s</code> 即可解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> navItems = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.post-toc li&#x27;</span>);</span><br><span class="line">   <span class="keyword">const</span> sections = [...navItems].map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> link = element.querySelector(<span class="string">&#x27;a.nav-link&#x27;</span>);</span><br><span class="line">     <span class="comment">//增加该行</span></span><br><span class="line">     <span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(<span class="built_in">decodeURI</span>(link.getAttribute(<span class="string">&#x27;href&#x27;</span>)).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">     <span class="comment">// TOC item animation navigate.</span></span><br><span class="line">     link.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">       event.preventDefault();</span><br><span class="line">       <span class="comment">//删除该行</span></span><br><span class="line">       <span class="comment">//var target = document.getElementById(event.currentTarget.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">       <span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">       <span class="built_in">window</span>.anime(&#123;</span><br><span class="line">         <span class="attr">targets</span>  : <span class="built_in">document</span>.scrollingElement,</span><br><span class="line">         <span class="attr">duration</span> : <span class="number">500</span>,</span><br><span class="line">         <span class="attr">easing</span>   : <span class="string">&#x27;linear&#x27;</span>,</span><br><span class="line">         <span class="attr">scrollTop</span>: offset + <span class="number">10</span></span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">// 删除该行 </span></span><br><span class="line">     <span class="comment">//return document.getElementById(link.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">     <span class="comment">// 增加该行</span></span><br><span class="line">     <span class="keyword">return</span> target;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>无法解决的问题尝试清除缓存<code>hexo clean</code>后重新生成</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA/代理模式</title>
    <url>/2021/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>代理模式的一个典型应用：AOP(面向切面编程)</p>
</blockquote>
<span id="more"></span>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>a类本来需要调用c类（目标类）的方法完成某个功能， 但是c不让a调用。 </p>
<p>a —&gt;不能直接调用 c的方法。<br>在a 和 c 直接创建一个 b 代理，c让b访问。 c，b实现相同的功能（接口）。<br>a —&gt;访问b—&gt;访问c</p>
<p>作用：</p>
<ul>
<li><p>功能增强： 在原有的功能上，增加了额外的功能。 新增加的功能，叫做功能增强</p>
</li>
<li><p>控制访问： 代理类不让你访问目标，例如商家不让用户访问厂家。 </p>
</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>代理类需要手工实现。即自己创建一个java类，表示代理类。所要代理的目标类是确定的。</p>
<ul>
<li>缺点：当目标类和代理类很多时候，<ul>
<li>当目标类增加， 代理类可能也需要成倍的增加。 代理类数量过多。</li>
<li>当接口中功能增加或修改，会影响众多的实现类，厂家类，代理类都需要修改。影响较大。</li>
</ul>
</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在程序执行过程中，使用jdk的<strong>反射</strong>机制，创建<strong>代理类对象</strong>， 并动态的指定要代理目标类。</p>
<p>即使目标类很多，代理类数量可以很少；当修改了接口中的方法时，不影响代理类。</p>
<p>动态代理是一种创建java对象的能力，不用创建代理类，就能创建代理类对象。</p>
<p>两种实现方式：jdk动态代理；cglib动态代理</p>
<h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><ul>
<li>使用java反射包中的类和接口实现动态代理的功能。</li>
<li>反射包 java.lang.reflect , 里面有三个类 ： InvocationHandler , Method, Proxy.</li>
<li>要求目标类实现接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用反射调用方法</span></span><br><span class="line">HelloService service = <span class="keyword">new</span> HelloServiceImpl(); <span class="comment">//创建类对象service</span></span><br><span class="line">service.sayHello(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 通过对象调用sayHello()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反射调用方法</span></span><br><span class="line">Method method =  HelloService.class.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class); <span class="comment">// 获取method对象（sayHello()方法）</span></span><br><span class="line">HelloService service2 = <span class="keyword">new</span> HelloServiceImpl2();</span><br><span class="line">Object ret = method.invoke(service2, <span class="string">&quot;李四&quot;</span>); <span class="comment">// invoke()方法调用对象service2的方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>InvocationHandler接口，只有一个方法invoke()，代理对象要完成的功能。（目标方法/功能增强）</li>
<li>Method类：表示目标类中的方法。通过Method可以执行某个目标类的方法，method.invoke(目标对象，方法的参数)</li>
<li>Proxy类：创建代理对象。之前创建对象是 new ，现在使用Proxy类的静态方法 newProxyInstance() 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现InvocationHandler接口，完成代理类要做的功能（1.调用目标方法，2.功能增强）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySellHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>; <span class="comment">// 为目标类创建对象（活动的，不是固定的，需要传入进来）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySellHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 实现invoke方法，完成代理类要做的功能</span></span><br><span class="line">    <span class="comment">// Object proxy: jdk创建的代理对象，无需赋值。</span></span><br><span class="line">	<span class="comment">// Method method: 目标类中的方法，jdk提供</span></span><br><span class="line">    <span class="comment">// Object[] args：目标类中方法的参数， jdk提供。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object res  = <span class="keyword">null</span>;</span><br><span class="line">        res =  method.invoke(target,args); <span class="comment">// 反射，执行目标对象target的method方法</span></span><br><span class="line">		<span class="comment">//功能增强，加价</span></span><br><span class="line">        <span class="keyword">if</span>( res != <span class="keyword">null</span> )&#123;</span><br><span class="line">            Float price = (Float)res;</span><br><span class="line">            price = price + <span class="number">25</span>;</span><br><span class="line">            res = price;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建代理对象，使用Proxy</span></span><br><span class="line"><span class="comment">//1. 创建目标对象</span></span><br><span class="line">UsbSell factory = <span class="keyword">new</span> UsbKingFactory();</span><br><span class="line"><span class="comment">//2.创建InvocationHandler对象</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MySellHandler(factory);</span><br><span class="line"><span class="comment">//3.创建代理对象</span></span><br><span class="line">UsbSell proxy = (UsbSell) Proxy.newProxyInstance(</span><br><span class="line">    factory.getClass().getClassLoader(),</span><br><span class="line">    factory.getClass().getInterfaces(),</span><br><span class="line">    handler</span><br><span class="line">	);</span><br><span class="line"><span class="comment">//4.通过代理执行方法</span></span><br><span class="line"><span class="keyword">float</span> price = proxy.sell(<span class="number">1</span>); <span class="comment">// 代理对象proxy调用目标类factory中的sell方法</span></span><br></pre></td></tr></table></figure>
<h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><ul>
<li><p>cglib是第三方的工具库， 创建代理对象。</p>
</li>
<li><p>原理是继承， cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法， 实现功能的修改。要求目标类不能是final的， 方法也不能是final的。</p>
</li>
<li><p>cglib的要求目标类比较宽松， 只要能继承即可。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>图与网络/双计数</title>
    <url>/2021/07/06/%E5%8F%8C%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>双计数狭义上讲，对于一个集合运用两种不同的方式（行 / 列），得到等式结果或者不等式的结果。</p>
</blockquote>
<span id="more"></span>
<h2 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a>握手定理</h2><blockquote>
<p>对于图$G=(V, E)$，有</p>
<script type="math/tex; mode=display">
\sum_{v\in V}d(v) = 2|E|</script></blockquote>
<p>证明：对图G的邻接矩阵中1的个数分别从行（左），列（右）进行计数。即对二元组$\{(v,e)|v\in e\}$进行计数。</p>
<blockquote>
<p>推论：图中奇度点数目为偶数。</p>
<p>超图握手定理：对于超图$G=(V, B)$</p>
</blockquote>
<script type="math/tex; mode=display">
\sum_{v\in V}d(v) = \sum_{\beta\in B}|\beta|</script><h2 id="完全图边的双计数"><a href="#完全图边的双计数" class="headerlink" title="完全图边的双计数"></a>完全图边的双计数</h2><script type="math/tex; mode=display">
\sum_{i=1}^S{n_i} = n</script><script type="math/tex; mode=display">
{n\choose 2} = \sum_{i = 1}^S {n_i \choose 2}+\sum_{i<j}n_in_j</script><p>对于一个完全图，共有$n\choose 2$条边；</p>
<p>将完全图划分为$S$部分，每部分有$n_i$个点，${n_i \choose 2}$条边；</p>
<p>每部分之间有$n_in_j$条边。</p>
<h2 id="等式证明"><a href="#等式证明" class="headerlink" title="等式证明"></a>等式证明</h2><script type="math/tex; mode=display">
{n\choose k } = \frac{n}{k}{n-1 \choose k-1}</script><p>证明：设$A$为$k$元子集，对二元组$\{(x,A)|x\in A, |A| = k\}$进行计数。</p>
<script type="math/tex; mode=display">
\sum_{k = 1}^n k{n\choose k} = n \sum_{k = 1}^n { {n-1}\choose {k-1} } = n2^{n-1}</script><p>证明：设$A$为$k$元子集，$k=1,2,…,n$，对二元组$\{(x,A)|x\in A, |A| = k\}$进行计数。</p>
<script type="math/tex; mode=display">
{n \choose k}{k \choose l} = {n \choose l} { {n-1}\choose {k-l} }</script><p>证明：设$A$为$l$元子集，$B$为$k$元子集，对二元组$\{(A,B)||A|=l,|B|=k,A\subseteq B\}$进行计数。</p>
<h2 id="Turan-Number"><a href="#Turan-Number" class="headerlink" title="Turan Number"></a>Turan Number</h2><script type="math/tex; mode=display">
T(n,k,l)\geq \frac{n\choose l}{k \choose l}</script><blockquote>
<p>图兰数$T(n,k,l) (l\leq k \leq n)$是$n$元集合$X$的$l$元子集的最小值(下界)，使得$X$的每个$k$元子集至少包含一个这样的l元子集。</p>
</blockquote>
<p>证明：设$F$为满足条件的l元子集，记$F=\{A_1，A_2，…\}$，此时可用关联矩阵表示，$A_i$为满足条件的$l$元集合，$B_i$为$ k$元子集，若$A_i$在$B_i$上，则为$1$，就可以得到一个$0-1$矩阵。对矩阵中$1$的个数计数。</p>
<p>行计数：对于某一个$l$元集合，有$\binom{n-l}{k-l}]$个$k$元集合包含它，共有$|F|$个，行计数$1$的个数为$|F|\binom{n-l}{k-l}$</p>
<p>列计数：每个$B_i$必包含一个$A_i$，则每一列至少有一个$1$，可以得到$|F|\binom{n-l}{k-l} \geq {n\choose k}$</p>
<h2 id="Zarankiewicz’s-problem"><a href="#Zarankiewicz’s-problem" class="headerlink" title="Zarankiewicz’s problem"></a>Zarankiewicz’s problem</h2><blockquote>
<p>对于一个$n\times n$的$0-1$矩阵，如果不存在$a\times a$的全$1$子矩阵，那么这个$nxn$的矩阵最多有多少个1？</p>
<p>等价于：用二部图重新表述这个问题。一个部分大小为$n$的二部图$G=(V_1,V_2,E)$，其中$V_1,V_2$是顶点的不相交$n$元集合，$E\in V_1\times V_2$是边的集合。令$K_a(n)$为最小整数$k$边，使得任意大小为$n$且边数大于k的二部图至少包含一个$a\times a-clique$。对于任意的自然数$n$和$a$，</p>
</blockquote>
<script type="math/tex; mode=display">
K_a(n) \leq (a-1)^{\frac{1}{a} }n^{2-\frac{1}{a} }+(a-1)n</script><p>对$S= \{(x,A)|x\in V_1,A \in V_2,|A|=a,且x与A中所有点都有边相连\}$计数, 即对下图中的结构进行计数。</p>
<div align="center">
    <img src="/img/0607-1.png" style="zoom:33%;">
</div>

<p>固定$x$：从与$x$相连的元素中取$A$，设$x$的neighbor为$d(x)$，那么A有$\sum_{x\in V_1}\binom{d(x)}{a}$种选法，且$|S|=\sum_{x\in V_1}\binom{d(x)}{a}$</p>
<p>固定$A$：从$n$中选出$a$元集合，与之对应相连的$x$最多有$(a-1)$个，否则就会出现$a\times a-clique$，即$|S| \leq \binom{n}{a}(a-1)$</p>
<p>即$\sum_{x\in V_1}\binom{d(x)}{a}\leq \binom{n}{a}(a-1)$</p>
<blockquote>
<p>Jensen不等式，对凸函数有：</p>
<script type="math/tex; mode=display">
s.t.\sum_{i=1}^n\lambda_i = 1</script><script type="math/tex; mode=display">
\sum_{i=1}^n\lambda_if(x_i)\geq f(\sum_{i=1}^n\lambda_ix_i),</script><p>Jensen不等式可由数学归纳法证明，略。</p>
</blockquote>
<p>令$f(x)=\binom{x}{a}$,$x_i=d(x_i)$;</p>
<p>根据Jensen不等式，有</p>
<p>$\frac{1}{n}\sum_{x\in V_1}\binom{d(x)}{a}\geq \binom{\frac{1}{n}\sum_{x\in V_1}d(x)}{a}$</p>
<p>$\sum_{x\in V_1}\binom{d(x)}{a}\geq n\binom{\frac{1}{n}\sum_{x\in V_1}d(x)}{a}=n\binom{\frac{|E|}{n} }{a}$(因为为二部图，则degree为一倍边数)</p>
<p>即$n\binom{\frac{|E|}{n} }{a}\leq \binom{n}{a}(a-1)$</p>
<p>经过放缩有$n(\frac{|E|}{n}-(a-1))^a&lt;\frac{n(|E|/n)(|E|/n-1)…(|E|/n-(a-1))}{a!}=n\binom{\frac{|E|}{n} }{a}$</p>
<p>$\binom{n}{a}(a-1)=\frac{n(n-1)…(n-(a-1))}{a!}(a-1)&lt;\frac{n^a}{a!}(a-1)$，两边同时开a次方即可解。</p>
<ul>
<li>$K_a(n)$的下界可以用概率方法求得</li>
</ul>
<h2 id="H-free图"><a href="#H-free图" class="headerlink" title="H-free图"></a>H-free图</h2><blockquote>
<p>一个有$n$个顶点的无$H$图可以最多有多少条边?</p>
<p>定理：如果图$G=(V，E)$中不包含4个点的圈, 即$C_4-free$，那么有$|E|\leq \left \lfloor n/4(1+\sqrt{4n-3}) \right \rfloor$</p>
</blockquote>
<p>令点集$V={1，2，…，n}$，用于双计数的集合为$S=\{(u,\{v,w\})|u与v,w都邻接，且v≠w\}$，即对下图中的结构进行计数。</p>
<div align="center">
    <img src="/img/0607-1.png" style="zoom:33%;">
</div>

<p>固定$u$,那么$v$和$w$只能在度为$d(u)$的点中选取，即$\binom{d(u)}{2}$，有$\sum _{u\in V}\binom{d(u)}{2}=|S|$；</p>
<p>固定$v$和$w$，最多只有一个点可以和它们都关联，那么有$\binom{n}{2}\geq |S|$，</p>
<p>那么，$\sum _{u\in V}d^2(u)\leq \sum _{u\in V}d(u)+n(n-1)$,</p>
<blockquote>
<p>柯西—施瓦茨不等式，$|(\alpha ,\beta )|\leq ||\alpha ||*||\beta ||$</p>
<p>上述不等式中对应的分别是$[d(u_1),d(u_2)….d(u_n)]$，$(1,1,…1)$。</p>
</blockquote>
<p>由柯西—施瓦茨不等式得，$n\sum_{u\in V}d^2(n)\geq (\sum_{u\in V}d(n)*1)^2$，代入上式，$\frac{(\sum_{u\in V} d(u))^2}{n}\leq \sum_{u\in V}d(u)+n)n-1$，</p>
<p>由握手定理得$4|E|^2\leq n2|E|+n^2(n-1)$，求解n可得上述结论。</p>
<h2 id="三计数"><a href="#三计数" class="headerlink" title="三计数"></a>三计数</h2><blockquote>
<p>在超图中，有</p>
<script type="math/tex; mode=display">
\sum_{x\in X}d^2(x)=\sum_{A\in F} \sum_{x\in A}d(x)=\sum_{A\in F} \sum_{B\in F}|A\cap B|</script></blockquote>
<p>对于集合$(X,F)$，$X$为点集合，$F$为超边集合，对三元组${(x,A,B)|A,B∈F,x∈A，x∈B}$计数。</p>
<p>左：$x$在全集$X$上，$A，B$集合均包含点$x$；</p>
<p>中：先选出在$A$的$x$，再使得$x$在$B$中；</p>
<p>右：先选出$A$和$B$集合，使得$x$在$A$和$B$上，即在$A\cap B$上。</p>
<h2 id="整除关系"><a href="#整除关系" class="headerlink" title="整除关系"></a>整除关系</h2><blockquote>
<p>假设两个有限集$R$和$C$和一个子集$S\subseteq R\times C$。无论何时$(p，g)∈s $那么认为$p$和$q$是关联的。</p>
<p>设$r_p$表示$p$固定，与$p$关联的元素数目；$c_p$表示$q$固定，与$q$关联的元素数目。有</p>
<script type="math/tex; mode=display">
\sum_{p\in R}r_p=|S|=\sum_{q\in C}c_q</script></blockquote>
<p>假设$M_{|p|\times |q|}$的关联矩阵使用双计数进行证明，矩阵中若$p_i$和$q_j$相关联，$a_{ij}$则置为$1$，否则为$0$，那么$|S|$就是矩阵$M$中全部$1$的个数，等式的第一项可从行计数，最后一项可从列计数角度统计矩阵中1的个数。</p>
<p>例：</p>
<p>$R=C={1，2，…，n}$，集合$S=\{(i,j)|i可以整除j\}$，</p>
<p>$t(j)$表示$j$的因子的数目，如$j=4$，因子有$1,2,4$，那么$t(4)=3$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i/j</th>
<th style="text-align:center">1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
\overline{t(j)}=\frac{1}{n}\sum_{j=1}^{n}t(j)=\frac{1}{n}\sum_{i=1}^{n}\left \lfloor n/i \right \rfloor</script><script type="math/tex; mode=display">
\frac{1}{n}\sum_{i=1}^{n}(\frac{n}{j}-1)<\frac{1}{n}\sum_{i=1}^{n}\left \lfloor n/i \right \rfloor\leq \frac{1}{n}\sum_{i=1}^{n}\frac{n}{i}=\sum_{i=1}^{n}\frac{1}{i}</script><script type="math/tex; mode=display">
\sum_{i=1}^{n}\frac{1}{i}-1 < t(j) \leq lnn</script><script type="math/tex; mode=display">
|\overline{t(j)}-lnn|<1</script><h2 id="Sperner-Lemma"><a href="#Sperner-Lemma" class="headerlink" title="Sperner Lemma"></a>Sperner Lemma</h2><blockquote>
<p>假设某个顶点为$V1、V2、V3$的“大”三角形被三角化了(也就是说，被分解成有限数量的“小”三角形，这些“小”三角形每条边都能拼接在一起)。</p>
<p>假设三角化中的顶点从集合$\{1,2,3\}$中获取颜色，使得$V_i$接收颜色$i$(对于每个$i$)，并且沿着$V_i$到$V_i$的边的顶点只用$i$和$j$的颜色，而内部顶点用1、2或3的颜色任意着色。那么在三角测量中一定有一个小的“三色”三角形。</p>
</blockquote>
<div align="center">
    <img src="/img/0607-3.png">
</div>


<p><strong>证明：</strong></p>
<p>假定大三角形外部有一点$A$，每一个小三角形中心都有一个顶点$O$，若小三角形含有1，2顶点，则从$O$经过1，2点构成的边形成一条边(即出度)，如下图</p>
<div align="center">
    <img src="/img/0607-4.png">
</div>


<p>根据握手定理可知，度之和必为偶数， 在$V_1$和$V_2$构成的边上，观察可得出度必为奇数，即边上(1,2).(2,1)的线段必有奇数个，那么在小三角形必存在奇数度的三角形，即必存在1度的三角形，得证。</p>
<p>参考：<a href="https://www.it610.com/article/1295411404924329984.htm">【图论学习笔记二】双计数(Double Counting) - it610.com</a></p>
]]></content>
      <tags>
        <tag>图与网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA/JDBC</title>
    <url>/2021/07/07/jdbc/</url>
    <content><![CDATA[<blockquote>
<p>Java DataBase Connectivity, Java连接数据库，是SUN公司制定的一套接口, java.sql.*;</p>
<p>后期将集成到Mybatis框架中。</p>
</blockquote>
<span id="more"></span>
<p>从官网下载对应的驱动jar包，将其配置到环境变量classpath。</p>
<p>classpath=.;D:\course\06-JDBC\resources\MySql Connector Java 5.1.23\mysql-connector-java-5.1.23-bin.jar</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 1、注册驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();	<span class="comment">//多态，父类型引用指向子类型对象</span></span><br><span class="line">        DriverManager.registerDriver(driver); <span class="comment">//静态方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册驱动的另一种方法</span></span><br><span class="line">        <span class="comment">//Class.forName(driver);</span></span><br><span class="line">        <span class="comment">//不用接受返回值，只想用类加载这个操作，执行静态代码块完成注册驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取连接</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">				url包括哪几部分:协议，IP，Port，资源名				</span></span><br><span class="line"><span class="comment">				eg：http://180.101.49.11:80/index.html</span></span><br><span class="line"><span class="comment">			http:// 通信协议; 180.101.49.11 IP地址; 80 端口号; index.html 资源名</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mydatabase&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;146&quot;</span>;</span><br><span class="line">        <span class="comment">// static Connection getConnection(String url, String user, String password)</span></span><br><span class="line">        conn = DriverManager.getConnection(url,user,password); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;数据库连接对象&quot; + conn);	</span></span><br><span class="line">        <span class="comment">//数据库连接对象com.mysql.jdbc.JDBC4Connection@1ae369b7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、获取数据库操作对象</span></span><br><span class="line">        <span class="comment">// Statement createStatement() 创建一个 Statement 对象来将 SQL 语句发送到数据库。</span></span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、执行sql语句</span></span><br><span class="line">        <span class="comment">// int executeUpdate(String sql) </span></span><br><span class="line">        <span class="comment">// 专门执行DML语句,返回值是“影响数据库中的记录条数”</span></span><br><span class="line">        <span class="comment">// 这里的sql语句不用;</span></span><br><span class="line">        <span class="keyword">int</span> count = stmt.executeUpdate(<span class="string">&quot;update dept set dname = &#x27;销售部&#x27;,</span></span><br><span class="line"><span class="string">                                       loc = &#x27;合肥&#x27; where deptno = 20;&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(count == 1 ? &quot;保存成功&quot;:&quot;保存失败&quot;);</span></span><br><span class="line">		<span class="comment">// 5、处理查询结果集</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6、释放资源, 从小到大依次关闭</span></span><br><span class="line">            <span class="comment">// 释放Statement</span></span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>	&#123;</span><br><span class="line">                    stmt.close();	</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放Connection</span></span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>	&#123;</span><br><span class="line">                    conn.close();	</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理返回结果"><a href="#处理返回结果" class="headerlink" title="处理返回结果"></a>处理返回结果</h2><p>executeUpdate：insert/update/delete, 返回结果对表文件操作时，受影响行数</p>
<p>executeQuery：查询命令【select  *  from 表名】，返回结果是查询命令得到【临时表】，ResultSet实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="comment">//rs = stmt.executeQuery(&quot;select empno,ename,sal from emp&quot;);</span></span><br><span class="line"><span class="comment">//遍历查询到的结果</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="comment">//按顺序取</span></span><br><span class="line">    String empno = rs.getString(<span class="number">1</span>);</span><br><span class="line">    String ename = rs.getString(<span class="number">2</span>);</span><br><span class="line">    String sal = rs.getString(<span class="number">3</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + sal);</span><br><span class="line">	<span class="comment">//按名称取出</span></span><br><span class="line">    String empno = rs.getString(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">    String ename = rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">    String sal = rs.getString(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + sal);</span><br><span class="line">	<span class="comment">//类型+顺序</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String ename = rs.getString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="number">3</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + (sal + <span class="number">100</span>));</span><br><span class="line">	<span class="comment">//类型+名称</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">    String ename = rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + (sal + <span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用动态资源绑定器传参"><a href="#使用动态资源绑定器传参" class="headerlink" title="使用动态资源绑定器传参"></a>使用动态资源绑定器传参</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResourceBundle bundle = ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>); <span class="comment">//.properties后缀不用写</span></span><br><span class="line">String driver = bundle.getString(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">String url = bundle.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String user = bundle.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password = bundle.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">conn = DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mydatabase</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">146</span></span><br></pre></td></tr></table></figure>
<h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><p>问题：用户输入语句含有sql语句关键字，完成了sql语句的拼接，参与编译，导致原sql语句含义被扭曲。</p>
<p>解决方法：用户提供的信息不参与编译过程，用java.sql.PreparedStatement（继承java.sql.Statement）</p>
<ul>
<li>PreparedStatement属于预编译的数据库操作对象，原理：预先对sql语句的框架进行编译，再给sql语句传“值”，使用较多。</li>
<li>PreparedStatement效率高。只用预编译一次，可执行多次。在编译阶段做安全检查（ps.setString()）Statement执行一次编译一次</li>
<li>要求支持sql语句拼接时使用Statement。（如升/降序是在语句末尾拼接asc/desc）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用PreparedStatement模拟登录，防止sql注入现象</span></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Statement stat = null;</span></span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1、注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">// 2、获取连接</span></span><br><span class="line">    conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;146&quot;</span>);</span><br><span class="line">    <span class="comment">// 3、获取预编译的数据库操作对象</span></span><br><span class="line">    <span class="comment">// sql语句的框架中，一个?，表示一个占位符，一个?将来接收一个值。注意：?不用单引号括起来</span></span><br><span class="line">    String sql = <span class="string">&quot;select * from t_user where userName = ? and userPassword = ?&quot;</span>;</span><br><span class="line">    <span class="comment">// 程序执行到此处，会发送sql语句框架给DBMS，DBMS对sql语句框架进行预编译。</span></span><br><span class="line">    ps = conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 给占位符?传值，第一个?的下标是1，第二个?的下标是2（JDBC中下标都从1开始）</span></span><br><span class="line">    ps.setString(<span class="number">1</span>,userLoginInfo.get(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">    ps.setString(<span class="number">2</span>,userLoginInfo.get(<span class="string">&quot;userPassword&quot;</span>));</span><br><span class="line">    <span class="comment">// 4、执行sql语句</span></span><br><span class="line">    rs = ps.executeQuery();</span><br><span class="line">    <span class="comment">// 5、处理结果集</span></span><br><span class="line">    <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">        loginSuccess = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 6、释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升降序排列时需要sql注入</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入desc或者asc&quot;</span>);</span><br><span class="line">String keyWords = s.nextLine();</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">    conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;146&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//createStatement可以完成拼接</span></span><br><span class="line">    stmt = conn.createStatement();</span><br><span class="line">    String sql = <span class="string">&quot;select ename from emp order by ename &quot;</span> + keyWords;</span><br><span class="line">    rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">        System.out.println(rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDBC事务自动提交"><a href="#JDBC事务自动提交" class="headerlink" title="JDBC事务自动提交"></a>JDBC事务自动提交</h2><p>即执行任一条DML语句，则自动提交一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//conn.setAutoCommit(false); // 开启事务</span></span><br><span class="line"><span class="comment">//conn.commit(); // 提交事务</span></span><br><span class="line"><span class="comment">//conn.rollback(); // 回滚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        conn = DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">            <span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="string">&quot;146&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------将自动提交改为手动提交------------------------------</span></span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// 开启事务</span></span><br><span class="line">        <span class="comment">//-----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取预编译的数据库操作对象</span></span><br><span class="line">        String sql = <span class="string">&quot;update t_act set balance = ? where actno = ? &quot;</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        ps.setInt(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">        ps.setDouble(<span class="number">2</span>,<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行sql语句</span></span><br><span class="line">        <span class="keyword">int</span> count = ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String s = null;</span></span><br><span class="line"><span class="comment">            s.toString();</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        ps.setInt(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">        ps.setDouble(<span class="number">2</span>,<span class="number">222</span>);</span><br><span class="line">        count += ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        System.out.println(count == <span class="number">2</span> ? <span class="string">&quot;转账成功&quot;</span> : <span class="string">&quot;转账失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -----------程序能执行到此处，说明没有异常，事务结束，手动提交数据----------------------</span></span><br><span class="line">        conn.commit(); <span class="comment">// 提交事务</span></span><br><span class="line">        <span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// --------遇到异常，回滚-------------------</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback(); <span class="comment">// 回滚</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//-----------------------------------------</span></span><br><span class="line">    &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>行级锁（悲观锁）:for update 当前事务结束之前，行结果被锁住，无法修改。事务排队进行，不允许并发<br>乐观锁：多线程并发，事务不需要排队，都可以修改，需要版本号。</p>
<h2 id="DAO与Entity"><a href="#DAO与Entity" class="headerlink" title="DAO与Entity"></a>DAO与Entity</h2><p>DAO(Data Access Object) 数据访问对象，将数据库操作都封装起来。包括：</p>
<p>1）实体类Dept：用于存放与传输对象数据。</p>
<p>2）数据库连接和关闭工具类JdbcUtil： 避免了数据库连接和关闭代码的重复使用，方便修改。</p>
<p>3）DAO 实现类DeptDao： 针对不同数据库给出DAO接口定义方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实体类（一张表对应一个实体，用于描述表结构，一个实例对象对应表中一个数据行，属性与表中字段保持一致）</span></span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.entity;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deptNo;</span><br><span class="line">    <span class="keyword">private</span> String  dname;</span><br><span class="line">    <span class="keyword">private</span> String  loc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDeptNo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> deptNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeptNo</span><span class="params">(Integer deptNo)</span> </span>&#123;<span class="keyword">this</span>.deptNo = deptNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDname</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> dname;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDname</span><span class="params">(String dname)</span> </span>&#123;<span class="keyword">this</span>.dname = dname;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoc</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> loc;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoc</span><span class="params">(String loc)</span> </span>&#123;<span class="keyword">this</span>.loc = loc;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dept</span><span class="params">(Integer deptNo, String dname, String loc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deptNo = deptNo;</span><br><span class="line">        <span class="keyword">this</span>.dname = dname;</span><br><span class="line">        <span class="keyword">this</span>.loc = loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据库连接和关闭工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Connection con = <span class="keyword">null</span>;<span class="comment">//类文件属性，可以在类文件中所有的方法中使用</span></span><br><span class="line">    <span class="keyword">private</span>  PreparedStatement ps=<span class="keyword">null</span>;<span class="comment">//类文件属性，可以在类文件中所有的方法中使用</span></span><br><span class="line">    <span class="comment">//静态语句块 static&#123;&#125;</span></span><br><span class="line">    <span class="comment">//在当前类文件第一次被加载到JVM时，JVM将会自动调用当前类文件静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//1.注册数据库服务器提供的Driver接口实现类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装Connection对象创建细节 不需要考虑使用对象创建细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Connection  <span class="title">createCon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection对象创建失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象创建细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createStatement</span><span class="params">(String sql)</span></span>&#123;</span><br><span class="line">        Connection con = createCon();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = con.prepareStatement(sql);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象与Connection对象销毁细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ps!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象与Connection对象与ResultSet对象销毁细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DAO接口实现（命名为表名+Dao，实现CRUD功能）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  JdbcUtil util = <span class="keyword">new</span> JdbcUtil();</span><br><span class="line">    <span class="comment">//添加数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(String deptNo,String dname,String loc)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;insert into dept (deptNo,dname,loc) values(?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setInt(<span class="number">1</span>, Integer.valueOf(deptNo));</span><br><span class="line">            ps.setString(<span class="number">2</span>, dname);</span><br><span class="line">            ps.setString(<span class="number">3</span>, loc);</span><br><span class="line">            result=ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String deptNo)</span></span>&#123;</span><br><span class="line">        String sql =<span class="string">&quot;delete from dept where deptno=?&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setInt(<span class="number">1</span>, Integer.valueOf(deptNo));</span><br><span class="line">            result = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String deptNo,String dname,String loc)</span></span>&#123;</span><br><span class="line">        String  sql =<span class="string">&quot;update dept set dname=?,loc=? where deptno=?&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setString(<span class="number">1</span>, dname);</span><br><span class="line">            ps.setString(<span class="number">2</span>, loc);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, Integer.valueOf(deptNo));</span><br><span class="line">            result = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql =<span class="string">&quot;select * from dept&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">//将是临时表数据行转换为实体类实例对象保管</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">int</span> deptNo = rs.getInt(<span class="string">&quot;deptno&quot;</span>);</span><br><span class="line">                String dname = rs.getString(<span class="string">&quot;dname&quot;</span>);</span><br><span class="line">                String loc = rs.getString(<span class="string">&quot;loc&quot;</span>);</span><br><span class="line">                Dept dept = <span class="keyword">new</span> Dept(deptNo, dname, loc);</span><br><span class="line">                list.add(dept);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA/Servlet规范</title>
    <url>/2021/07/19/servlet/</url>
    <content><![CDATA[<blockquote>
<p>Servlet规范，来自于JAVAEE规范中的一种。</p>
<p>后期使用springMVC框架。</p>
</blockquote>
<span id="more"></span>
<p>Servlet规范指定【动态资源文件】开发步骤；Http服务器调用动态资源文件规则；Http服务器管理动态资源文件实例对象规则。</p>
<p>Tomcat服务器下lib文件中servlet-api.jar存放Servlet接口（javax.servlet.Servlet接口）</p>
<p>Servlet规范任务中，Http服务器能调用的【动态资源文件】必须是一个<strong>Servlet接口实现类</strong></p>
<h2 id="Servlet规范开发步骤"><a href="#Servlet规范开发步骤" class="headerlink" title="Servlet规范开发步骤"></a>Servlet规范开发步骤</h2><ul>
<li>创建一个Java类继承HttpServlet父类，使之成为一个Servlet接口实现类</li>
</ul>
<ul>
<li><p>重写两个方法，doGet或则doPost</p>
</li>
<li><p>将Servlet接口实现类信息【注册】到Tomcat服务器</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /web/WEB-INF/web.xml文件中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将Servlet接口实现类类路径地址交给Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span><span class="comment">&lt;!--声明servlet接口实现类类路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    Tomcat  String mm = &quot;com.bjpowernode.controller.OneServlet&quot;</span><br><span class="line">    <span class="comment">&lt;!--为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/one<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--设置简短请求别名,别名在书写时必须以&quot;/&quot;为开头--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期"></a>Servlet对象生命周期</h2><ul>
<li>网站中所有的Servlet接口实现类的实例对象，只能由Http服务器(如Tomcat，相当于servlet的容器)负责额创建。 开发人员不能手动创建。</li>
</ul>
<ul>
<li>在默认的情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时，自动创建这个Servlet接口实现类的实例对象；在手动配置情况下，要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--手动配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>30<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span><span class="comment">&lt;!--填写一个大于0的整数即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>在Http服务器运行期间，一个Servlet接口实现类只能被创建出一个实例对象</p>
</li>
<li><p>在Http服务器关闭时刻，自动将网站中所有的Servlet对象进行销毁</p>
</li>
</ul>
<h2 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h2><p>来自于Servlet规范，在Tomcat中存在servlet-api.jar，实现类由Http服务器负责提供。负责将doGet/doPost方法<strong>执行结果</strong>写入到【响应体】交给浏览器。惯于将HttpServletResponse接口修饰的对象称为【<strong>响应对象</strong>】</p>
<p>主要功能:</p>
<ul>
<li><p>执行结果以二进制形式写入到【响应体】</p>
</li>
<li><p>设置响应头中[content-type]属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">         String result=<span class="string">&quot;Java&lt;br/&gt;Mysql&lt;br/&gt;HTML&lt;br/&gt;&quot;</span>; <span class="comment">//既有文字信息又有HTML标签命令</span></span><br><span class="line">        <span class="comment">//设置响应头content-type</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//向Tomcat索要输出流</span></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">//通过输出流将结果写入到响应体</span></span><br><span class="line">        out.print(result);</span><br><span class="line">    &#125;<span class="comment">//doGet执行完毕，Tomcat将响应包推送给浏览器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置响应头中【location】属性，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String result =<span class="string">&quot;http://www.baidu.com?userName=mike&quot;</span>;</span><br><span class="line">    <span class="comment">//通过响应对象，将地址赋值给响应头中location属性</span></span><br><span class="line">    response.sendRedirect(result);<span class="comment">//[响应头  location=&quot;http://www.baidu.com&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//浏览器在接收到响应包之后，如果发现响应头中存在location属性，自动通过地址栏向location指定网站发送请求。sendRedirect方法远程控制浏览器请求行为【请求地址，请求方式，请求参数】</span></span><br></pre></td></tr></table></figure>
<h2 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h2><p>来自于Servlet规范中，在Tomcat中存在servlet-api.jar，接口实现类由Http服务器负责提供。负责在doGet/doPost方法运行时读取Http请求协议包中信息，修饰的对象称为【请求对象】</p>
<p>作用:</p>
<ul>
<li>读取Http请求协议包中【请求行】信息</li>
<li>读取保存在Http请求协议包中【请求头】或则【请求体】中请求参数信息</li>
<li>代替浏览器向Http服务器申请资源文件调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象，读取【请求行】中【url】信息</span></span><br><span class="line">         String url = request.getRequestURL().toString();</span><br><span class="line">        <span class="comment">//2.通过请求对象，读取【请求行】中【method】信息</span></span><br><span class="line">         String method = request.getMethod();</span><br><span class="line">        <span class="comment">//3.通过请求对象，读取【请求行】中uri信息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * URI：资源文件精准定位地址，在请求行并没有URI这个属性。</span></span><br><span class="line"><span class="comment">        *      实际上URL中截取一个字符串，这个字符串格式&quot;/网站名/资源文件名&quot;</span></span><br><span class="line"><span class="comment">        *      URI用于让Http服务器对被访问的资源文件进行定位</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String uri =  request.getRequestURI();<span class="comment">// substring</span></span><br><span class="line">        System.out.println(<span class="string">&quot;URL &quot;</span>+url);</span><br><span class="line">        System.out.println(<span class="string">&quot;method &quot;</span>+method);</span><br><span class="line">        System.out.println(<span class="string">&quot;URI &quot;</span>+uri);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.通过请求对象获得【请求头】中【所有请求参数名】</span></span><br><span class="line">        Enumeration paramNames =request.getParameterNames(); </span><br><span class="line">        <span class="comment">//将所有请求参数名称保存到一个枚举对象进行返回</span></span><br><span class="line">        <span class="keyword">while</span>(paramNames.hasMoreElements())&#123;</span><br><span class="line">            String paramName = (String)paramNames.nextElement();</span><br><span class="line">            <span class="comment">//2.通过请求对象读取指定的请求参数的值</span></span><br><span class="line">            String value = request.getParameter(paramName);</span><br><span class="line">            System.out.println(<span class="string">&quot;请求参数名 &quot;</span>+paramName+<span class="string">&quot; 请求参数值 &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        浏览器以GET方式发送请求,请求参数保存在【请求头】,在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求头二进制内容由Tomcat负责解码，Tomcat9.0默认使用【utf-8】字符集，可以解释一切国家文字</span></span><br><span class="line"><span class="comment">	浏览器以POST方式发送请求，请求参数保存在【请求体】,在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求体二进制内容由当前请求对象（request）负责解码。request默认使用[ISO-8859-1]字符集，一个东欧语系字符集，此时如果请求体参数内容是中文，将无法解码只能得到乱码</span></span><br><span class="line"><span class="comment">	解决方案:在Post请求方式下，在读取请求体内容之前，应该通知请求对象使用utf-8字符集对请求体内容进行一次重新解码*/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通知请求对象，使用utf-8字符集对请求体二进制内容进行一次重写解码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//通过请求对象，读取【请求体】参数信息</span></span><br><span class="line">        String value = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;从请求体得到参数值 &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请求对象和响应对象生命周期</p>
<ul>
<li>​       在Http服务器接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】</li>
<li>在Http服务器调用doGet/doPost方法时，负责将【请求对象】和【响应对象】作为实参传递到方法，确保doGet/doPost正确执行</li>
<li>在Http服务器准备推送Http响应协议包之前，负责将本次请求关联的【请求对象】和【响应对象】<br>​      销毁</li>
</ul>
<p>【请求对象】和【响应对象】生命周期贯穿一次请求的处理过程中</p>
</blockquote>
<h2 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h2><p>由三位数字组成的一个符号。Http服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中【状态行】上。</p>
<p>如果Http服务器针对本次请求，返回了对应的资源文件，通过Http状态码通知浏览器应该如何处理这个结果</p>
<p>如果Http服务器针对本次请求，无法返回对应的资源文件，通过Http状态码向浏览器解释不能提供服务的原因</p>
<p>分类：<br>100—-599组成；分为5个大类<br>100; 通知浏览器本次返回的资源文件并不是一个独立的资源文件，需要浏览器在接收响应包之后，继续向Http服务器所要依赖的其他资源文件</p>
<p>200，通知浏览器本次返回的资源文件是一个完整独立资源文件，浏览器在接收到之后不需要所要其他关联文件</p>
<p>302，通知浏览器本次返回的不是一个资源文件内容而是一个资源文件地址，需要浏览器根据这个地址自动发起请求来索要这个资源文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;资源文件地址&quot;</span>) <span class="comment">//写入到响应头中location</span></span><br><span class="line"><span class="comment">//而这个行为导致Tomcat将302状态码写入到状态行</span></span><br></pre></td></tr></table></figure>
<p>404: 通知浏览器，由于在服务端没有定位到被访问的资源文件 因此无法提供帮助</p>
<p>405：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet），但是这个Servlet对于浏览器采用的请求方式不能处理</p>
<p>500:通知浏览器，在服务端已经定位到被访问的资源文件（Servlet）这个Servlet可以接收浏览器采用请求方式，但是Servlet在处理请求期间，由于Java异常导致处理失败</p>
<h2 id="多个Servlet之间调用规则"><a href="#多个Servlet之间调用规则" class="headerlink" title="多个Servlet之间调用规则"></a>多个Servlet之间调用规则</h2><p>多个Servlet:</p>
<ul>
<li>前提条件：某些来自于浏览器发送请求，往往需要服务端中多个Servlet协同处理。但是浏览器一次只能访问一个Servlet，导致用户需要手动通过浏览器发起多次请求才能得到服务。这样增加用户获得服务难度，导致用户放弃访问当前网站</li>
</ul>
<ul>
<li>提高用户使用感受规则：无论本次请求涉及到多少个Servlet,用户只需要【手动】通知浏览器发起一次请求即可</li>
</ul>
<h3 id="重定向解决方案"><a href="#重定向解决方案" class="headerlink" title="重定向解决方案"></a>重定向解决方案</h3><p>用户第一次通过【手动方式】通知浏览器访问OneServlet。OneServlet工作完毕后，将TwoServlet地址写入到响应头location属性中，导致Tomcat将302状态码写入到状态行。浏览器接收到响应包之后，读取到302状态。此时浏览器自动根据响应头中location属性地址【自动】发起第二次请求，访问TwoServlet去完成请求中剩余任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;请求地址&quot;</span>) <span class="comment">//将地址写入到响应包中响应头中location属性</span></span><br></pre></td></tr></table></figure>
<ul>
<li>请求地址：既可以把当前网站内部的资源文件地址发送给浏览器 （/网站名/资源文件名）也可以把其他网站资源文件地址发送给浏览器(<a href="http://ip地址:端口号/网站名/资源文件名">http://ip地址:端口号/网站名/资源文件名</a>)</li>
<li>请求次数：浏览器至少发送两次请求，只有第一次请求是用户手动发送。后续请求都是浏览器自动发送的。</li>
<li>请求方式：通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】</li>
<li>缺点:重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间</li>
</ul>
<h3 id="请求转发解决方案"><a href="#请求转发解决方案" class="headerlink" title="请求转发解决方案"></a>请求转发解决方案</h3><p> 用户第一次通过手动方式要求浏览器访问OneServlet。OneServlet工作完毕后，通过当前的请求对象代替浏览器向Tomcat发送请求，申请调用TwoServlet。Tomcat接收到这个请求之后，自动调用TwoServlet完成剩余任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求对象代替浏览器向Tomcat发送请求</span></span><br><span class="line"><span class="comment">//1.通过当前请求对象生成资源文件申请报告对象</span></span><br><span class="line">RequestDispatcher  report = request.getRequestDispatcher(<span class="string">&quot;/资源文件名&quot;</span>); <span class="comment">//一定要以&quot;/&quot;为开头</span></span><br><span class="line"><span class="comment">//2.将报告对象发送给Tomcat</span></span><br><span class="line">report.forward(request, response)</span><br></pre></td></tr></table></figure>
<ul>
<li>无论本次请求涉及到多少个Servlet,用户只需要手动通过浏览器发送一次请求</li>
</ul>
<ul>
<li>Servlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数增加处理服务速度</li>
</ul>
<p>请求次数：在请求转发过程中，浏览器只发送一次请求</p>
<p>请求地址：只能向Tomcat服务器申请调用当前网站下资源文件地址</p>
<p>请求方式：在请求转发过程中，浏览器只发送一个了个Http请求协议包。参与本次请求的所有Servlet共享同一个请求协议包，因此这些Servlet接收的请求方式与浏览器发送的请求方式保持一致</p>
<h2 id="多个Servlet之间数据共享实现方案"><a href="#多个Servlet之间数据共享实现方案" class="headerlink" title="多个Servlet之间数据共享实现方案"></a>多个Servlet之间数据共享实现方案</h2><p>数据共享：OneServlet工作完毕后，将产生数据交给TwoServlet来使用</p>
<p>Servlet规范中提供四种数据共享方案</p>
<h3 id="ServletContext接口"><a href="#ServletContext接口" class="headerlink" title="ServletContext接口"></a>ServletContext接口</h3><p>来自于Servlet规范中一个接口。在Tomcat中存在servlet-api.jar，在Tomcat中负责提供这个接口实现类。</p>
<p>如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享。</p>
<p>习惯于将ServletContext对象称为【全局作用域对象】。</p>
<blockquote>
<p>每一个网站都存在一个全局作用域对象。 这个全局作用域对象【相当于】一个Map.在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中其他Servlet此时都可以从全局作用域对象得到这个数据进行使用。</p>
<p>生命周期：全局作用域对象生命周期贯穿网站整个运行期间</p>
</blockquote>
<p>在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象</p>
<p>在Http服务器运行期间时，一个网站只有一个全局作用域对象，全局作用域对象一直处于存活状态</p>
<p>在Http服务器准备关闭时，负责将当前网站中全局作用域对象 进行销毁处理          </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令实现： 【同一个网站】OneServlet将数据共享给TwoServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象向Tomcat索要当前网站全局作用域对象</span></span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="comment">//2.将数据添加到全局作用域对象，作为共享数据</span></span><br><span class="line">        application.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="number">100</span>);<span class="comment">// map: key-value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象向Tomcat索要当前网站全局作用域对象</span></span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="comment">//2.从全局作用域对象得到指定关键字对应的值</span></span><br><span class="line">        Integer money=(Integer)application.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cookie类"><a href="#Cookie类" class="headerlink" title="Cookie类"></a>Cookie类</h3><p>来自于Servlet规范中一个工具类，存在于Tomcat提供servlet-api.jar中。如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于Cookie对象进行数据共享</p>
<p>Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量。在现实生活场景中，Cookie相当于用户在服务端得到【会员卡】</p>
<p>原理: 用户通过浏览器第一次向MyWeb网站发送请求申请OneServlet。OneServlet在运行期间创建一个Cookie存储与当前用户相关数据。OneServlet工作完毕后，【<strong>将Cookie写入到响应头</strong>】交还给当前浏览器。浏览器收到响应响应包之后，将cookie存储在浏览器的缓存一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时。【<strong>浏览器需要无条件的将myWeb网站之前推送过来的Cookie，写入到请求头</strong>】发送过去。此时TwoServlet在运行时，可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现命令:  同一个网站 OneServlet 与  TwoServlet 借助于Cookie实现数据共享</span></span><br><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个cookie对象，保存共享数据（当前用户数据）</span></span><br><span class="line">        Cookie card = <span class="keyword">new</span> Cookie(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;abc&quot;</span>);<span class="comment">// Cookie(String name,String value)</span></span><br><span class="line">        Cookie card1= <span class="keyword">new</span> Cookie(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">		<span class="comment">//cookie相当于一个map,一个cookie中只能存放一个键值对</span></span><br><span class="line">        <span class="comment">//这个键值对的key与value只能是String,键值对中key不能是中文</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.【发卡】将cookie写入到响应头，交给浏览器</span></span><br><span class="line">        resp.addCookie(card);</span><br><span class="line">        resp.addCookie(card1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TwoServlet&#123;			 </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象从请求头得到浏览器返回的Cookie</span></span><br><span class="line">        Cookie  cookieArray[] = request.getCookies();</span><br><span class="line">        <span class="comment">//2.循环遍历数据得到每一个cookie的key 与 value</span></span><br><span class="line">        <span class="keyword">for</span>(Cookie card:cookieArray)&#123;</span><br><span class="line">            String key =   card.getName(); <span class="comment">//读取key  &quot;key1&quot;</span></span><br><span class="line">            String value = card.getValue();<span class="comment">//读取value &quot;abc&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Cookie销毁时机</p>
</blockquote>
<p>在默认情况下，Cookie对象存放在浏览器的缓存中。只要浏览器关闭，Cookie对象就被销毁</p>
<p>在手动设置情况下，可以要求浏览器将接收的Cookie 存放在客户端计算机上硬盘上，同时需要指定Cookie在硬盘上存活时间。在存活时间范围内，关闭浏览器关闭客户端计算机，关闭服务器，都不会导致Cookie被销毁。在存活时间到达时，Cookie自动从硬盘上被删除</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cookie</span>.setMaxAge(<span class="number">60</span>); //cookie在硬盘上存活<span class="number">1</span>分钟</span><br></pre></td></tr></table></figure>
<p>Cookie域保存在自己浏览器内部，与别人互不干扰，但因为是客户端技术，所以安全性不高。</p>
<h3 id="HttpSession接口"><a href="#HttpSession接口" class="headerlink" title="HttpSession接口"></a>HttpSession接口</h3><p>来自于Servlet规范下一个接口。存在于Tomcat中servlet-api.jar，其实现类由Http服务器提供。Tomcat提供实现类存在于servlet-api.jar。如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于HttpSession对象进行数据共享。习惯于将HttpSession接口修饰对象称为【会话作用域对象】</p>
<blockquote>
<p>HttpSession 与  Cookie 区别：</p>
<p>存储位置:Cookie：存放在客户端计算机（浏览器内存/硬盘）。HttpSession：存放在服务端计算机内存</p>
<p>数据类型：Cookie对象存储共享数据类型只能是String。HttpSession对象可以存储任意类型的共享数据Object</p>
<p>数据数量: 一个Cookie对象只能存储一个共享数据。HttpSession使用map集合，可以存储任意数量共享数据</p>
<p>参照物：Cookie相当于客户在服务端【会员卡】。HttpSession相当于客户在服务端【私人保险柜】</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令实现:   同一个网站（myWeb）下OneServlet将数据传递给TwoServlet</span></span><br><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//2.将数据添加到用户私人储物柜</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;key1&quot;</span>,共享数据)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浏览器访问/myWeb中TwoServlet</span></span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//2.从会话作用域对象得到OneServlet提供的共享数据</span></span><br><span class="line">        Object 共享数据 = session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Http服务器如何将用户与HttpSession关联：cookie</p>
<blockquote>
<p>getSession()  与  getSession(false)</p>
<p>getSession(): 如果当前用户在服务端已经拥有了自己的私人储物。要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。要求tocmat为当前用户创建一个全新的私人储物柜</p>
<p>getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜.要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。此时Tomcat将返回null</p>
</blockquote>
<p>HttpSession销毁时机:</p>
<p>用户与HttpSession关联时使用的Cookie只能存放在浏览器缓存中，在浏览器关闭时，意味着用户与他的HttpSession关系被切断。由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会让Tomcat将浏览器关联的HttpSession进行销毁。为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】，空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟，此时Tomcat认为用户已经放弃了自己的HttpSession，Tomcat就会销毁这个HttpSession</p>
<h3 id="HttpServletRequest接口-1"><a href="#HttpServletRequest接口-1" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h3><p>在同一个网站中，如果两个Servlet之间通过【请求转发】方式进行调用，彼此之间共享同一个请求协议包。而一个请求协议包只对应一个请求对象。因此servlet之间共享同一个请求对象，此时可以利用这个<strong>请求对象</strong>在两个Servlet之间实现数据共享。</p>
<p>将请求对象称为【请求作用域对象】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OneServlet通过请求转发申请调用TwoServlet时，需要给TwoServlet提供共享数据</span></span><br><span class="line">OneServlet&#123;				 </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.将数据添加到【请求作用域对象】中attribute属性</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;key1&quot;</span>,数据); <span class="comment">//数据类型可以任意类型Object</span></span><br><span class="line">        <span class="comment">//2.向Tomcat申请调用TwoServlet</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/two&quot;</span>).forward(req,response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从当前请求对象得到OneServlet写入到共享数据</span></span><br><span class="line">        Object 数据 = req.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;				 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监听器接口"><a href="#监听器接口" class="headerlink" title="监听器接口"></a>监听器接口</h2><p>一组来自于Servlet规范下接口，共有8个接口。在Tomcat存在servlet-api.jar包。监听器接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类。监听器接口用于监控【<strong>作用域对象</strong>生命周期变化时刻】以及【作用域对象共享数据变化时刻】</p>
<blockquote>
<p>作用域对象：在Servlet规范中，认为在<strong>服务端内存</strong>中可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】</p>
<p>Servlet规范下作用域对象:</p>
<ul>
<li>ServletContext：全局作用域对象</li>
<li>HttpSession:  会话作用域对象</li>
<li>HttpServletRequest: 请求作用域对象</li>
</ul>
<p>(cookie存放在客户端，故不属于作用域对象)</p>
</blockquote>
<p>监听器接口实现类开发规范：根据监听的实际情况，选择对应监听器接口进行实现；重写监听器接口声明【监听事件处理方法】；在web.xml文件将监听器接口实现类注册到Http服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将监听器接口实现类注册到Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.bjpoewrnode.listener.OneListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ServletContextListener接口</li>
</ul>
<p>合法的检测全局作用域对象被初始化时刻以及被销毁时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitlized</span><span class="params">(ServletContextEvent sce)</span><span class="comment">//在全局作用域对象被Http服务器初始化被调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestory</span><span class="params">(ServletContextEvent sce)</span><span class="comment">//在全局作用域对象被Http服务器销毁时触发调用</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>ServletContextAttributeListener接口</li>
</ul>
<p>合法的检测全局作用域对象共享数据变化时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextAdd</span><span class="params">()</span> <span class="comment">//在全局作用域对象添加共享数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextReplaced</span><span class="params">()</span> <span class="comment">//在全局作用域对象更新共享数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextRemove</span><span class="params">()</span> <span class="comment">//在全局作用域对象删除共享数据</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局作用域对象共享数据变化时刻</span></span><br><span class="line">ServletContext application = request.getServletContext();</span><br><span class="line">application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="number">100</span>); <span class="comment">//新增共享数据</span></span><br><span class="line">application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="number">200</span>); <span class="comment">//更新共享数据</span></span><br><span class="line">application.removeAttribute(<span class="string">&quot;key1&quot;</span>);  <span class="comment">//删除共享数据</span></span><br></pre></td></tr></table></figure>
<h2 id="过滤器接口"><a href="#过滤器接口" class="headerlink" title="过滤器接口"></a>过滤器接口</h2><p>来自于Servlet规范下接口，在Tomcat中存在于servlet-api.jar包。Filter接口实现类由开发人员负责提供，Http服务器不负责提供。Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截。</p>
<blockquote>
<p>拦截Http服务器，帮助Http服务器检测当前请求合法性；对当前请求进行增强操作</p>
</blockquote>
<p>Filter接口实现类开发步骤：创建一个Java类实现Filter接口；重写Filter接口中doFilter方法；web.xml将过滤器接口实现类注册到Http服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//合法请求</span></span><br><span class="line">        <span class="comment">//将拦截请求对象和响应对象交还给Tomcat,由Tomcat继续调用资源文件</span></span><br><span class="line">        <span class="keyword">if</span>(...)&#123; </span><br><span class="line">        <span class="comment">//增强功能，通知拦截的请求对象，使用UTF-8字符集对当前请求体信息进行一次重新编辑(POST())</span></span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);<span class="comment">//FilterChain的doFilter方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则过滤器代替Http服务器拒绝本次请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--将过滤器类文件路径交给Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>oneFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.bjpowernode.filter.OneFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通知Tomcat在调用何种资源文件时需要被当前过滤器拦截--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>oneFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>拦截地址<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用某一个具体文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/mm.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用某一个文件夹下所有的资源文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用任意文件夹下某种类型文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用网站中任意文件时，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用过滤器避免恶意登录（避开登陆界面直接通过地址栏访问网站内资源文件）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用Dao将查询验证信息推送到数据库服务器上</span></span><br><span class="line">        result = dao.login(userName, password);</span><br><span class="line">        <span class="keyword">if</span>(result ==<span class="number">1</span>)&#123;<span class="comment">//用户存在</span></span><br><span class="line">            <span class="comment">//在判定来访用户身份合法后，通过请求对象向Tomcat申请为当前用户申请一个HttpSession令牌</span></span><br><span class="line">            HttpSession session = request.getSession();</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myWeb/index.html&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myWeb/login_error.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)servletRequest;</span><br><span class="line">        <span class="comment">// 与login相关的不过滤</span></span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        <span class="keyword">if</span>(uri.indexOf(<span class="string">&quot;login&quot;</span>) != -<span class="number">1</span> || <span class="string">&quot;/myWeb/&quot;</span>.equals(uri))&#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.拦截后，通过请求对象向Tomcat索要当前用户的HttpSession。</span></span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜.要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。此时Tomcat将返回null</span></span><br><span class="line">        <span class="comment">//2.判断来访用户身份合法性</span></span><br><span class="line">        <span class="keyword">if</span>(session == <span class="keyword">null</span>)&#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/login_error.html&quot;</span>)</span><br><span class="line">                .forward(servletRequest, servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--通知Tomcat在调用任意文件之前都要调用当前过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>图与网络/贪心算法</title>
    <url>/2021/07/12/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<blockquote>
<p>贪心算法在对问题求解时，总是做出在当前看来是最好的选择。</p>
</blockquote>
<span id="more"></span>
<h2 id="最小生成树问题-Minimum-spanning-trees-MST"><a href="#最小生成树问题-Minimum-spanning-trees-MST" class="headerlink" title="最小生成树问题(Minimum spanning trees,MST)"></a>最小生成树问题(Minimum spanning trees,MST)</h2><blockquote>
<p><strong>生成树</strong>：指一个连通子图，它含有图中全部$n$个顶点，但只有足以构成一棵树的$n-1$条边。</p>
<p><strong>最小生成树</strong>：在所有生成树中，所有边的权重和最小的生成树。</p>
<p>假设有一个连通的无向的图$G=(V,E)$，及权值函数$w: E\rightarrow R$。考虑贪婪的方法找出$MST$。</p>
</blockquote>
<p>这个贪心策略由下面的“一般型”算法延伸，该算法<strong>每次只增长最小生成树的一条边</strong>。</p>
<p>该算法管理边集$A$，$A$不断加$1$条边，需要做$n-1$次循环。在每次迭代之前，$A$是最小生成树的子集。在每一步，我们确定可以添加到$A$的边${u,v}$，在不违背这个不变式的情况下，$A\cup \{u，v\}$还是最小生成树的一个子集。</p>
<p>称这样的边为A的安全边（$safe\  edge$），因为它可以在保持不变的情况下添加到$A$。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">GENERIC-MST</span>(G,w)</span><br><span class="line"><span class="selector-tag">A</span> ← ?</span><br><span class="line"><span class="selector-tag">while</span> <span class="selector-tag">A</span> <span class="selector-tag">does</span> <span class="selector-tag">not</span> <span class="selector-tag">form</span> <span class="selector-tag">a</span> <span class="selector-tag">spanning</span> <span class="selector-tag">tree</span></span><br><span class="line">    <span class="selector-tag">do</span> <span class="selector-tag">find</span> <span class="selector-tag">an</span> <span class="selector-tag">edge</span> <span class="selector-tag">e</span> <span class="selector-tag">that</span> <span class="selector-tag">is</span> <span class="selector-tag">safe</span> <span class="selector-tag">for</span> <span class="selector-tag">A</span></span><br><span class="line">        <span class="selector-tag">A</span> ← <span class="selector-tag">A</span> ∪ <span class="selector-tag">e</span></span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如何找到安全的边？</strong></p>
</blockquote>
<p><strong>定义</strong>: 无向图$G=(V,E)$的一个$cut(S,V-S)$是$V$的一个$cut$。</p>
<p>如果一条在$E$中的边$(u, v)$它的一个端点在$S$中，另一个端点在$V-S$中，我们说这条边穿过这个$cut(S,V-S)$</p>
<p>如果$A$中的边没有与该$cut$相交，则该$cut\ respects\ A$的边。</p>
<p>如果边的权值是任何边穿过$cut$的最小值，则边就是穿过$cut$的轻边($light\ edge$)。注意，可以有更多轻边，那么选择其中一条即可。</p>
<p>简单来说，就是$A∪safe\ edge$就是最小生成树的子集，$A$中的点没有穿过$cut$，再在$cut$中找到轻边作为安全边，得到新的$A$，然后再找到新的$cut$，满足$A$没有穿过$cut$，循环此过程，直至找到$n-1$条边。</p>
<blockquote>
<p>定理：设$G=(V,E)$是连通的具有权重$w$的无向图，令$A$是$E$的子集，包含在$G$的最小生成树中。设$(S, V-S)$为任意$cut(respect\ A)$，设$(u,v)$为穿过$(S, V-S)$的轻边。那么$(u,v)$是$A$的安全边。</p>
</blockquote>
<p><strong>证明</strong>:</p>
<p>设$T$是一个最小生成树，包含$A$。</p>
<ul>
<li><p>若$T$包含轻边$(u,v)$，则$A\cup \{u，v\} \in T$,</p>
</li>
<li><p>若$T$不包含轻边$(u,v)$，构造另一棵最小生成树$T’$，对于当前生成树$T，u，v$之间没有直接的边相连，但可以通过路径$p$连通，按图中将$G$分割为$cut$两部分，使得$u， v$在$cut$不同的点集，那么必然存在这样 的$x，y$也被划分在$cut$两部分，边$(u,v)(x,y)$都穿过该$cut$，$(u,v)$是轻边，连接$(u,v)$，断开$(x,y)$，得到新的生成树$T’$，$T’=T-(x,y)\cup (u,v)$。因为$(u,v)$是一个轻边，$w(u,v)\leq w(x,y)$。因此,$w (T’) = w (T) - w (x, y) + w (u, v) \leq w (T)$。由于$T$是最小生成树，所以$T’$也必须是最小生成树。</p>
</li>
</ul>
<p><strong>Kruskal , Prim使用特定的规则来确定安全边。</strong></p>
<ul>
<li><strong>kruaskal算法</strong>找到安全边的方法是，在所有连接森林中两颗不同树的边里面，找到权重最小的边$(u,v)$。</li>
</ul>
<div align="center">
    <img src="/img/greedy/2.jpg"/>
</div>

<ul>
<li><strong>Prim算法</strong>所具有的一个性质是集合$A$中边总是构成一棵树。这颗树从一个任意的根节点r开始，一直长大到覆盖$V$中的所有结点时为止。算法每一步在连接集合$A$和$A$之外的节点所有边中，选择一条轻边加入到$A$中。</li>
</ul>
<div align="center">
    <img src="/img/greedy/3.jpg"/>
</div>



<h2 id="最大独立集-Maximum-independent-set"><a href="#最大独立集-Maximum-independent-set" class="headerlink" title="最大独立集(Maximum independent set)"></a>最大独立集(Maximum independent set)</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Greedy independent <span class="keyword">set</span></span><br><span class="line"><span class="keyword">input</span> Graph G=(V,E);</span><br><span class="line">output independent <span class="keyword">set</span> V<span class="string">&#x27; in G;</span></span><br><span class="line"><span class="string">begin</span></span><br><span class="line"><span class="string">    V&#x27;</span>:=ф</span><br><span class="line">    U:=V</span><br><span class="line">    <span class="keyword">while</span> U <span class="keyword">is</span> <span class="keyword">not</span> empty <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        x: vertex <span class="keyword">of</span> minimum degree <span class="keyword">in</span> graph induced <span class="keyword">by</span> U</span><br><span class="line">        V<span class="string">&#x27;:=V&#x27;</span>U(x);</span><br><span class="line">        eliminate x <span class="keyword">and</span> <span class="keyword">all</span> its neighbors <span class="keyword">from</span> U</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> V<span class="string">&#x27;</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>贪心算法找不到最大独立集的例子：</p>
<div align="center">
    <img src="/img/greedy/1.png"/>
</div>

<p>贪心结果：${a, e}$</p>
<p>实际结果：${b, c, d}$</p>
</blockquote>
<p>可以看出，随着左部和中部图中点数的增加，贪心所得到的解与最优值可以相差任意远。可以使用图的密度函数判断贪心算法的表现。</p>
<blockquote>
<p>定理：假设图$G$有$n$个点和$m$条边，记$\delta =\frac{m}{n}$为图G的密度。贪心算法求得的解$m_{Gr}(G)\geq \frac{n}{(2\delta +1)}$</p>
</blockquote>
<p><strong>证明：</strong></p>
<p>设$x_i$为程序while循环第$i$次迭代时选定的顶点，$d_i$为$x_i$的度。</p>
<p>该算法将$x_i$及其所有$d_i$邻居从$G$中删除。第$i$步删除$d_{i+1}$个点，得到</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}(d_i+1)=n.........(1)</script><p>又因为删除点的同时会删除边，那么与$x_i$相连的$d_i$个点至少度是$d_i$，那么删除的边有$(d_i+1)d_i$，又$d_i$个点之间可能存在互相连接的情况，那么删除的边至少有$(di+1)di/2$，删除的边数一定小于总边数，得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}(d_i+1)\frac{d_i}{2}\leq m=\delta n..........(2)</script><p>$(2)*2+(1)$得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}(d_i+1)^2\leq n(2\delta +1)</script><p>利用柯西斯瓦格不等式，对于所有的$i$，当$d_i+1=\frac{n}{m_{Gr}(G)}$时，不等式的左边取得极小值。</p>
<script type="math/tex; mode=display">
n(2\delta +1)\geq \sum_{i=1}^{m_{Gr}(G)}(d_i+1)^2\geq \frac{n^2}{m_{Gr}(G)}</script><p>得证。</p>
<p>下面的定理提供了最优解与贪婪算法求得的解之间的关系。</p>
<blockquote>
<p>定理：有$n$个顶点和$m$的图$G$，设$\delta =\frac{m}{n}$。可以找到一个独立的集合$m_{Gr}(G)$，令最优解$\frac{m^*(G)}{m_{Gr}(G)}\leq (\delta +1)$</p>
</blockquote>
<p><strong>证明</strong>:</p>
<p>本证明与前一证明相似。在本例中，确定一个最大的独立集合${V^<em>}$，令$k_i$为在第$i$次循环中所删除$d_{i+1}$个顶点并在${V^</em>}$中的顶点数。显然</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}k_i=|V^*|=m^*(G)............(3)</script><p>由于贪心算法选择的顶点最小度，删除的顶点的度的和至少是$d_i(d_i+1)$。</p>
<p>因为一条边的两个端点不可能都在$V^<em>$</em>中，*它这样删除边的数目至少为$\frac{(d_i(d_i+1)+k_i(k_i-1))}{2}$，这里可以修改$(2)$，得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}\frac{d_i(d_i+1+ki(k_i-1))}{2}\leq \delta n...........(4)</script><p>$(2)+(3)+2*(4)$得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}((d_i+1)^2+k_i^2)\leq n(2\delta +1)+m^*(G)</script><p>应用$C-S$不等式，当$d_i+1=\frac{n}{m_{Gr}(G)}\ and\ k_i=\frac{m^*(G)}{m_{Gr}(G)}$，上述不等式左边最小，因此</p>
<script type="math/tex; mode=display">
n(2\delta +1)+m^*(G)\geq \sum_{i=1}^{m_{Gr}(G)}((d_i+1)^2+k_i^2)\geq \frac{n^2+m^*(G)^2}{m_{Gr}(G)}</script><p>即</p>
<script type="math/tex; mode=display">
m_{Gr}(G)\geq m^*(G)\frac{\frac{n}{m^*(G)}+\frac{m^*(G)}{n}}{2\delta +1+\frac{m^*(G)}{n}}</script><p>当$m^*(G)=n$时，不等式最小。把这一项代入，定理成立。</p>
<h2 id="背包问题-Greedy-knapsack"><a href="#背包问题-Greedy-knapsack" class="headerlink" title="背包问题(Greedy knapsack)"></a>背包问题(Greedy knapsack)</h2><p>输入:集合$X$的$n$个元素，对于$X$中的每个$x_i$，价值$p_i$，重量$w_i$，正整数$b$；</p>
<p>输出:子集$Y\in X$使得$\sum_{x_i\in Y}w_i\leq b,max\ {\sum_{x_i\in Y}} p_i$</p>
<p>按$\frac{p_i}{w_i}$的规则进行贪心选择。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    sort X <span class="keyword">in</span> non-increasing <span class="keyword">order</span> <span class="keyword">with</span> respect <span class="keyword">to</span> the ratio pi/wi;</span><br><span class="line">    Y:=<span class="keyword">empty</span> <span class="keyword">set</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> b&gt;=wi <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        Y=YU<span class="comment">&#123;xi&#125;</span></span><br><span class="line">        b=b-wi</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    return Y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>找不到最优解的例子：</p>
<p>令$p_i=w_i=1，i=1,2，..，n-1, p_n=b-1, w_n=b=k_n$，其中$k$是一个任意大的数。</p>
<p>在这种情况下，最优解$m^*(x)=b-1$;而贪心算法找到的解的值为$n-1$。因此</p>
<script type="math/tex; mode=display">
\frac{m^*(x)}{m_{Gr}(x)} > k</script><p>贪心算法的劣势是由于算法没有将价值最高的元素包含在解中，而最优的元素正是价值最高的。这表明一个简单的修改贪心的程序有更好的性能。</p>
<blockquote>
<p>定理：给定一个背包的实例$x$，令$m_H(x)=max(P_{max}，m_{Gr}(x))$，其中$P_{max}$是$x$中一个项目的最大价值，$m_H(x)$满足以下不等式:$\frac{m^*(x)}{m_H(x)}&lt; 2$。</p>
</blockquote>
<p><strong>证明</strong>：设$j$为根据贪心选择第一个装不进背包物品的下标，此时背包转装入的物品价值为</p>
<script type="math/tex; mode=display">
\overline{p_j}=\sum_{i=1}^{j-1}\leq m_{Gr}(x)</script><p>重量为</p>
<script type="math/tex; mode=display">
\overline{w_j}=\sum_{i=1}^{j-1}w_i\leq b</script><p>首先证明任何最优解必须满足以下条件不等式:</p>
<p>$m^*(x)&lt;\overline{p_j}+p_j$，</p>
<p>因为装入前j-1个物品后，容量还剩余$b-\overline{w_j}&lt; w_j$，贪心选择在装入$j-1$个物品后，无法装入$j$，其密度为$\frac{p_j}{w_j}$，那么如果剩余容量按最优的去放，$(b-\overline{w_j})\frac{p_j}{w_j}&lt;w_j\frac{p_j}{w_j}=p_j$</p>
<p>如果$p_j&lt;\overline{p_j}$，那么$m^*(x)&lt;2\overline{p_j}\leq 2m_{Gr}(x)\leq 2m_H(x)$；</p>
<p>如果$p_j&gt;\overline{p_j}$，那么$P_{max}&gt;\overline{P_j}$，有$m^*(x)\leq \overline{p_j}+p_j\leq 2{p_j}\leq 2P{max}\leq 2m_H(x)$</p>
<h2 id="The-Stein-Lovasz-Theorem"><a href="#The-Stein-Lovasz-Theorem" class="headerlink" title="The Stein-Lovasz Theorem"></a>The Stein-Lovasz Theorem</h2><blockquote>
<p>The stein-lovasz Theorem 理论最基本的模型是解决集合的元素覆盖问题。使用贪心算法，以获得一个使用最少列元完成最大行覆盖的方案。</p>
<p>假设$(0,1)$矩阵$A$的大小是$N×M$ ,矩阵$A$的特征是每行至少具有$v$个$1$，每列最多$a$个$1$。假设现在从其中抽取一个子矩阵$C⊂A$,大小是$N×K$，使得子矩阵的每行元素都不是全零行，证明$K$存在一个上界，<br>$K≤\frac{N}{a}+(\frac{M}{v})lna≤(\frac{M}{v})(1+lna)$</p>
<p>分析：能不能使用一种抽取列数尽可能少的方案，如果使用的列数目比给定的边界条件$\frac{N}{a}+(\frac{M}{v})lna$小，那么原来的问题就自然获得证明。</p>
</blockquote>
<p><strong>贪心算法思路描述如下</strong></p>
<ol>
<li>初始化矩阵$(0,1)$矩阵$A$，每列的$1$权重值$c_i∈\{1,2,3,……,a\}$,然后按照列权重按照 $a,a-1,a-2,…,1$ 执行降序排序，此时的矩阵命名为$A_a$;</li>
<li>从最左边权重最高为$a$的第一列开始，删除这一列，并且这列对应的$1$所在相应的$a$个行也统一删掉。在删除$1$列和$a$行后的矩阵$A$，重新划定权重，继续寻找左边最高权重为$a$的列，继续删除。在删除$2$列和$2∗a$行后的矩阵$A$，重新划定权重，继续寻找左边最高权重为$a$的列，继续删除。重复$K_a$次后，把最高权重为$a$的列及对应的$a∗K_a$行都删掉了，此时的矩阵变成了$A_{a−1}$;</li>
<li>以矩阵$A_{a−1}$开始，从左边权重最高为$a-1$的第一列开始，删除这一列，并且这列所对应的$a−1$行也统一删掉。删完后，重新划定权重，继续寻找左边最高权重为$a-1$的列，继续删除。重复$K_{a−1}$次后，把最高权重为$a-1$的列及其对应的$(a−1)∗K_{a−1}$行都删掉了，此时的矩阵变成了$A_{a−2}$.</li>
<li>重复步骤3，删除权重为$a-2,a-3,…,1$的列，直到矩阵$A_1$变成了空。<br>将之前删除的所有列元集中起来重新组合成$N×K$矩阵，$K=\sum_{i=1}^a K_i$</li>
</ol>
<p><strong>证明</strong>：</p>
<p>假设$A_a=A_{N*M}$表示由$a$个1且每列的1互不重合的列组成的矩阵</p>
<p>$A_{a-1}’$表示由a-1个1且每列的1互不重合的列组成的矩阵。$|A_a’|=K_a$，那么删除覆盖的$K_a\cdot a$行得到新的矩阵$A_{a-1}=A_{(N-aK_a)\times (M-K_a)}$，那么每一列至多有$a-1$个$1$，</p>
<p>$|A_{a-1}’|=K_{a-1}$，那么删除覆盖的$K_{a-1}\cdot (a-1)$行得到新的矩阵$A_{a-2}$。</p>
<p>以此类推，$A_{i-1}$，每行至少$v$个1，每列至多$i-1$个$1$，那么有$N-aK_a-(a-1)K_{a-1}-…-iK_i$行，记为$k_i$行，有$M-K_a-…-K_i$列。</p>
<p>$k_a=N-aK_a$，即$K_a=\frac{N-k_a}{a}$，令$N=k_{a+1}$，则$K_a=\frac{k_{a+1}-k_a}{a}$，以此类推得到</p>
<script type="math/tex; mode=display">
K_i=\frac{k_{i+1}-k_i}{i}</script><script type="math/tex; mode=display">
\sum_{i=1}^{a}K_i=\sum_{i=1}^{a}\frac{k_{i+1}-k}{i}=\frac{k_{a+1}}{a}-\frac{k_a}{a}+\frac{k_a}{a-1}-\frac{k_{a-1}}{a-1} +...+\frac{k_2}{1}=\frac{N}{a}+\frac{k_a}{a(a-1)}+\frac{k_{a-1}}{(a-1)(a-2)}+...+\frac{k_2}{2\times 1}</script><p>使用双计数，分别对行和列进行计数，对于$A_{i-1}$，每一行至少$v$个1，而每列至多$i-1$个$1$，可得对$1$进行行计数不会超过进行列计数，即</p>
<script type="math/tex; mode=display">
k_i\times v\leq (M-K_a-...-K_i)\times (i-1)\leq M\times (i-1) \frac{k_i}{i-1}\leq \frac{M}{v}</script><p>那么</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{a}K_i\leq \frac{N}{a}+\frac{1}{a}\frac{M}{v}+\frac{1}{a-1}\frac{M}{v}+...+\frac{1}{2}\frac{M}{v}=\frac{N}{a}+\frac{M}{v}(\frac{1}{a}+\frac{1}{a-1}+...+\frac{1}{2})\leq \frac{N}{a}+\frac{M}{v}lna\leq \frac{M}{v}+\frac{M}{v}lna=\frac{M}{v}(1+lna)​</script><h3 id="应用1：完美哈希族函数（Perfect-Hash-Function）"><a href="#应用1：完美哈希族函数（Perfect-Hash-Function）" class="headerlink" title="应用1：完美哈希族函数（Perfect Hash Function）"></a>应用1：完美哈希族函数（Perfect Hash Function）</h3><blockquote>
<p>$(n,m,w)$-完美哈希族是一个函数F集合，使得$|Y|=n$， $|X|=m$,</p>
<p>$f:Y\rightarrow X$对于$F$中的每一个$f$，对于任何$C\subseteq \{1,2,…,n\}$使得$|C|=w$，$C$是$Y$的$w$元子集合，并且至少存在一个$F$中的$f$使得$f|C$是一一对应的。如果$|F|=N$那么完美哈希族可以记作$PHF(N;n,m,w)$。</p>
<p>求满足条件的函数数目的一个上界。</p>
</blockquote>
<div align="center">
    <img src="/img/greedy/3.png"/>
</div>

<p>$|F|=N$，如上图，假设$w=3$，那么任选$Y$中的三列，有$\binom{n}{3}$种选择，要求其中存在一行使得三个函数值各不同，例如取$1，2，3$列，$f_{11}$，$f_{12}$，$f_{13}$互不相同就满足要求一一映射。</p>
<p>$f:Y\rightarrow X$，$n$个$Y$对应到$m$个$X$，每一个$Y$有$m$种选择，那么有$m^n$个函数。从中挑出最少的函数(即N越小越好)使得对于任何的$C$可以满足一一对应要求。</p>
<ul>
<li>套用ST定理：</li>
</ul>
<p>$N:\binom{n}{w}$，从$M:m^n$个函数中挑选出最少的函数满足要求，那么得到的矩阵就是$NxM$的$(0,1)$矩阵$A$，$A_{ij}=1$的含义就是当$|w|=i$，$f_j$是可以满足一一映射要求的。</p>
<p>$v:\binom{m}{w}w!\cdot m^{n-w}$，表示从$m$个值中选取$w$的值排列放入选择的$w$个，剩余未赋值的$n-w$个，就任意赋值。</p>
<p>$a:\binom{n}{w}$，每一个函数至多覆盖$a$个。</p>
<p>套用S-T定理得</p>
<script type="math/tex; mode=display">
N\leq \frac{m}{w!\binom{m}{w}}(1+log\binom{n}{w})</script><ul>
<li>使用概率方法:</li>
</ul>
<p>从$m^n$个函数中随机选择$N$个函数出来，构造一张随机的函数表，考虑坏概率，在函数表中没有一个函数可以使$w$存在一一映射关系，对于一个函数坏概率为存在一一对应关系的对立事件，取出$N$个函数，得</p>
<script type="math/tex; mode=display">
(1-\frac{\binom{m}{w}w!m^(n-w)}{m^n})^N\binom{n}{w}</script><p>使其小于1，那么一定存在完美哈希族。(两边取对数求解)</p>
<h3 id="应用2：分割系统-Splitting-Systems"><a href="#应用2：分割系统-Splitting-Systems" class="headerlink" title="应用2：分割系统(Splitting Systems)"></a>应用2：分割系统(Splitting Systems)</h3><p><strong>在某个域中，$\alpha ^n=\beta$，$\alpha ,\beta$已知且为离散的，那么如何求解$n$？</strong></p>
<p><strong>分割系统的提出就是为了解决离散对数问题。</strong></p>
<blockquote>
<p>假设$n,t$为偶数，$X$是点集合,$B$是超边集合。</p>
<p>a) $|X|=n$,$B$是$X$的$\frac{n}{2}$子集的集合，称为区组</p>
<p>b)对于每一个$Y\subseteq X$中存在区组$B$，使得$|B\cap Y|=\frac{t}{2}$。</p>
<p>取最少$N$个$B$使得上面的条件满足。</p>
</blockquote>
<ul>
<li>使用S-T定理</li>
</ul>
<p>$N:\binom{n}{t}$，对所有的t元子集合进行分割;</p>
<p>$M:\binom{n}{\frac{n}{2} }$，完成的方法总数;</p>
<p>接下来确定$v$，那么对于某一行有多少$\frac{n}{2}$元子集合可以分割$t_i$，$t$个位置中一半放$1$，剩余一半放$0$，问题是一个$n$元集合，此时还剩$n-t$个位置没有放数，且还缺少$\frac{n-t}{2}$个1，那么得到子集合个数$\binom{t}{ \frac{t}{2} }\cdot \binom{n-t}{\frac{n-t}{2}}$；</p>
<p>确定$a$，对于固定的$\frac{n}{2}$元子集合可以分割多少$t$，$\binom{\frac{n}{2}}{\frac{t}{2}}\binom{\frac{n}{2}}{\frac{t}{2}}$，套用S-T定理，</p>
<script type="math/tex; mode=display">
N\leq \frac{\binom{n}{\frac{n}{2}}}{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}(1+2ln\binom{\frac{n}{2}}{\frac{t}{2}})</script><div align="center">
    <img src="/img/greedy/2.png"/>
</div>



<ul>
<li>使用概率方法：</li>
</ul>
<p>定义$A_i$，第$i$个$t$元子集合未被分割。对于一个$t$元集合没有分割的概率是分割时间的对立事件，为</p>
<script type="math/tex; mode=display">
1-\frac{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}{\binom{n}{\frac{n}{2}}}</script><p>共有$N$个$\frac{n}{2} $元子集合未被分割，为</p>
<script type="math/tex; mode=display">
(1-\frac{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}{\binom{n}{\frac{n}{2} }})^N=P(A_i)</script><p>那么至少有一个$t$元集合未被分割的概率为</p>
<script type="math/tex; mode=display">
P(\cup A_i)\leq \sum P(A_i)=\binom{n}{t}P(A_i)<1</script><p>令其小于$1$，那么没有未被分割的情况概率大于$0$。</p>
<p>参考：<a href="https://www.codenong.com/cs106200371/">图论学习笔记五贪心算法 | 码农家园 (codenong.com)</a></p>
]]></content>
      <tags>
        <tag>图与网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode/二叉树</title>
    <url>/2021/07/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>二叉树与递归有着千丝万缕的联系，二叉树在定义时就使用了递归的概念：一棵二叉树可能是空树，如果不是空树，那么它的左右子树都是二叉树。</p>
</blockquote>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span></span>&#123;</span><br><span class="line">    Object element;</span><br><span class="line">    BinaryNode left;</span><br><span class="line">    BinaryNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基础：二叉树的遍历"><a href="#基础：二叉树的遍历" class="headerlink" title="基础：二叉树的遍历"></a>基础：二叉树的遍历</h2><p>遍历时均无返回值，所以遍历要另写函数，把需要返回的作为参数传入。</p>
<h3 id="DFS-深度优先"><a href="#DFS-深度优先" class="headerlink" title="DFS, 深度优先"></a>DFS, 深度优先</h3><h4 id="先序遍历：根左右（文件目录结构）。"><a href="#先序遍历：根左右（文件目录结构）。" class="headerlink" title="先序遍历：根左右（文件目录结构）。"></a>先序遍历：根左右（文件目录结构）。</h4><p>常规迭代</p>
<ul>
<li><p>初始化栈，并将根节点入栈；</p>
</li>
<li><p>当栈不为空时：</p>
<ul>
<li>弹出栈顶元素 node，并将值添加到结果中；</li>
<li>如果 node 的右子树非空，将右子树入栈；</li>
<li>如果 node 的左子树非空，将左子树入栈；</li>
</ul>
</li>
</ul>
<p>由于栈是“先进后出”的顺序，所以入栈时先将右子树入栈，这样使得前序遍历结果为 “根-&gt;左-&gt;右”的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代，非递归实现,本质使用栈模拟递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//初始化栈，并将根节点入栈；</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">	<span class="comment">//当栈不为空时：</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//弹出栈顶元素 node，并将值添加到结果中；</span></span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        System.out.print(node.val); </span><br><span class="line">        <span class="comment">//如果 node 的右子树非空，将右子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">        <span class="comment">//如果 node 的左子树非空，将左子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板迭代</p>
<ul>
<li><p>先将根节点 <code>cur</code> 和所有的左孩子入栈并加入结果中，直至 <code>cur</code> 为空</p>
</li>
<li><p>每弹出一个栈顶元素 <code>tmp</code>，就到达它的右孩子，再将这个节点当作 <code>cur</code> 重新按上面的步骤来一遍，直至栈为空。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//将根节点cur和所有的左孩子入栈并加入结果中，直至cur为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(cur.val); </span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每弹出一个栈顶元素tmp,就到达它的右孩子,再将这个节点当作cur</span></span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        cur = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder_Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;        </span><br><span class="line">    <span class="comment">//访问节点的逻辑代码块</span></span><br><span class="line">    System.out.print(root.val+<span class="string">&quot; &quot;</span>);       </span><br><span class="line">    preorder_Traversal(root.left);</span><br><span class="line">    preorder_Traversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历：左根右。"><a href="#中序遍历：左根右。" class="headerlink" title="中序遍历：左根右。"></a><strong>中序遍历：左根右。</strong></h4><p>模板迭代：</p>
<ul>
<li><p>先将根节点 <code>cur</code> 和所有的左孩子入栈中，直至 <code>cur</code> 为空</p>
</li>
<li><p>每弹出一个栈顶元素 <code>tmp</code>，加入结果中，并到达它的右孩子，再将这个节点当作 <code>cur</code> 重新按上面的步骤来一遍，直至栈为空。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//将根节点cur和所有的左孩子入栈中，直至cur为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每弹出一个栈顶元素tmp,加入结果中，并到达它的右孩子,再将这个节点当作cur</span></span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        System.out.print(temp.val); </span><br><span class="line">        cur = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder_Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    inorder_Traversal(root.left);        </span><br><span class="line">    <span class="comment">//访问节点的逻辑代码块</span></span><br><span class="line">    System.out.print(root.val+<span class="string">&quot; &quot;</span>);       </span><br><span class="line">    inorder_Traversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后续遍历：左右根。"><a href="#后续遍历：左右根。" class="headerlink" title="后续遍历：左右根。"></a><strong>后续遍历：左右根。</strong></h4><p>对前序遍历的（根左右）修改为（根右左），再倒序输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规倒序输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//初始化栈，并将根节点入栈；</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; resStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">	<span class="comment">//当栈不为空时：</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//弹出栈顶元素 node，并将值添加到结果中；</span></span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        resStack.push(node);</span><br><span class="line">        <span class="comment">//如果 node 的右子树非空，将右子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        <span class="comment">//如果 node 的左子树非空，将左子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!resStack.isEmpty())&#123;</span><br><span class="line">        res.add(resStack.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板倒序输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; resStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="comment">//将根节点cur和所有的右孩子入栈并加入结果中，直至cur为空</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !s.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            resStack.push(cur); <span class="comment">// root</span></span><br><span class="line">            s.push(cur); </span><br><span class="line">            cur = cur.right; <span class="comment">// right</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//弹出一个栈顶元素tmp，并到达它的左孩子，再将这个节点当作cur</span></span><br><span class="line">        cur = s.pop();</span><br><span class="line">        cur = cur.left; <span class="comment">// left</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反向输出</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!resStack.isEmpty())&#123;</span><br><span class="line">        res.add(resStack.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder_Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    postorder_Traversal(root.left);</span><br><span class="line">    postorder_Traversal(root.right);        </span><br><span class="line">    <span class="comment">//访问节点的逻辑代码块</span></span><br><span class="line">    System.out.print(root.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层次遍历-BFS-广度优先"><a href="#层次遍历-BFS-广度优先" class="headerlink" title="层次遍历(BFS, 广度优先)"></a>层次遍历(BFS, 广度优先)</h3><p>广度优先搜索的步骤为：</p>
<ul>
<li><p>初始化队列 q，并将根节点 root 加入到队列中；</p>
</li>
<li><p>当队列不为空时：</p>
<ul>
<li>队列中弹出节点 node，加入到结果中；</li>
<li>如果左子树非空，左子树加入队列；</li>
<li>如果右子树非空，右子树加入队列；</li>
</ul>
</li>
</ul>
<p><img src="/img/tree/bfs1.gif"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列实现,分层次，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; LaywerTraversal(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 初始化队列 q，并将根节点 root 加入到队列中；</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">//当队列不为空时：</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="comment">//队列中弹出节点 node，加入到结果中；</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="comment">//如果左子树非空，左子树加入队列；</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="comment">//如果右子树非空，右子树加入队列；</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/tree/bfs2.gif"/></p>
<p>BFS常用于找最短路径。</p>
<p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p>
<p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p>
<blockquote>
<p>表达式树：分别对应前缀表达式/中缀表达式/后缀表达式</p>
<p>树叶是操作数值，其他节点是操作符。</p>
</blockquote>
<p>后缀表达式转树：操作数压栈，操作符弹栈</p>
<h2 id="对应例题"><a href="#对应例题" class="headerlink" title="对应例题"></a>对应例题</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>144 二叉树的先序遍历</p>
<p>589 N 叉树的前序遍历</p>
<blockquote>
<p><strong>606 根据先序遍历结果构造字符串</strong></p>
<ul>
<li>在先序遍历中，对每个非空访问元素，在进行处理时，先形成字符串”(“+ root.val；</li>
</ul>
<p>例如，对于[1,2,3,4]，得到”(1(2(4”</p>
<ul>
<li>如果当前访问的节点的左子树为空且右子树不为空，就在字符串中添加一个”()”</li>
</ul>
<p>这样得到, “(1(2(4()”</p>
<ul>
<li>同时，对于每轮递归中，在最终返回前，补全右括号”)”</li>
</ul>
<p>这样我们得到 “(1(2(4())(3))”</p>
<p>由此，基本输出形式已经完成。剩下处理头尾两个多余括号。</p>
<p><strong>331 验证是否是合法先序遍历结果</strong></p>
<ul>
<li><p>二叉树看成有向图，一条有向边带来一个入度和一个出度，二叉树的总入度等于总出度，也等于边数。即，遍历到最后，总入度肯定等于总出度。</p>
</li>
<li><p>还没遍历到最后时，肯定不会出现 入度 &gt;= 出度 的时刻。</p>
</li>
</ul>
<p>提供 1 个出度可以理解为提供一个挂载点，提供 1 个入度为消耗一个挂载点。入度 &gt;= 出度，意味着当前已遍历的节点，消耗的挂载点已经大于等于提供的挂载点。说明已经没法挂载接下来遍历的节点了，还有要挂的，但挂满了，是不合法的。</p>
</blockquote>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>94 基本的中序遍历</p>
<p>173 二叉搜索树迭代器</p>
<p>中序遍历一般会和BST（二叉搜索树）结合使用，这样访问的顺序就是已排序的了</p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>145 基本的二叉树的后序遍历</p>
<p>590 N 叉树的后序遍历</p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>102 二叉树的层序遍历</p>
<p>103 二叉树的锯齿形层序遍历（每层加flag或用双端队列）</p>
<p>107  二叉树的层序遍历 II（自底向上）</p>
<p>429 N 叉树的层序遍历</p>
<h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><p>递归三步：确定递归函数的参数和返回值；确定终止条件（if(root == null) return;）；确定单层递归逻辑（对哪个节点进行什么递归操作）；</p>
<p>226 翻转二叉树（对于每个节点，交换其左右子树，递归其左右子树）</p>
<p>100 相同的树（对于每个节点，判断其值是否相等，递归其左右子树）</p>
<p>572 另一个树的子树(一个树是另一个树的子树，要么这两个树相等；要么这个树是左树的子树；要么是右树的子树。)</p>
<blockquote>
<p><strong>剑指 Offer 26 树的子结构</strong></p>
<ul>
<li>先序遍历树 A中的每个节点；（对应函数 <code>isSubStructure(A, B)</code>）<ul>
<li>特例处理： 当 树 A为空 <strong>或</strong> 树 B 为空 时，直接返回 false；</li>
<li>返回值： 若树 BB 是树 AA 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<br>以 节点 A为根节点的子树 包含树 B ，对应 <code>recur(A, B)</code>；<br>树 B 是 树 A 左子树 的子结构，对应 <code>isSubStructure(A.left, B)</code>；<br>树 B 是 树 A 右子树 的子结构，对应 <code>isSubStructure(A.right, B)</code>;</li>
</ul>
</li>
<li>判断树A中 以当前节点为根节点的子树 是否包含树B。（对应函数 <code>recur(A, B)</code>）<ul>
<li>终止条件：<br>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；<br>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；<br>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li>
<li>返回值：<br>判断 A 和 B 的左子节点是否相等，即 <code>recur(A.left, B.left)</code> ；<br>判断 A 和 B 的右子节点是否相等，即 <code>recur(A.right, B.right)</code> ；</li>
</ul>
</li>
</ul>
</blockquote>
<p>101 对称二叉树/剑指 Offer 28（添加辅助函数，对于每个节点的左右孩子，判断其左的右和右的左，左的左和右的右是否相等，递归其左的右和右的左，左的左和右的右）</p>
<p>617 合并二叉树</p>
<p>965 单值二叉树</p>
<p>104 二叉树的最大深度/559 N 叉树的最大深度/111 二叉树的最小深度/110 平衡二叉树(一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 )</p>
<p>257 二叉树的所有路径</p>
<h2 id="BST搜索二叉树"><a href="#BST搜索二叉树" class="headerlink" title="BST搜索二叉树"></a>BST搜索二叉树</h2><blockquote>
<p>基础操作：创建，判断 BST 的合法性、增、删、查。删较复杂</p>
</blockquote>
<p>95 不同的二叉搜索树 II</p>
<p>98.验证二叉搜索树（中序遍历为升序/左子树不空，左子树上所有节点的值均小于根节点的值； 若右子树不空，则右子树上所有节点的值均大于根节点的值；左右子树也为二叉搜索树。）</p>
<p>700.二叉搜索树中的搜索</p>
<p>701.二叉搜索树中的插入操作</p>
<blockquote>
<p>450.删除二叉搜索树中的节点</p>
<ul>
<li><p>没找到删除的节点，遍历到空节点直接返回了</p>
</li>
<li><p>找到删除的节点</p>
<ul>
<li>左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>左右孩子节点都不为空，则将删除节点左孩子放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子。</li>
</ul>
<p><img src="/img/tree/450.删除二叉搜索树中的节点.gif"/></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode cur = root.right;</span><br><span class="line"><span class="keyword">while</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cur = cur.left;</span><br><span class="line">&#125;</span><br><span class="line">cur.left = root.left;</span><br><span class="line">root = root.right;</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
