<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-链表</title>
    <url>/2021/07/07/Leetcode-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>常用数据结构—链表</p>
</blockquote>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">// 设预指针pre的下一个节点指向head，防止空节点</span></span><br><span class="line">ListNode pre = <span class="keyword">new</span> ListNode(); </span><br><span class="line">pre.next = head;</span><br><span class="line"><span class="comment">// 设置动态当前指针cur</span></span><br><span class="line">ListNode cur = head; </span><br></pre></td></tr></table></figure>
<p>19/剑指 Offer 22 删除链表的倒数第 N 个结点（快慢指针）</p>
<p>61 旋转链表（快慢指针）</p>
<p>剑指 Offer 06. 从尾到头打印链表（栈）</p>
<p>21/ 剑指 Offer 25 合并两个有序链表</p>
<p>24 两两交换链表中的结点</p>
<p>剑指 Offer 18. 删除链表的节点</p>
<p>83 删除排序链表中的重复元素(相同节点保留一个)</p>
<p><strong>82 删除排序链表中的重复元素 II(相同节点全部删除)</strong></p>
<p>86 分隔链表</p>
<p>206/剑指 Offer 24. 反转链表</p>
<p>92 反转链表 II</p>
<p><strong>138/剑指 Offer 35. 复杂链表的复制</strong></p>
<ul>
<li><strong>hashmap</strong></li>
</ul>
<p><strong>剑指 Offer 52. 两个链表的第一个公共节点</strong></p>
<ul>
<li><strong>集合set</strong></li>
<li><strong>快慢指针（先统计两个链表的长度，如果长度不一样，让链表长的先走，直到两个链表长度一样，这此时两个链表同时每次后移一步，看节点是否一样）</strong></li>
<li><strong>双指针</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/06/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a></p>
</blockquote>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>双计数(Double Counting)</title>
    <url>/2021/07/06/%E5%8F%8C%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>双计数狭义上讲，对于一个集合运用两种不同的方式（行 / 列），得到等式结果或者不等式的结果。</p>
</blockquote>
<span id="more"></span>
<h2 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a>握手定理</h2><blockquote>
<p>对于图$G=(V, E)$，有</p>
<script type="math/tex; mode=display">
\sum_{v\in V}d(v) = 2|E|</script></blockquote>
<p>证明：对图G的邻接矩阵中1的个数分别从行（左），列（右）进行计数。即对二元组$\{(v,e)|v\in e\}$进行计数。</p>
<blockquote>
<p>推论：图中奇度点数目为偶数。</p>
<p>超图握手定理：对于超图$G=(V, B)$</p>
</blockquote>
<script type="math/tex; mode=display">
\sum_{v\in V}d(v) = \sum_{\beta\in B}|\beta|</script><h2 id="完全图边的双计数"><a href="#完全图边的双计数" class="headerlink" title="完全图边的双计数"></a>完全图边的双计数</h2><script type="math/tex; mode=display">
\sum_{i=1}^S{n_i} = n</script><script type="math/tex; mode=display">
{n\choose 2} = \sum_{i = 1}^S {n_i \choose 2}+\sum_{i<j}n_in_j</script><p>对于一个完全图，共有$n\choose 2$条边；</p>
<p>将完全图划分为$S$部分，每部分有$n_i$个点，${n_i \choose 2}$条边；</p>
<p>每部分之间有$n_in_j$条边。</p>
<h2 id="等式证明"><a href="#等式证明" class="headerlink" title="等式证明"></a>等式证明</h2><script type="math/tex; mode=display">
{n\choose k } = \frac{n}{k}{n-1 \choose k-1}</script><p>证明：设$A$为$k$元子集，对二元组$\{(x,A)|x\in A, |A| = k\}$进行计数。</p>
<script type="math/tex; mode=display">
\sum_{k = 1}^n k{n\choose k} = n \sum_{k = 1}^n { {n-1}\choose {k-1} } = n2^{n-1}</script><p>证明：设$A$为$k$元子集，$k=1,2,…,n$，对二元组$\{(x,A)|x\in A, |A| = k\}$进行计数。</p>
<script type="math/tex; mode=display">
{n \choose k}{k \choose l} = {n \choose l} { {n-1}\choose {k-l} }</script><p>证明：设$A$为$l$元子集，$B$为$k$元子集，对二元组$\{(A,B)||A|=l,|B|=k,A\subseteq B\}$进行计数。</p>
<h2 id="Turan-Number"><a href="#Turan-Number" class="headerlink" title="Turan Number"></a>Turan Number</h2><script type="math/tex; mode=display">
T(n,k,l)\geq \frac{n\choose l}{k \choose l}</script><blockquote>
<p>图兰数$T(n,k,l) (l\leq k \leq n)$是$n$元集合$X$的$l$元子集的最小值(下界)，使得$X$的每个$k$元子集至少包含一个这样的l元子集。</p>
</blockquote>
<p>证明：设$F$为满足条件的l元子集，记$F=\{A_1，A_2，…\}$，此时可用关联矩阵表示，$A_i$为满足条件的$l$元集合，$B_i$为$ k$元子集，若$A_i$在$B_i$上，则为$1$，就可以得到一个$0-1$矩阵。对矩阵中$1$的个数计数。</p>
<p>行计数：对于某一个$l$元集合，有$\binom{n-l}{k-l}]$个$k$元集合包含它，共有$|F|$个，行计数$1$的个数为$|F|\binom{n-l}{k-l}$</p>
<p>列计数：每个$B_i$必包含一个$A_i$，则每一列至少有一个$1$，可以得到$|F|\binom{n-l}{k-l} \geq {n\choose k}$</p>
<h2 id="Zarankiewicz’s-problem"><a href="#Zarankiewicz’s-problem" class="headerlink" title="Zarankiewicz’s problem"></a>Zarankiewicz’s problem</h2><blockquote>
<p>对于一个$n\times n$的$0-1$矩阵，如果不存在$a\times a$的全$1$子矩阵，那么这个$nxn$的矩阵最多有多少个1？</p>
<p>等价于：用二部图重新表述这个问题。一个部分大小为$n$的二部图$G=(V_1,V_2,E)$，其中$V_1,V_2$是顶点的不相交$n$元集合，$E\in V_1\times V_2$是边的集合。令$K_a(n)$为最小整数$k$边，使得任意大小为$n$且边数大于k的二部图至少包含一个$a\times a-clique$。对于任意的自然数$n$和$a$，</p>
</blockquote>
<script type="math/tex; mode=display">
K_a(n) \leq (a-1)^{\frac{1}{a} }n^{2-\frac{1}{a} }+(a-1)n</script><p>对$S= \{(x,A)|x\in V_1,A \in V_2,|A|=a,且x与A中所有点都有边相连\}$计数, 即对下图中的结构进行计数。</p>
<p><img src="/img/0607-1.png" style="zoom:33%;" /></p>
<p>固定$x$：从与$x$相连的元素中取$A$，设$x$的neighbor为$d(x)$，那么A有$\sum_{x\in V_1}\binom{d(x)}{a}$种选法，且$|S|=\sum_{x\in V_1}\binom{d(x)}{a}$</p>
<p>固定$A$：从$n$中选出$a$元集合，与之对应相连的$x$最多有$(a-1)$个，否则就会出现$a\times a-clique$，即$|S| \leq \binom{n}{a}(a-1)$</p>
<p>即$\sum_{x\in V_1}\binom{d(x)}{a}\leq \binom{n}{a}(a-1)$</p>
<blockquote>
<p>Jensen不等式，对凸函数有：</p>
<script type="math/tex; mode=display">
s.t.\sum_{i=1}^n\lambda_i = 1</script><script type="math/tex; mode=display">
\sum_{i=1}^n\lambda_if(x_i)\geq f(\sum_{i=1}^n\lambda_ix_i),</script><p>Jensen不等式可由数学归纳法证明，略。</p>
</blockquote>
<p>令$f(x)=\binom{x}{a}$,$x_i=d(x_i)$;</p>
<p>根据Jensen不等式，有</p>
<p>$\frac{1}{n}\sum_{x\in V_1}\binom{d(x)}{a}\geq \binom{\frac{1}{n}\sum_{x\in V_1}d(x)}{a}$</p>
<p>$\sum_{x\in V_1}\binom{d(x)}{a}\geq n\binom{\frac{1}{n}\sum_{x\in V_1}d(x)}{a}=n\binom{\frac{|E|}{n} }{a}$(因为为二部图，则degree为一倍边数)</p>
<p>即$n\binom{\frac{|E|}{n} }{a}\leq \binom{n}{a}(a-1)$</p>
<p>经过放缩有$n(\frac{|E|}{n}-(a-1))^a&lt;\frac{n(|E|/n)(|E|/n-1)…(|E|/n-(a-1))}{a!}=n\binom{\frac{|E|}{n} }{a}$</p>
<p>$\binom{n}{a}(a-1)=\frac{n(n-1)…(n-(a-1))}{a!}(a-1)&lt;\frac{n^a}{a!}(a-1)$，两边同时开a次方即可解。</p>
<ul>
<li>$K_a(n)$的下界可以用概率方法求得</li>
</ul>
<h2 id="H-free图"><a href="#H-free图" class="headerlink" title="H-free图"></a>H-free图</h2><blockquote>
<p>一个有$n$个顶点的无$H$图可以最多有多少条边?</p>
<p>定理：如果图$G=(V，E)$中不包含4个点的圈, 即$C_4-free$，那么有$|E|\leq \left \lfloor n/4(1+\sqrt{4n-3}) \right \rfloor$</p>
</blockquote>
<p>令点集$V={1，2，…，n}$，用于双计数的集合为$S=\{(u,\{v,w\})|u与v,w都邻接，且v≠w\}$，即对下图中的结构进行计数。</p>
<p><img src="/img/0607-1.png" style="zoom:33%;" /></p>
<p>固定$u$,那么$v$和$w$只能在度为$d(u)$的点中选取，即$\binom{d(u)}{2}$，有$\sum _{u\in V}\binom{d(u)}{2}=|S|$；</p>
<p>固定$v$和$w$，最多只有一个点可以和它们都关联，那么有$\binom{n}{2}\geq |S|$，</p>
<p>那么，$\sum _{u\in V}d^2(u)\leq \sum _{u\in V}d(u)+n(n-1)$,</p>
<blockquote>
<p>柯西—施瓦茨不等式，$|(\alpha ,\beta )|\leq ||\alpha ||*||\beta ||$</p>
<p>上述不等式中对应的分别是$[d(u_1),d(u_2)….d(u_n)]$，$(1,1,…1)$。</p>
</blockquote>
<p>由柯西—施瓦茨不等式得，$n\sum_{u\in V}d^2(n)\geq (\sum_{u\in V}d(n)*1)^2$，代入上式，$\frac{(\sum_{u\in V} d(u))^2}{n}\leq \sum_{u\in V}d(u)+n)n-1$，</p>
<p>由握手定理得$4|E|^2\leq n2|E|+n^2(n-1)$，求解n可得上述结论。</p>
<h2 id="三计数"><a href="#三计数" class="headerlink" title="三计数"></a>三计数</h2><blockquote>
<p>在超图中，有</p>
<script type="math/tex; mode=display">
\sum_{x\in X}d^2(x)=\sum_{A\in F} \sum_{x\in A}d(x)=\sum_{A\in F} \sum_{B\in F}|A\cap B|</script></blockquote>
<p>对于集合$(X,F)$，$X$为点集合，$F$为超边集合，对三元组${(x,A,B)|A,B∈F,x∈A，x∈B}$计数。</p>
<p>左：$x$在全集$X$上，$A，B$集合均包含点$x$；</p>
<p>中：先选出在$A$的$x$，再使得$x$在$B$中；</p>
<p>右：先选出$A$和$B$集合，使得$x$在$A$和$B$上，即在$A\cap B$上。</p>
<h2 id="整除关系"><a href="#整除关系" class="headerlink" title="整除关系"></a>整除关系</h2><blockquote>
<p>假设两个有限集$R$和$C$和一个子集$S\subseteq R\times C$。无论何时$(p，g)∈s $那么认为$p$和$q$是关联的。</p>
<p>设<img src="https://img.it610.com/image/info8/b4c6f817626645db87ab41f3c50e6db6.gif" alt="r_p">表示$p$固定，与$p$关联的元素数目；$c_p$表示$q$固定，与$q$关联的元素数目。有</p>
<script type="math/tex; mode=display">
\sum_{p\in R}r_p=|S|=\sum_{q\in C}c_q</script></blockquote>
<p>假设$M_{|p|\times |q|}$的关联矩阵使用双计数进行证明，矩阵中若$p_i$和$q_j$相关联，$a_{ij}$则置为$1$，否则为$0$，那么$|S|$就是矩阵$M$中全部$1$的个数，等式的第一项可从行计数，最后一项可从列计数角度统计矩阵中1的个数。</p>
<p>例：</p>
<p>$R=C={1，2，…，n}$，集合$S=\{(i,j)|i可以整除j\}$，</p>
<p>$t(j)$表示$j$的因子的数目，如$j=4$，因子有$1,2,4$，那么$t(4)=3$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i/j</th>
<th style="text-align:center">1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
\overline{t(j)}=\frac{1}{n}\sum_{j=1}^{n}t(j)=\frac{1}{n}\sum_{i=1}^{n}\left \lfloor n/i \right \rfloor</script><script type="math/tex; mode=display">
\frac{1}{n}\sum_{i=1}^{n}(\frac{n}{j}-1)<\frac{1}{n}\sum_{i=1}^{n}\left \lfloor n/i \right \rfloor\leq \frac{1}{n}\sum_{i=1}^{n}\frac{n}{i}=\sum_{i=1}^{n}\frac{1}{i}</script><script type="math/tex; mode=display">
\sum_{i=1}^{n}\frac{1}{i}-1 < t(j) \leq lnn</script><script type="math/tex; mode=display">
|\overline{t(j)}-lnn|<1</script><h2 id="9-Sperner-Lemma"><a href="#9-Sperner-Lemma" class="headerlink" title="9. Sperner Lemma"></a>9. Sperner Lemma</h2><blockquote>
<p>假设某个顶点为$V1、V2、V3$的“大”三角形被三角化了(也就是说，被分解成有限数量的“小”三角形，这些“小”三角形每条边都能拼接在一起)。</p>
<p>假设三角化中的顶点从集合$\{1,2,3\}$中获取颜色，使得$V_i$接收颜色$i$(对于每个$i$)，并且沿着$V_i$到$V_i$的边的顶点只用$i$和$j$的颜色，而内部顶点用1、2或3的颜色任意着色。那么在三角测量中一定有一个小的“三色”三角形。</p>
</blockquote>
<p><img src="/img/0607-3.png" /></p>
<p><strong>证明：</strong></p>
<p>假定大三角形外部有一点$A$，每一个小三角形中心都有一个顶点$O$，若小三角形含有1，2顶点，则从$O$经过1，2点构成的边形成一条边(即出度)，如下图</p>
<p><img src="/img/0607-4.png" /></p>
<p>根据握手定理可知，度之和必为偶数， 在$V_1$和$V_2$构成的边上，观察可得出度必为奇数，即边上(1,2).(2,1)的线段必有奇数个，那么在小三角形必存在奇数度的三角形，即必存在1度的三角形，得证。</p>
<p>参考：<a href="https://www.it610.com/article/1295411404924329984.htm">【图论学习笔记二】双计数(Double Counting) - it610.com</a></p>
]]></content>
      <tags>
        <tag>图与网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/07/07/jdbc/</url>
    <content><![CDATA[<blockquote>
<p>Java DataBase Connectivity, Java连接数据库，是SUN公司制定的一套接口, java.sql.*;</p>
<p>后期将集成到Mybatis框架中。</p>
</blockquote>
<span id="more"></span>
<p>从官网下载对应的驱动jar包，将其配置到环境变量classpath。</p>
<p>classpath=.;D:\course\06-JDBC\resources\MySql Connector Java 5.1.23\mysql-connector-java-5.1.23-bin.jar</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 1、注册驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();	<span class="comment">//多态，父类型引用指向子类型对象</span></span><br><span class="line">        DriverManager.registerDriver(driver); <span class="comment">//静态方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册驱动的另一种方法</span></span><br><span class="line">        <span class="comment">//Class.forName(driver);</span></span><br><span class="line">        <span class="comment">//不用接受返回值，只想用类加载这个操作，执行静态代码块完成注册驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取连接</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">				url包括哪几部分:协议，IP，Port，资源名				</span></span><br><span class="line"><span class="comment">				eg：http://180.101.49.11:80/index.html</span></span><br><span class="line"><span class="comment">			http:// 通信协议; 180.101.49.11 IP地址; 80 端口号; index.html 资源名</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mydatabase&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;146&quot;</span>;</span><br><span class="line">        <span class="comment">// static Connection getConnection(String url, String user, String password)</span></span><br><span class="line">        conn = DriverManager.getConnection(url,user,password); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;数据库连接对象&quot; + conn);	</span></span><br><span class="line">        <span class="comment">//数据库连接对象com.mysql.jdbc.JDBC4Connection@1ae369b7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、获取数据库操作对象</span></span><br><span class="line">        <span class="comment">// Statement createStatement() 创建一个 Statement 对象来将 SQL 语句发送到数据库。</span></span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、执行sql语句</span></span><br><span class="line">        <span class="comment">// int executeUpdate(String sql) </span></span><br><span class="line">        <span class="comment">// 专门执行DML语句,返回值是“影响数据库中的记录条数”</span></span><br><span class="line">        <span class="comment">// 这里的sql语句不用;</span></span><br><span class="line">        <span class="keyword">int</span> count = stmt.executeUpdate(<span class="string">&quot;update dept set dname = &#x27;销售部&#x27;,</span></span><br><span class="line"><span class="string">                                       loc = &#x27;合肥&#x27; where deptno = 20;&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(count == 1 ? &quot;保存成功&quot;:&quot;保存失败&quot;);</span></span><br><span class="line">		<span class="comment">// 5、处理查询结果集</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6、释放资源, 从小到大依次关闭</span></span><br><span class="line">            <span class="comment">// 释放Statement</span></span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>	&#123;</span><br><span class="line">                    stmt.close();	</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放Connection</span></span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>	&#123;</span><br><span class="line">                    conn.close();	</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理返回结果"><a href="#处理返回结果" class="headerlink" title="处理返回结果"></a>处理返回结果</h2><p>executeUpdate：insert/update/delete, 返回结果对表文件操作时，受影响行数</p>
<p>executeQuery：查询命令【select  *  from 表名】，返回结果是查询命令得到【临时表】，ResultSet实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="comment">//rs = stmt.executeQuery(&quot;select empno,ename,sal from emp&quot;);</span></span><br><span class="line"><span class="comment">//遍历查询到的结果</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="comment">//按顺序取</span></span><br><span class="line">    String empno = rs.getString(<span class="number">1</span>);</span><br><span class="line">    String ename = rs.getString(<span class="number">2</span>);</span><br><span class="line">    String sal = rs.getString(<span class="number">3</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + sal);</span><br><span class="line">	<span class="comment">//按名称取出</span></span><br><span class="line">    String empno = rs.getString(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">    String ename = rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">    String sal = rs.getString(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + sal);</span><br><span class="line">	<span class="comment">//类型+顺序</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String ename = rs.getString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="number">3</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + (sal + <span class="number">100</span>));</span><br><span class="line">	<span class="comment">//类型+名称</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">    String ename = rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + (sal + <span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用动态资源绑定器传参"><a href="#使用动态资源绑定器传参" class="headerlink" title="使用动态资源绑定器传参"></a>使用动态资源绑定器传参</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResourceBundle bundle = ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>); <span class="comment">//.properties后缀不用写</span></span><br><span class="line">String driver = bundle.getString(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">String url = bundle.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String user = bundle.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password = bundle.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">conn = DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mydatabase</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">146</span></span><br></pre></td></tr></table></figure>
<h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><p>问题：用户输入语句含有sql语句关键字，完成了sql语句的拼接，参与编译，导致原sql语句含义被扭曲。</p>
<p>解决方法：用户提供的信息不参与编译过程，用java.sql.PreparedStatement（继承java.sql.Statement）</p>
<ul>
<li>PreparedStatement属于预编译的数据库操作对象，原理：预先对sql语句的框架进行编译，再给sql语句传“值”，使用较多。</li>
<li>PreparedStatement效率高。只用预编译一次，可执行多次。在编译阶段做安全检查（ps.setString()）Statement执行一次编译一次</li>
<li>要求支持sql语句拼接时使用Statement。（如升/降序是在语句末尾拼接asc/desc）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用PreparedStatement模拟登录，防止sql注入现象</span></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Statement stat = null;</span></span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1、注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">// 2、获取连接</span></span><br><span class="line">    conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;146&quot;</span>);</span><br><span class="line">    <span class="comment">// 3、获取预编译的数据库操作对象</span></span><br><span class="line">    <span class="comment">// sql语句的框架中，一个?，表示一个占位符，一个?将来接收一个值。注意：?不用单引号括起来</span></span><br><span class="line">    String sql = <span class="string">&quot;select * from t_user where userName = ? and userPassword = ?&quot;</span>;</span><br><span class="line">    <span class="comment">// 程序执行到此处，会发送sql语句框架给DBMS，DBMS对sql语句框架进行预编译。</span></span><br><span class="line">    ps = conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 给占位符?传值，第一个?的下标是1，第二个?的下标是2（JDBC中下标都从1开始）</span></span><br><span class="line">    ps.setString(<span class="number">1</span>,userLoginInfo.get(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">    ps.setString(<span class="number">2</span>,userLoginInfo.get(<span class="string">&quot;userPassword&quot;</span>));</span><br><span class="line">    <span class="comment">// 4、执行sql语句</span></span><br><span class="line">    rs = ps.executeQuery();</span><br><span class="line">    <span class="comment">// 5、处理结果集</span></span><br><span class="line">    <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">        loginSuccess = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 6、释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升降序排列时需要sql注入</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入desc或者asc&quot;</span>);</span><br><span class="line">String keyWords = s.nextLine();</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">    conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;146&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//createStatement可以完成拼接</span></span><br><span class="line">    stmt = conn.createStatement();</span><br><span class="line">    String sql = <span class="string">&quot;select ename from emp order by ename &quot;</span> + keyWords;</span><br><span class="line">    rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">        System.out.println(rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDBC事务自动提交"><a href="#JDBC事务自动提交" class="headerlink" title="JDBC事务自动提交"></a>JDBC事务自动提交</h2><p>即执行任一条DML语句，则自动提交一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//conn.setAutoCommit(false); // 开启事务</span></span><br><span class="line"><span class="comment">//conn.commit(); // 提交事务</span></span><br><span class="line"><span class="comment">//conn.rollback(); // 回滚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        conn = DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">            <span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="string">&quot;146&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------将自动提交改为手动提交------------------------------</span></span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// 开启事务</span></span><br><span class="line">        <span class="comment">//-----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取预编译的数据库操作对象</span></span><br><span class="line">        String sql = <span class="string">&quot;update t_act set balance = ? where actno = ? &quot;</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        ps.setInt(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">        ps.setDouble(<span class="number">2</span>,<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行sql语句</span></span><br><span class="line">        <span class="keyword">int</span> count = ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String s = null;</span></span><br><span class="line"><span class="comment">            s.toString();</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        ps.setInt(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">        ps.setDouble(<span class="number">2</span>,<span class="number">222</span>);</span><br><span class="line">        count += ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        System.out.println(count == <span class="number">2</span> ? <span class="string">&quot;转账成功&quot;</span> : <span class="string">&quot;转账失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -----------程序能执行到此处，说明没有异常，事务结束，手动提交数据----------------------</span></span><br><span class="line">        conn.commit(); <span class="comment">// 提交事务</span></span><br><span class="line">        <span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// --------遇到异常，回滚-------------------</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback(); <span class="comment">// 回滚</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//-----------------------------------------</span></span><br><span class="line">    &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>行级锁（悲观锁）:for update 当前事务结束之前，行结果被锁住，无法修改。事务排队进行，不允许并发<br>乐观锁：多线程并发，事务不需要排队，都可以修改，需要版本号。</p>
<h2 id="DAO与Entity"><a href="#DAO与Entity" class="headerlink" title="DAO与Entity"></a>DAO与Entity</h2><p>DAO(Data Access Object) 数据访问对象，将数据库操作都封装起来。包括：</p>
<p>1）实体类Dept：用于存放与传输对象数据。</p>
<p>2）数据库连接和关闭工具类JdbcUtil： 避免了数据库连接和关闭代码的重复使用，方便修改。</p>
<p>3）DAO 实现类DeptDao： 针对不同数据库给出DAO接口定义方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实体类（一张表对应一个实体，用于描述表结构，一个实例对象对应表中一个数据行，属性与表中字段保持一致）</span></span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.entity;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deptNo;</span><br><span class="line">    <span class="keyword">private</span> String  dname;</span><br><span class="line">    <span class="keyword">private</span> String  loc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDeptNo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> deptNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeptNo</span><span class="params">(Integer deptNo)</span> </span>&#123;<span class="keyword">this</span>.deptNo = deptNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDname</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> dname;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDname</span><span class="params">(String dname)</span> </span>&#123;<span class="keyword">this</span>.dname = dname;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoc</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> loc;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoc</span><span class="params">(String loc)</span> </span>&#123;<span class="keyword">this</span>.loc = loc;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dept</span><span class="params">(Integer deptNo, String dname, String loc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deptNo = deptNo;</span><br><span class="line">        <span class="keyword">this</span>.dname = dname;</span><br><span class="line">        <span class="keyword">this</span>.loc = loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据库连接和关闭工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Connection con = <span class="keyword">null</span>;<span class="comment">//类文件属性，可以在类文件中所有的方法中使用</span></span><br><span class="line">    <span class="keyword">private</span>  PreparedStatement ps=<span class="keyword">null</span>;<span class="comment">//类文件属性，可以在类文件中所有的方法中使用</span></span><br><span class="line">    <span class="comment">//静态语句块 static&#123;&#125;</span></span><br><span class="line">    <span class="comment">//在当前类文件第一次被加载到JVM时，JVM将会自动调用当前类文件静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//1.注册数据库服务器提供的Driver接口实现类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装Connection对象创建细节 不需要考虑使用对象创建细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Connection  <span class="title">createCon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection对象创建失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象创建细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createStatement</span><span class="params">(String sql)</span></span>&#123;</span><br><span class="line">        Connection con = createCon();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = con.prepareStatement(sql);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象与Connection对象销毁细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ps!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象与Connection对象与ResultSet对象销毁细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DAO接口实现（命名为表名+Dao，实现CRUD功能）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  JdbcUtil util = <span class="keyword">new</span> JdbcUtil();</span><br><span class="line">    <span class="comment">//添加数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(String deptNo,String dname,String loc)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;insert into dept (deptNo,dname,loc) values(?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setInt(<span class="number">1</span>, Integer.valueOf(deptNo));</span><br><span class="line">            ps.setString(<span class="number">2</span>, dname);</span><br><span class="line">            ps.setString(<span class="number">3</span>, loc);</span><br><span class="line">            result=ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String deptNo)</span></span>&#123;</span><br><span class="line">        String sql =<span class="string">&quot;delete from dept where deptno=?&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setInt(<span class="number">1</span>, Integer.valueOf(deptNo));</span><br><span class="line">            result = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String deptNo,String dname,String loc)</span></span>&#123;</span><br><span class="line">        String  sql =<span class="string">&quot;update dept set dname=?,loc=? where deptno=?&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setString(<span class="number">1</span>, dname);</span><br><span class="line">            ps.setString(<span class="number">2</span>, loc);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, Integer.valueOf(deptNo));</span><br><span class="line">            result = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql =<span class="string">&quot;select * from dept&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">//将是临时表数据行转换为实体类实例对象保管</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">int</span> deptNo = rs.getInt(<span class="string">&quot;deptno&quot;</span>);</span><br><span class="line">                String dname = rs.getString(<span class="string">&quot;dname&quot;</span>);</span><br><span class="line">                String loc = rs.getString(<span class="string">&quot;loc&quot;</span>);</span><br><span class="line">                Dept dept = <span class="keyword">new</span> Dept(deptNo, dname, loc);</span><br><span class="line">                list.add(dept);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo配置</title>
    <url>/2021/07/07/hexo/</url>
    <content><![CDATA[<blockquote>
<p>hexo，快速、简洁且高效的博客框架</p>
</blockquote>
<span id="more"></span>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="regexp">//</span> 清除缓存</span><br><span class="line">hexo g <span class="regexp">//</span> 创建静态文件</span><br><span class="line">hexo s <span class="regexp">//</span> 本地运行</span><br><span class="line">hexo d <span class="regexp">//</span> 部署到远程</span><br></pre></td></tr></table></figure>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>主题文件夹放在<code>./theme/</code> 下，<code>_config.yml</code> 中<code>theme:</code> 改成主题文件夹名</p>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>文章存放路径<code>/source/_posts/*.md</code></p>
<ul>
<li>文章头部</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="string">/8/3</span> <span class="number">18</span><span class="string">:20:00</span> <span class="string">//发布时间</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">hexo</span> <span class="string">//分类</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span> <span class="string">//使用mathjax渲染公式</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">hexo博客</span> <span class="string">//标题</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文章折叠</li>
</ul>
<p>需要折叠的部分之前加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>公式</li>
</ul>
<p>卸载原有公式渲染引擎 <code>npm uninstall hexo-renderer-marked --save</code> </p>
<p>安装kramed <code>npm install hexo-renderer-kramed --save</code></p>
<blockquote>
<p>问题1：kramed对<code>\,&#123;,&#125;</code>有转义，无法正常显示</p>
<p>解决方法：</p>
<p>定位到博客根目录，找到<code>/node_modules/kramed/lib/rules/inline.js</code>文件，进行部分修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,      第11行，将其修改为</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    第20行，将其修改为</span></span><br><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<p>问题2：公式中以下符号会解析错误<code>&#123;&#123;` `&#125;&#125;</code> <code>&#123;%` `%&#125;</code></p>
<p>解决方法：中间加空格，变为<code>&#123; &#123;</code> <code>&#125; &#125;</code> <code>&#123; %</code> <code>% &#125;</code></p>
</blockquote>
<h2 id="多分支管理"><a href="#多分支管理" class="headerlink" title="多分支管理"></a>多分支管理</h2><p>同时管理了两个分支：</p>
<ul>
<li>master -负责展示静态网页</li>
<li>hexo -备份本地hexo文件（默认分支）</li>
</ul>
<p>执行<code>hexo d</code>时，自动更新master分支（config文件中deploy配置）</p>
<p>add, commit, pull更新hexo分支需要备份的源文件</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>无法解决的问题尝试清除缓存<code>hexo clean</code>后重新生成</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA代理模式</title>
    <url>/2021/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>代理模式的一个典型应用：AOP(面向切面编程)</p>
</blockquote>
<span id="more"></span>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>a类本来需要调用c类（目标类）的方法完成某个功能， 但是c不让a调用。 </p>
<p>a —&gt;不能直接调用 c的方法。<br>在a 和 c 直接创建一个 b 代理，c让b访问。 c，b实现相同的功能（接口）。<br>a —&gt;访问b—&gt;访问c</p>
<p>作用：</p>
<ul>
<li><p>功能增强： 在原有的功能上，增加了额外的功能。 新增加的功能，叫做功能增强</p>
</li>
<li><p>控制访问： 代理类不让你访问目标，例如商家不让用户访问厂家。 </p>
</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>代理类需要手工实现。即自己创建一个java类，表示代理类。所要代理的目标类是确定的。</p>
<ul>
<li>缺点：当目标类和代理类很多时候，<ul>
<li>当目标类增加， 代理类可能也需要成倍的增加。 代理类数量过多。</li>
<li>当接口中功能增加或修改，会影响众多的实现类，厂家类，代理类都需要修改。影响较大。</li>
</ul>
</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在程序执行过程中，使用jdk的<strong>反射</strong>机制，创建<strong>代理类对象</strong>， 并动态的指定要代理目标类。</p>
<p>即使目标类很多，代理类数量可以很少；当修改了接口中的方法时，不影响代理类。</p>
<p>动态代理是一种创建java对象的能力，不用创建代理类，就能创建代理类对象。</p>
<p>两种实现方式：jdk动态代理；cglib动态代理</p>
<h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><ul>
<li>使用java反射包中的类和接口实现动态代理的功能。</li>
<li>反射包 java.lang.reflect , 里面有三个类 ： InvocationHandler , Method, Proxy.</li>
<li>要求目标类实现接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用反射调用方法</span></span><br><span class="line">HelloService service = <span class="keyword">new</span> HelloServiceImpl(); <span class="comment">//创建类对象service</span></span><br><span class="line">service.sayHello(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 通过对象调用sayHello()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反射调用方法</span></span><br><span class="line">Method method =  HelloService.class.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class); <span class="comment">// 获取method对象（sayHello()方法）</span></span><br><span class="line">HelloService service2 = <span class="keyword">new</span> HelloServiceImpl2();</span><br><span class="line">Object ret = method.invoke(service2, <span class="string">&quot;李四&quot;</span>); <span class="comment">// invoke()方法调用对象service2的方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>InvocationHandler接口，只有一个方法invoke()，代理对象要完成的功能。（目标方法/功能增强）</li>
<li>Method类：表示目标类中的方法。通过Method可以执行某个目标类的方法，method.invoke(目标对象，方法的参数)</li>
<li>Proxy类：创建代理对象。之前创建对象是 new ，现在使用Proxy类的静态方法 newProxyInstance() 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现InvocationHandler接口，完成代理类要做的功能（1.调用目标方法，2.功能增强）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySellHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>; <span class="comment">// 为目标类创建对象（活动的，不是固定的，需要传入进来）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySellHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 实现invoke方法，完成代理类要做的功能</span></span><br><span class="line">    <span class="comment">// Object proxy: jdk创建的代理对象，无需赋值。</span></span><br><span class="line">	<span class="comment">// Method method: 目标类中的方法，jdk提供</span></span><br><span class="line">    <span class="comment">// Object[] args：目标类中方法的参数， jdk提供。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object res  = <span class="keyword">null</span>;</span><br><span class="line">        res =  method.invoke(target,args); <span class="comment">// 反射，执行目标对象target的method方法</span></span><br><span class="line">		<span class="comment">//功能增强，加价</span></span><br><span class="line">        <span class="keyword">if</span>( res != <span class="keyword">null</span> )&#123;</span><br><span class="line">            Float price = (Float)res;</span><br><span class="line">            price = price + <span class="number">25</span>;</span><br><span class="line">            res = price;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建代理对象，使用Proxy</span></span><br><span class="line"><span class="comment">//1. 创建目标对象</span></span><br><span class="line">UsbSell factory = <span class="keyword">new</span> UsbKingFactory();</span><br><span class="line"><span class="comment">//2.创建InvocationHandler对象</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MySellHandler(factory);</span><br><span class="line"><span class="comment">//3.创建代理对象</span></span><br><span class="line">UsbSell proxy = (UsbSell) Proxy.newProxyInstance(</span><br><span class="line">    factory.getClass().getClassLoader(),</span><br><span class="line">    factory.getClass().getInterfaces(),</span><br><span class="line">    handler</span><br><span class="line">	);</span><br><span class="line"><span class="comment">//4.通过代理执行方法</span></span><br><span class="line"><span class="keyword">float</span> price = proxy.sell(<span class="number">1</span>); <span class="comment">// 代理对象proxy调用目标类factory中的sell方法</span></span><br></pre></td></tr></table></figure>
<h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><ul>
<li><p>cglib是第三方的工具库， 创建代理对象。</p>
</li>
<li><p>原理是继承， cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法， 实现功能的修改。要求目标类不能是final的， 方法也不能是final的。</p>
</li>
<li><p>cglib的要求目标类比较宽松， 只要能继承即可。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet规范</title>
    <url>/2021/07/09/servlet/</url>
    <content><![CDATA[<blockquote>
<p>Servlet规范，来自于JAVAEE规范中的一种。</p>
<p>后期使用springMVC框架。</p>
</blockquote>
<span id="more"></span>
<p>Servlet规范指定【动态资源文件】开发步骤；Http服务器调用动态资源文件规则；Http服务器管理动态资源文件实例对象规则。</p>
<p>Tomcat服务器下lib文件中servlet-api.jar存放Servlet接口（javax.servlet.Servlet接口）</p>
<p>Servlet规范任务中，Http服务器能调用的【动态资源文件】必须是一个<strong>Servlet接口实现类</strong></p>
<h2 id="Servlet规范开发步骤"><a href="#Servlet规范开发步骤" class="headerlink" title="Servlet规范开发步骤"></a>Servlet规范开发步骤</h2><ul>
<li>创建一个Java类继承HttpServlet父类，使之成为一个Servlet接口实现类</li>
</ul>
<ul>
<li><p>重写两个方法，doGet或则doPost</p>
</li>
<li><p>将Servlet接口实现类信息【注册】到Tomcat服务器</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /web/WEB-INF/web.xml文件中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将Servlet接口实现类类路径地址交给Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span><span class="comment">&lt;!--声明servlet接口实现类类路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    Tomcat  String mm = &quot;com.bjpowernode.controller.OneServlet&quot;</span><br><span class="line">    <span class="comment">&lt;!--为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/one<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--设置简短请求别名,别名在书写时必须以&quot;/&quot;为开头--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期:"></a>Servlet对象生命周期:</h2><ul>
<li>网站中所有的Servlet接口实现类的实例对象，只能由Http服务器(如Tomcat，相当于servlet的容器)负责额创建。 开发人员不能手动创建。</li>
</ul>
<ul>
<li>在默认的情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时，自动创建这个Servlet接口实现类的实例对象；在手动配置情况下，要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--手动配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>30<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span><span class="comment">&lt;!--填写一个大于0的整数即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>在Http服务器运行期间，一个Servlet接口实现类只能被创建出一个实例对象</p>
</li>
<li><p>在Http服务器关闭时刻，自动将网站中所有的Servlet对象进行销毁</p>
</li>
</ul>
<h2 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h2><p>来自于Servlet规范，在Tomcat中存在servlet-api.jar，实现类由Http服务器负责提供。负责将doGet/doPost方法<strong>执行结果</strong>写入到【响应体】交给浏览器。惯于将HttpServletResponse接口修饰的对象称为【<strong>响应对象</strong>】</p>
<p>主要功能:</p>
<ul>
<li><p>执行结果以二进制形式写入到【响应体】</p>
</li>
<li><p>设置响应头中[content-type]属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">         String result=<span class="string">&quot;Java&lt;br/&gt;Mysql&lt;br/&gt;HTML&lt;br/&gt;&quot;</span>; <span class="comment">//既有文字信息又有HTML标签命令</span></span><br><span class="line">        <span class="comment">//设置响应头content-type</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//向Tomcat索要输出流</span></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">//通过输出流将结果写入到响应体</span></span><br><span class="line">        out.print(result);</span><br><span class="line">    &#125;<span class="comment">//doGet执行完毕，Tomcat将响应包推送给浏览器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置响应头中【location】属性，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String result =<span class="string">&quot;http://www.baidu.com?userName=mike&quot;</span>;</span><br><span class="line">    <span class="comment">//通过响应对象，将地址赋值给响应头中location属性</span></span><br><span class="line">    response.sendRedirect(result);<span class="comment">//[响应头  location=&quot;http://www.baidu.com&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//浏览器在接收到响应包之后，如果发现响应头中存在location属性，自动通过地址栏向location指定网站发送请求。sendRedirect方法远程控制浏览器请求行为【请求地址，请求方式，请求参数】</span></span><br></pre></td></tr></table></figure>
<h2 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h2><p>来自于Servlet规范中，在Tomcat中存在servlet-api.jar，接口实现类由Http服务器负责提供。负责在doGet/doPost方法运行时读取Http请求协议包中信息，修饰的对象称为【请求对象】</p>
<p>作用:</p>
<ul>
<li>读取Http请求协议包中【请求行】信息</li>
<li>读取保存在Http请求协议包中【请求头】或则【请求体】中请求参数信息</li>
<li>代替浏览器向Http服务器申请资源文件调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象，读取【请求行】中【url】信息</span></span><br><span class="line">         String url = request.getRequestURL().toString();</span><br><span class="line">        <span class="comment">//2.通过请求对象，读取【请求行】中【method】信息</span></span><br><span class="line">         String method = request.getMethod();</span><br><span class="line">        <span class="comment">//3.通过请求对象，读取【请求行】中uri信息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * URI：资源文件精准定位地址，在请求行并没有URI这个属性。</span></span><br><span class="line"><span class="comment">        *      实际上URL中截取一个字符串，这个字符串格式&quot;/网站名/资源文件名&quot;</span></span><br><span class="line"><span class="comment">        *      URI用于让Http服务器对被访问的资源文件进行定位</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String uri =  request.getRequestURI();<span class="comment">// substring</span></span><br><span class="line">        System.out.println(<span class="string">&quot;URL &quot;</span>+url);</span><br><span class="line">        System.out.println(<span class="string">&quot;method &quot;</span>+method);</span><br><span class="line">        System.out.println(<span class="string">&quot;URI &quot;</span>+uri);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.通过请求对象获得【请求头】中【所有请求参数名】</span></span><br><span class="line">        Enumeration paramNames =request.getParameterNames(); </span><br><span class="line">        <span class="comment">//将所有请求参数名称保存到一个枚举对象进行返回</span></span><br><span class="line">        <span class="keyword">while</span>(paramNames.hasMoreElements())&#123;</span><br><span class="line">            String paramName = (String)paramNames.nextElement();</span><br><span class="line">            <span class="comment">//2.通过请求对象读取指定的请求参数的值</span></span><br><span class="line">            String value = request.getParameter(paramName);</span><br><span class="line">            System.out.println(<span class="string">&quot;请求参数名 &quot;</span>+paramName+<span class="string">&quot; 请求参数值 &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        浏览器以GET方式发送请求,请求参数保存在【请求头】,在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求头二进制内容由Tomcat负责解码，Tomcat9.0默认使用【utf-8】字符集，可以解释一切国家文字</span></span><br><span class="line"><span class="comment">	浏览器以POST方式发送请求，请求参数保存在【请求体】,在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求体二进制内容由当前请求对象（request）负责解码。request默认使用[ISO-8859-1]字符集，一个东欧语系字符集，此时如果请求体参数内容是中文，将无法解码只能得到乱码</span></span><br><span class="line"><span class="comment">	解决方案:在Post请求方式下，在读取请求体内容之前，应该通知请求对象使用utf-8字符集对请求体内容进行一次重新解码*/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通知请求对象，使用utf-8字符集对请求体二进制内容进行一次重写解码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//通过请求对象，读取【请求体】参数信息</span></span><br><span class="line">        String value = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;从请求体得到参数值 &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请求对象和响应对象生命周期</p>
<ul>
<li>​       在Http服务器接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】</li>
<li>在Http服务器调用doGet/doPost方法时，负责将【请求对象】和【响应对象】作为实参传递到方法，确保doGet/doPost正确执行</li>
<li>在Http服务器准备推送Http响应协议包之前，负责将本次请求关联的【请求对象】和【响应对象】<br>​      销毁</li>
</ul>
<p>【请求对象】和【响应对象】生命周期贯穿一次请求的处理过程中</p>
</blockquote>
<h2 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h2><p>由三位数字组成的一个符号。Http服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中【状态行】上。</p>
<p>如果Http服务器针对本次请求，返回了对应的资源文件，通过Http状态码通知浏览器应该如何处理这个结果</p>
<p>如果Http服务器针对本次请求，无法返回对应的资源文件，通过Http状态码向浏览器解释不能提供服务的原因</p>
<p>分类：<br>100—-599组成；分为5个大类<br>100; 通知浏览器本次返回的资源文件并不是一个独立的资源文件，需要浏览器在接收响应包之后，继续向Http服务器所要依赖的其他资源文件</p>
<p>200，通知浏览器本次返回的资源文件是一个完整独立资源文件，浏览器在接收到之后不需要所要其他关联文件</p>
<p>302，通知浏览器本次返回的不是一个资源文件内容而是一个资源文件地址，需要浏览器根据这个地址自动发起请求来索要这个资源文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;资源文件地址&quot;</span>) <span class="comment">//写入到响应头中location</span></span><br><span class="line"><span class="comment">//而这个行为导致Tomcat将302状态码写入到状态行</span></span><br></pre></td></tr></table></figure>
<p>404: 通知浏览器，由于在服务端没有定位到被访问的资源文件 因此无法提供帮助</p>
<p>405：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet），但是这个Servlet对于浏览器采用的请求方式不能处理</p>
<p>500:通知浏览器，在服务端已经定位到被访问的资源文件（Servlet）这个Servlet可以接收浏览器采用请求方式，但是Servlet在处理请求期间，由于Java异常导致处理失败</p>
<h2 id="多个Servlet之间调用规则："><a href="#多个Servlet之间调用规则：" class="headerlink" title="多个Servlet之间调用规则："></a>多个Servlet之间调用规则：</h2><p>多个Servlet:</p>
<ul>
<li>前提条件：某些来自于浏览器发送请求，往往需要服务端中多个Servlet协同处理。但是浏览器一次只能访问一个Servlet，导致用户需要手动通过浏览器发起多次请求才能得到服务。这样增加用户获得服务难度，导致用户放弃访问当前网站</li>
</ul>
<ul>
<li>提高用户使用感受规则：无论本次请求涉及到多少个Servlet,用户只需要【手动】通知浏览器发起一次请求即可</li>
</ul>
<blockquote>
<p>重定向解决方案</p>
</blockquote>
<p>用户第一次通过【手动方式】通知浏览器访问OneServlet。OneServlet工作完毕后，将TwoServlet地址写入到响应头location属性中，导致Tomcat将302状态码写入到状态行。浏览器接收到响应包之后，读取到302状态。此时浏览器自动根据响应头中location属性地址【自动】发起第二次请求，访问TwoServlet去完成请求中剩余任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;请求地址&quot;</span>) <span class="comment">//将地址写入到响应包中响应头中location属性</span></span><br></pre></td></tr></table></figure>
<ul>
<li>请求地址：既可以把当前网站内部的资源文件地址发送给浏览器 （/网站名/资源文件名）也可以把其他网站资源文件地址发送给浏览器(<a href="http://ip地址:端口号/网站名/资源文件名">http://ip地址:端口号/网站名/资源文件名</a>)</li>
<li>请求次数：浏览器至少发送两次请求，只有第一次请求是用户手动发送。后续请求都是浏览器自动发送的。</li>
<li>请求方式：通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】</li>
<li>缺点:重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间</li>
</ul>
<blockquote>
<p>请求转发解决方案</p>
</blockquote>
<p> 用户第一次通过手动方式要求浏览器访问OneServlet。OneServlet工作完毕后，通过当前的请求对象代替浏览器向Tomcat发送请求，申请调用TwoServlet。Tomcat接收到这个请求之后，自动调用TwoServlet完成剩余任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求对象代替浏览器向Tomcat发送请求</span></span><br><span class="line"><span class="comment">//1.通过当前请求对象生成资源文件申请报告对象</span></span><br><span class="line">RequestDispatcher  report = request.getRequestDispatcher(<span class="string">&quot;/资源文件名&quot;</span>); <span class="comment">//一定要以&quot;/&quot;为开头</span></span><br><span class="line"><span class="comment">//2.将报告对象发送给Tomcat</span></span><br><span class="line">report.forward(request, response)</span><br></pre></td></tr></table></figure>
<ul>
<li>无论本次请求涉及到多少个Servlet,用户只需要手动通过浏览器发送一次请求</li>
</ul>
<ul>
<li>Servlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数增加处理服务速度</li>
</ul>
<p>请求次数：在请求转发过程中，浏览器只发送一次请求</p>
<p>请求地址：只能向Tomcat服务器申请调用当前网站下资源文件地址</p>
<p>请求方式：在请求转发过程中，浏览器只发送一个了个Http请求协议包。参与本次请求的所有Servlet共享同一个请求协议包，因此这些Servlet接收的请求方式与浏览器发送的请求方式保持一致</p>
<h2 id="多个Servlet之间数据共享实现方案："><a href="#多个Servlet之间数据共享实现方案：" class="headerlink" title="多个Servlet之间数据共享实现方案："></a>多个Servlet之间数据共享实现方案：</h2><p>数据共享：OneServlet工作完毕后，将产生数据交给TwoServlet来使用</p>
<p>Servlet规范中提供四种数据共享方案</p>
<ul>
<li><strong>ServletContext接口</strong></li>
</ul>
<p>来自于Servlet规范中一个接口。在Tomcat中存在servlet-api.jar，在Tomcat中负责提供这个接口实现类。</p>
<p>如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享。</p>
<p>习惯于将ServletContext对象称为【全局作用域对象】。</p>
<blockquote>
<p>每一个网站都存在一个全局作用域对象。 这个全局作用域对象【相当于】一个Map.在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中其他Servlet此时都可以从全局作用域对象得到这个数据进行使用。</p>
<p>生命周期：全局作用域对象生命周期贯穿网站整个运行期间</p>
</blockquote>
<p>在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象</p>
<p>在Http服务器运行期间时，一个网站只有一个全局作用域对象，全局作用域对象一直处于存活状态</p>
<p>在Http服务器准备关闭时，负责将当前网站中全局作用域对象 进行销毁处理          </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令实现： 【同一个网站】OneServlet将数据共享给TwoServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象向Tomcat索要当前网站全局作用域对象</span></span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="comment">//2.将数据添加到全局作用域对象，作为共享数据</span></span><br><span class="line">        application.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="number">100</span>);<span class="comment">// map: key-value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象向Tomcat索要当前网站全局作用域对象</span></span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="comment">//2.从全局作用域对象得到指定关键字对应的值</span></span><br><span class="line">        Integer money=(Integer)application.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Cookie类</strong></li>
</ul>
<p>来自于Servlet规范中一个工具类，存在于Tomcat提供servlet-api.jar中。如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于Cookie对象进行数据共享</p>
<p>Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量。在现实生活场景中，Cookie相当于用户在服务端得到【会员卡】</p>
<p>原理: 用户通过浏览器第一次向MyWeb网站发送请求申请OneServlet。OneServlet在运行期间创建一个Cookie存储与当前用户相关数据。OneServlet工作完毕后，【<strong>将Cookie写入到响应头</strong>】交还给当前浏览器。浏览器收到响应响应包之后，将cookie存储在浏览器的缓存一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时。【<strong>浏览器需要无条件的将myWeb网站之前推送过来的Cookie，写入到请求头</strong>】发送过去。此时TwoServlet在运行时，可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现命令:  同一个网站 OneServlet 与  TwoServlet 借助于Cookie实现数据共享</span></span><br><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个cookie对象，保存共享数据（当前用户数据）</span></span><br><span class="line">        Cookie card = <span class="keyword">new</span> Cookie(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;abc&quot;</span>);<span class="comment">// Cookie(String name,String value)</span></span><br><span class="line">        Cookie card1= <span class="keyword">new</span> Cookie(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line">		<span class="comment">//cookie相当于一个map,一个cookie中只能存放一个键值对</span></span><br><span class="line">        <span class="comment">//这个键值对的key与value只能是String,键值对中key不能是中文</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.【发卡】将cookie写入到响应头，交给浏览器</span></span><br><span class="line">        resp.addCookie(card);</span><br><span class="line">        resp.addCookie(card1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TwoServlet&#123;			 </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象从请求头得到浏览器返回的Cookie</span></span><br><span class="line">        Cookie  cookieArray[] = request.getCookies();</span><br><span class="line">        <span class="comment">//2.循环遍历数据得到每一个cookie的key 与 value</span></span><br><span class="line">        <span class="keyword">for</span>(Cookie card:cookieArray)&#123;</span><br><span class="line">            String key =   card.getName(); <span class="comment">//读取key  &quot;key1&quot;</span></span><br><span class="line">            String value = card.getValue();<span class="comment">//读取value &quot;abc&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Cookie销毁时机</p>
</blockquote>
<p>在默认情况下，Cookie对象存放在浏览器的缓存中。只要浏览器关闭，Cookie对象就被销毁</p>
<p>在手动设置情况下，可以要求浏览器将接收的Cookie 存放在客户端计算机上硬盘上，同时需要指定Cookie在硬盘上存活时间。在存活时间范围内，关闭浏览器关闭客户端计算机，关闭服务器，都不会导致Cookie被销毁。在存活时间到达时，Cookie自动从硬盘上被删除</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cookie</span>.setMaxAge(<span class="number">60</span>); //cookie在硬盘上存活<span class="number">1</span>分钟</span><br></pre></td></tr></table></figure>
<p>Cookie域保存在自己浏览器内部，与别人互不干扰，但因为是客户端技术，所以安全性不高。</p>
<ul>
<li><strong>HttpSession接口</strong></li>
</ul>
<p>来自于Servlet规范下一个接口。存在于Tomcat中servlet-api.jar，其实现类由Http服务器提供。Tomcat提供实现类存在于servlet-api.jar。如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于HttpSession对象进行数据共享。习惯于将HttpSession接口修饰对象称为【会话作用域对象】</p>
<blockquote>
<p>HttpSession 与  Cookie 区别：</p>
<p>存储位置:Cookie：存放在客户端计算机（浏览器内存/硬盘）。HttpSession：存放在服务端计算机内存</p>
<p>数据类型：Cookie对象存储共享数据类型只能是String。HttpSession对象可以存储任意类型的共享数据Object</p>
<p>数据数量: 一个Cookie对象只能存储一个共享数据。HttpSession使用map集合，可以存储任意数量共享数据</p>
<p>参照物：Cookie相当于客户在服务端【会员卡】。HttpSession相当于客户在服务端【私人保险柜】</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令实现:   同一个网站（myWeb）下OneServlet将数据传递给TwoServlet</span></span><br><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//2.将数据添加到用户私人储物柜</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;key1&quot;</span>,共享数据)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浏览器访问/myWeb中TwoServlet</span></span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//2.从会话作用域对象得到OneServlet提供的共享数据</span></span><br><span class="line">        Object 共享数据 = session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Http服务器如何将用户与HttpSession关联：cookie</p>
<blockquote>
<p>getSession()  与  getSession(false)</p>
<p>getSession(): 如果当前用户在服务端已经拥有了自己的私人储物。要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。要求tocmat为当前用户创建一个全新的私人储物柜</p>
<p>getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜.要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。此时Tomcat将返回null</p>
</blockquote>
<p>HttpSession销毁时机:</p>
<p>用户与HttpSession关联时使用的Cookie只能存放在浏览器缓存中，在浏览器关闭时，意味着用户与他的HttpSession关系被切断。由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会让Tomcat将浏览器关联的HttpSession进行销毁。为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】，空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟，此时Tomcat认为用户已经放弃了自己的HttpSession，Tomcat就会销毁这个HttpSession</p>
<ul>
<li><strong>HttpServletRequest接口</strong></li>
</ul>
<p>在同一个网站中，如果两个Servlet之间通过【请求转发】方式进行调用，彼此之间共享同一个请求协议包。而一个请求协议包只对应一个请求对象。因此servlet之间共享同一个请求对象，此时可以利用这个<strong>请求对象</strong>在两个Servlet之间实现数据共享。</p>
<p>将请求对象称为【请求作用域对象】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OneServlet通过请求转发申请调用TwoServlet时，需要给TwoServlet提供共享数据</span></span><br><span class="line">OneServlet&#123;				 </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.将数据添加到【请求作用域对象】中attribute属性</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;key1&quot;</span>,数据); <span class="comment">//数据类型可以任意类型Object</span></span><br><span class="line">        <span class="comment">//2.向Tomcat申请调用TwoServlet</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/two&quot;</span>).forward(req,response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从当前请求对象得到OneServlet写入到共享数据</span></span><br><span class="line">        Object 数据 = req.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;				 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监听器接口"><a href="#监听器接口" class="headerlink" title="监听器接口"></a>监听器接口</h2><p>一组来自于Servlet规范下接口，共有8个接口。在Tomcat存在servlet-api.jar包。监听器接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类。监听器接口用于监控【<strong>作用域对象</strong>生命周期变化时刻】以及【作用域对象共享数据变化时刻】</p>
<blockquote>
<p>作用域对象：在Servlet规范中，认为在<strong>服务端内存</strong>中可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】</p>
<p>Servlet规范下作用域对象:</p>
<ul>
<li>ServletContext：全局作用域对象</li>
<li>HttpSession:  会话作用域对象</li>
<li>HttpServletRequest: 请求作用域对象</li>
</ul>
<p>(cookie存放在客户端，故不属于作用域对象)</p>
</blockquote>
<p>监听器接口实现类开发规范：根据监听的实际情况，选择对应监听器接口进行实现；重写监听器接口声明【监听事件处理方法】；在web.xml文件将监听器接口实现类注册到Http服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将监听器接口实现类注册到Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.bjpoewrnode.listener.OneListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ServletContextListener接口</li>
</ul>
<p>合法的检测全局作用域对象被初始化时刻以及被销毁时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitlized</span><span class="params">(ServletContextEvent sce)</span><span class="comment">//在全局作用域对象被Http服务器初始化被调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestory</span><span class="params">(ServletContextEvent sce)</span><span class="comment">//在全局作用域对象被Http服务器销毁时触发调用</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>ServletContextAttributeListener接口</li>
</ul>
<p>合法的检测全局作用域对象共享数据变化时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextAdd</span><span class="params">()</span> <span class="comment">//在全局作用域对象添加共享数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextReplaced</span><span class="params">()</span> <span class="comment">//在全局作用域对象更新共享数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextRemove</span><span class="params">()</span> <span class="comment">//在全局作用域对象删除共享数据</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局作用域对象共享数据变化时刻</span></span><br><span class="line">ServletContext application = request.getServletContext();</span><br><span class="line">application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="number">100</span>); <span class="comment">//新增共享数据</span></span><br><span class="line">application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="number">200</span>); <span class="comment">//更新共享数据</span></span><br><span class="line">application.removeAttribute(<span class="string">&quot;key1&quot;</span>);  <span class="comment">//删除共享数据</span></span><br></pre></td></tr></table></figure>
<h3 id="过滤器接口"><a href="#过滤器接口" class="headerlink" title="过滤器接口"></a>过滤器接口</h3><p>来自于Servlet规范下接口，在Tomcat中存在于servlet-api.jar包。Filter接口实现类由开发人员负责提供，Http服务器不负责提供。Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截。</p>
<blockquote>
<p>拦截Http服务器，帮助Http服务器检测当前请求合法性；对当前请求进行增强操作</p>
</blockquote>
<p>Filter接口实现类开发步骤：创建一个Java类实现Filter接口；重写Filter接口中doFilter方法；web.xml将过滤器接口实现类注册到Http服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//合法请求</span></span><br><span class="line">        <span class="comment">//将拦截请求对象和响应对象交还给Tomcat,由Tomcat继续调用资源文件</span></span><br><span class="line">        <span class="keyword">if</span>(...)&#123; </span><br><span class="line">        <span class="comment">//增强功能，通知拦截的请求对象，使用UTF-8字符集对当前请求体信息进行一次重新编辑(POST())</span></span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);<span class="comment">//FilterChain的doFilter方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则过滤器代替Http服务器拒绝本次请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--将过滤器类文件路径交给Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>oneFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.bjpowernode.filter.OneFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通知Tomcat在调用何种资源文件时需要被当前过滤器拦截--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>oneFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>拦截地址<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用某一个具体文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/mm.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用某一个文件夹下所有的资源文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用任意文件夹下某种类型文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用网站中任意文件时，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用过滤器避免恶意登录（避开登陆界面直接通过地址栏访问网站内资源文件）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用Dao将查询验证信息推送到数据库服务器上</span></span><br><span class="line">        result = dao.login(userName, password);</span><br><span class="line">        <span class="keyword">if</span>(result ==<span class="number">1</span>)&#123;<span class="comment">//用户存在</span></span><br><span class="line">            <span class="comment">//在判定来访用户身份合法后，通过请求对象向Tomcat申请为当前用户申请一个HttpSession令牌</span></span><br><span class="line">            HttpSession session = request.getSession();</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myWeb/index.html&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myWeb/login_error.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)servletRequest;</span><br><span class="line">        <span class="comment">// 与login相关的不过滤</span></span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        <span class="keyword">if</span>(uri.indexOf(<span class="string">&quot;login&quot;</span>) != -<span class="number">1</span> || <span class="string">&quot;/myWeb/&quot;</span>.equals(uri))&#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.拦截后，通过请求对象向Tomcat索要当前用户的HttpSession。</span></span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜.要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。此时Tomcat将返回null</span></span><br><span class="line">        <span class="comment">//2.判断来访用户身份合法性</span></span><br><span class="line">        <span class="keyword">if</span>(session == <span class="keyword">null</span>)&#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/login_error.html&quot;</span>)</span><br><span class="line">                .forward(servletRequest, servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--通知Tomcat在调用任意文件之前都要调用当前过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
