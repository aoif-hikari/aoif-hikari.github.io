<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="google-site-verification" content="JSt260h9ZipxDe9fDWuLLwbMKW6KZ1gPsQ2V68XJlTA" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aoif-hikari.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="贪心算法在对问题求解时，总是做出在当前看来是最好的选择。">
<meta property="og:type" content="article">
<meta property="og:title" content="图与网络&#x2F;贪心算法">
<meta property="og:url" content="https://aoif-hikari.github.io/2021/07/12/%E8%B4%AA%E5%BF%83/index.html">
<meta property="og:site_name" content="aoif-hikari">
<meta property="og:description" content="贪心算法在对问题求解时，总是做出在当前看来是最好的选择。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://aoif-hikari.github.io/img/greedy/2.jpg">
<meta property="og:image" content="https://aoif-hikari.github.io/img/greedy/3.jpg">
<meta property="og:image" content="https://aoif-hikari.github.io/img/greedy/1.png">
<meta property="og:image" content="https://aoif-hikari.github.io/img/greedy/3.png">
<meta property="og:image" content="https://aoif-hikari.github.io/img/greedy/2.png">
<meta property="article:published_time" content="2021-07-12T11:14:36.923Z">
<meta property="article:modified_time" content="2021-07-16T08:56:06.190Z">
<meta property="article:author" content="fu">
<meta property="article:tag" content="图与网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aoif-hikari.github.io/img/greedy/2.jpg">

<link rel="canonical" href="https://aoif-hikari.github.io/2021/07/12/%E8%B4%AA%E5%BF%83/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>图与网络/贪心算法 | aoif-hikari</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="aoif-hikari" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">aoif-hikari</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://aoif-hikari.github.io/2021/07/12/%E8%B4%AA%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.jpg">
      <meta itemprop="name" content="fu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aoif-hikari">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图与网络/贪心算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-12 19:14:36" itemprop="dateCreated datePublished" datetime="2021-07-12T19:14:36+08:00">2021-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 16:56:06" itemprop="dateModified" datetime="2021-07-16T16:56:06+08:00">2021-07-16</time>
              </span>

          
            <span id="/2021/07/12/%E8%B4%AA%E5%BF%83/" class="post-meta-item leancloud_visitors" data-flag-title="图与网络/贪心算法" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/07/12/%E8%B4%AA%E5%BF%83/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/12/%E8%B4%AA%E5%BF%83/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              <span>8.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>贪心算法在对问题求解时，总是做出在当前看来是最好的选择。</p>
</blockquote>
<span id="more"></span>
<h2 id="最小生成树问题-Minimum-spanning-trees-MST"><a href="#最小生成树问题-Minimum-spanning-trees-MST" class="headerlink" title="最小生成树问题(Minimum spanning trees,MST)"></a>最小生成树问题(Minimum spanning trees,MST)</h2><blockquote>
<p><strong>生成树</strong>：指一个连通子图，它含有图中全部$n$个顶点，但只有足以构成一棵树的$n-1$条边。</p>
<p><strong>最小生成树</strong>：在所有生成树中，所有边的权重和最小的生成树。</p>
<p>假设有一个连通的无向的图$G=(V,E)$，及权值函数$w: E\rightarrow R$。考虑贪婪的方法找出$MST$。</p>
</blockquote>
<p>这个贪心策略由下面的“一般型”算法延伸，该算法<strong>每次只增长最小生成树的一条边</strong>。</p>
<p>该算法管理边集$A$，$A$不断加$1$条边，需要做$n-1$次循环。在每次迭代之前，$A$是最小生成树的子集。在每一步，我们确定可以添加到$A$的边${u,v}$，在不违背这个不变式的情况下，$A\cup \{u，v\}$还是最小生成树的一个子集。</p>
<p>称这样的边为A的安全边（$safe\  edge$），因为它可以在保持不变的情况下添加到$A$。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">GENERIC-MST</span>(G,w)</span><br><span class="line"><span class="selector-tag">A</span> ← ?</span><br><span class="line"><span class="selector-tag">while</span> <span class="selector-tag">A</span> <span class="selector-tag">does</span> <span class="selector-tag">not</span> <span class="selector-tag">form</span> <span class="selector-tag">a</span> <span class="selector-tag">spanning</span> <span class="selector-tag">tree</span></span><br><span class="line">    <span class="selector-tag">do</span> <span class="selector-tag">find</span> <span class="selector-tag">an</span> <span class="selector-tag">edge</span> <span class="selector-tag">e</span> <span class="selector-tag">that</span> <span class="selector-tag">is</span> <span class="selector-tag">safe</span> <span class="selector-tag">for</span> <span class="selector-tag">A</span></span><br><span class="line">        <span class="selector-tag">A</span> ← <span class="selector-tag">A</span> ∪ <span class="selector-tag">e</span></span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如何找到安全的边？</strong></p>
</blockquote>
<p><strong>定义</strong>: 无向图$G=(V,E)$的一个$cut(S,V-S)$是$V$的一个$cut$。</p>
<p>如果一条在$E$中的边$(u, v)$它的一个端点在$S$中，另一个端点在$V-S$中，我们说这条边穿过这个$cut(S,V-S)$</p>
<p>如果$A$中的边没有与该$cut$相交，则该$cut\ respects\ A$的边。</p>
<p>如果边的权值是任何边穿过$cut$的最小值，则边就是穿过$cut$的轻边($light\ edge$)。注意，可以有更多轻边，那么选择其中一条即可。</p>
<p>简单来说，就是$A∪safe\ edge$就是最小生成树的子集，$A$中的点没有穿过$cut$，再在$cut$中找到轻边作为安全边，得到新的$A$，然后再找到新的$cut$，满足$A$没有穿过$cut$，循环此过程，直至找到$n-1$条边。</p>
<blockquote>
<p>定理：设$G=(V,E)$是连通的具有权重$w$的无向图，令$A$是$E$的子集，包含在$G$的最小生成树中。设$(S, V-S)$为任意$cut(respect\ A)$，设$(u,v)$为穿过$(S, V-S)$的轻边。那么$(u,v)$是$A$的安全边。</p>
</blockquote>
<p><strong>证明</strong>:</p>
<p>设$T$是一个最小生成树，包含$A$。</p>
<ul>
<li><p>若$T$包含轻边$(u,v)$，则$A\cup \{u，v\} \in T$,</p>
</li>
<li><p>若$T$不包含轻边$(u,v)$，构造另一棵最小生成树$T’$，对于当前生成树$T，u，v$之间没有直接的边相连，但可以通过路径$p$连通，按图中将$G$分割为$cut$两部分，使得$u， v$在$cut$不同的点集，那么必然存在这样 的$x，y$也被划分在$cut$两部分，边$(u,v)(x,y)$都穿过该$cut$，$(u,v)$是轻边，连接$(u,v)$，断开$(x,y)$，得到新的生成树$T’$，$T’=T-(x,y)\cup (u,v)$。因为$(u,v)$是一个轻边，$w(u,v)\leq w(x,y)$。因此,$w (T’) = w (T) - w (x, y) + w (u, v) \leq w (T)$。由于$T$是最小生成树，所以$T’$也必须是最小生成树。</p>
</li>
</ul>
<p><strong>Kruskal , Prim使用特定的规则来确定安全边。</strong></p>
<ul>
<li><strong>kruaskal算法</strong>找到安全边的方法是，在所有连接森林中两颗不同树的边里面，找到权重最小的边$(u,v)$。</li>
</ul>
<div align="center">
    <img src="/img/greedy/2.jpg"/>
</div>

<ul>
<li><strong>Prim算法</strong>所具有的一个性质是集合$A$中边总是构成一棵树。这颗树从一个任意的根节点r开始，一直长大到覆盖$V$中的所有结点时为止。算法每一步在连接集合$A$和$A$之外的节点所有边中，选择一条轻边加入到$A$中。</li>
</ul>
<div align="center">
    <img src="/img/greedy/3.jpg"/>
</div>



<h2 id="最大独立集-Maximum-independent-set"><a href="#最大独立集-Maximum-independent-set" class="headerlink" title="最大独立集(Maximum independent set)"></a>最大独立集(Maximum independent set)</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Greedy independent <span class="keyword">set</span></span><br><span class="line"><span class="keyword">input</span> Graph G=(V,E);</span><br><span class="line">output independent <span class="keyword">set</span> V<span class="string">&#x27; in G;</span></span><br><span class="line"><span class="string">begin</span></span><br><span class="line"><span class="string">    V&#x27;</span>:=ф</span><br><span class="line">    U:=V</span><br><span class="line">    <span class="keyword">while</span> U <span class="keyword">is</span> <span class="keyword">not</span> empty <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        x: vertex <span class="keyword">of</span> minimum degree <span class="keyword">in</span> graph induced <span class="keyword">by</span> U</span><br><span class="line">        V<span class="string">&#x27;:=V&#x27;</span>U(x);</span><br><span class="line">        eliminate x <span class="keyword">and</span> <span class="keyword">all</span> its neighbors <span class="keyword">from</span> U</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> V<span class="string">&#x27;</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>贪心算法找不到最大独立集的例子：</p>
<div align="center">
    <img src="/img/greedy/1.png"/>
</div>

<p>贪心结果：${a, e}$</p>
<p>实际结果：${b, c, d}$</p>
</blockquote>
<p>可以看出，随着左部和中部图中点数的增加，贪心所得到的解与最优值可以相差任意远。可以使用图的密度函数判断贪心算法的表现。</p>
<blockquote>
<p>定理：假设图$G$有$n$个点和$m$条边，记$\delta =\frac{m}{n}$为图G的密度。贪心算法求得的解$m_{Gr}(G)\geq \frac{n}{(2\delta +1)}$</p>
</blockquote>
<p><strong>证明：</strong></p>
<p>设$x_i$为程序while循环第$i$次迭代时选定的顶点，$d_i$为$x_i$的度。</p>
<p>该算法将$x_i$及其所有$d_i$邻居从$G$中删除。第$i$步删除$d_{i+1}$个点，得到</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}(d_i+1)=n.........(1)</script><p>又因为删除点的同时会删除边，那么与$x_i$相连的$d_i$个点至少度是$d_i$，那么删除的边有$(d_i+1)d_i$，又$d_i$个点之间可能存在互相连接的情况，那么删除的边至少有$(di+1)di/2$，删除的边数一定小于总边数，得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}(d_i+1)\frac{d_i}{2}\leq m=\delta n..........(2)</script><p>$(2)*2+(1)$得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}(d_i+1)^2\leq n(2\delta +1)</script><p>利用柯西斯瓦格不等式，对于所有的$i$，当$d_i+1=\frac{n}{m_{Gr}(G)}$时，不等式的左边取得极小值。</p>
<script type="math/tex; mode=display">
n(2\delta +1)\geq \sum_{i=1}^{m_{Gr}(G)}(d_i+1)^2\geq \frac{n^2}{m_{Gr}(G)}</script><p>得证。</p>
<p>下面的定理提供了最优解与贪婪算法求得的解之间的关系。</p>
<blockquote>
<p>定理：有$n$个顶点和$m$的图$G$，设$\delta =\frac{m}{n}$。可以找到一个独立的集合$m_{Gr}(G)$，令最优解$\frac{m^*(G)}{m_{Gr}(G)}\leq (\delta +1)$</p>
</blockquote>
<p><strong>证明</strong>:</p>
<p>本证明与前一证明相似。在本例中，确定一个最大的独立集合${V^<em>}$，令$k_i$为在第$i$次循环中所删除$d_{i+1}$个顶点并在${V^</em>}$中的顶点数。显然</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}k_i=|V^*|=m^*(G)............(3)</script><p>由于贪心算法选择的顶点最小度，删除的顶点的度的和至少是$d_i(d_i+1)$。</p>
<p>因为一条边的两个端点不可能都在$V^<em>$</em>中，*它这样删除边的数目至少为$\frac{(d_i(d_i+1)+k_i(k_i-1))}{2}$，这里可以修改$(2)$，得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}\frac{d_i(d_i+1+ki(k_i-1))}{2}\leq \delta n...........(4)</script><p>$(2)+(3)+2*(4)$得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m_{Gr}(G)}((d_i+1)^2+k_i^2)\leq n(2\delta +1)+m^*(G)</script><p>应用$C-S$不等式，当$d_i+1=\frac{n}{m_{Gr}(G)}\ and\ k_i=\frac{m^*(G)}{m_{Gr}(G)}$，上述不等式左边最小，因此</p>
<script type="math/tex; mode=display">
n(2\delta +1)+m^*(G)\geq \sum_{i=1}^{m_{Gr}(G)}((d_i+1)^2+k_i^2)\geq \frac{n^2+m^*(G)^2}{m_{Gr}(G)}</script><p>即</p>
<script type="math/tex; mode=display">
m_{Gr}(G)\geq m^*(G)\frac{\frac{n}{m^*(G)}+\frac{m^*(G)}{n}}{2\delta +1+\frac{m^*(G)}{n}}</script><p>当$m^*(G)=n$时，不等式最小。把这一项代入，定理成立。</p>
<h2 id="背包问题-Greedy-knapsack"><a href="#背包问题-Greedy-knapsack" class="headerlink" title="背包问题(Greedy knapsack)"></a>背包问题(Greedy knapsack)</h2><p>输入:集合$X$的$n$个元素，对于$X$中的每个$x_i$，价值$p_i$，重量$w_i$，正整数$b$；</p>
<p>输出:子集$Y\in X$使得$\sum_{x_i\in Y}w_i\leq b,max\ {\sum_{x_i\in Y}} p_i$</p>
<p>按$\frac{p_i}{w_i}$的规则进行贪心选择。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    sort X <span class="keyword">in</span> non-increasing <span class="keyword">order</span> <span class="keyword">with</span> respect <span class="keyword">to</span> the ratio pi/wi;</span><br><span class="line">    Y:=<span class="keyword">empty</span> <span class="keyword">set</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> b&gt;=wi <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        Y=YU<span class="comment">&#123;xi&#125;</span></span><br><span class="line">        b=b-wi</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    return Y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>找不到最优解的例子：</p>
<p>令$p_i=w_i=1，i=1,2，..，n-1, p_n=b-1, w_n=b=k_n$，其中$k$是一个任意大的数。</p>
<p>在这种情况下，最优解$m^*(x)=b-1$;而贪心算法找到的解的值为$n-1$。因此</p>
<script type="math/tex; mode=display">
\frac{m^*(x)}{m_{Gr}(x)} > k</script><p>贪心算法的劣势是由于算法没有将价值最高的元素包含在解中，而最优的元素正是价值最高的。这表明一个简单的修改贪心的程序有更好的性能。</p>
<blockquote>
<p>定理：给定一个背包的实例$x$，令$m_H(x)=max(P_{max}，m_{Gr}(x))$，其中$P_{max}$是$x$中一个项目的最大价值，$m_H(x)$满足以下不等式:$\frac{m^*(x)}{m_H(x)}&lt; 2$。</p>
</blockquote>
<p><strong>证明</strong>：设$j$为根据贪心选择第一个装不进背包物品的下标，此时背包转装入的物品价值为</p>
<script type="math/tex; mode=display">
\overline{p_j}=\sum_{i=1}^{j-1}\leq m_{Gr}(x)</script><p>重量为</p>
<script type="math/tex; mode=display">
\overline{w_j}=\sum_{i=1}^{j-1}w_i\leq b</script><p>首先证明任何最优解必须满足以下条件不等式:</p>
<p>$m^*(x)&lt;\overline{p_j}+p_j$，</p>
<p>因为装入前j-1个物品后，容量还剩余$b-\overline{w_j}&lt; w_j$，贪心选择在装入$j-1$个物品后，无法装入$j$，其密度为$\frac{p_j}{w_j}$，那么如果剩余容量按最优的去放，$(b-\overline{w_j})\frac{p_j}{w_j}&lt;w_j\frac{p_j}{w_j}=p_j$</p>
<p>如果$p_j&lt;\overline{p_j}$，那么$m^*(x)&lt;2\overline{p_j}\leq 2m_{Gr}(x)\leq 2m_H(x)$；</p>
<p>如果$p_j&gt;\overline{p_j}$，那么$P_{max}&gt;\overline{P_j}$，有$m^*(x)\leq \overline{p_j}+p_j\leq 2{p_j}\leq 2P{max}\leq 2m_H(x)$</p>
<h2 id="The-Stein-Lovasz-Theorem"><a href="#The-Stein-Lovasz-Theorem" class="headerlink" title="The Stein-Lovasz Theorem"></a>The Stein-Lovasz Theorem</h2><blockquote>
<p>The stein-lovasz Theorem 理论最基本的模型是解决集合的元素覆盖问题。使用贪心算法，以获得一个使用最少列元完成最大行覆盖的方案。</p>
<p>假设$(0,1)$矩阵$A$的大小是$N×M$ ,矩阵$A$的特征是每行至少具有$v$个$1$，每列最多$a$个$1$。假设现在从其中抽取一个子矩阵$C⊂A$,大小是$N×K$，使得子矩阵的每行元素都不是全零行，证明$K$存在一个上界，<br>$K≤\frac{N}{a}+(\frac{M}{v})lna≤(\frac{M}{v})(1+lna)$</p>
<p>分析：能不能使用一种抽取列数尽可能少的方案，如果使用的列数目比给定的边界条件$\frac{N}{a}+(\frac{M}{v})lna$小，那么原来的问题就自然获得证明。</p>
</blockquote>
<p><strong>贪心算法思路描述如下</strong></p>
<ol>
<li>初始化矩阵$(0,1)$矩阵$A$，每列的$1$权重值$c_i∈\{1,2,3,……,a\}$,然后按照列权重按照 $a,a-1,a-2,…,1$ 执行降序排序，此时的矩阵命名为$A_a$;</li>
<li>从最左边权重最高为$a$的第一列开始，删除这一列，并且这列对应的$1$所在相应的$a$个行也统一删掉。在删除$1$列和$a$行后的矩阵$A$，重新划定权重，继续寻找左边最高权重为$a$的列，继续删除。在删除$2$列和$2∗a$行后的矩阵$A$，重新划定权重，继续寻找左边最高权重为$a$的列，继续删除。重复$K_a$次后，把最高权重为$a$的列及对应的$a∗K_a$行都删掉了，此时的矩阵变成了$A_{a−1}$;</li>
<li>以矩阵$A_{a−1}$开始，从左边权重最高为$a-1$的第一列开始，删除这一列，并且这列所对应的$a−1$行也统一删掉。删完后，重新划定权重，继续寻找左边最高权重为$a-1$的列，继续删除。重复$K_{a−1}$次后，把最高权重为$a-1$的列及其对应的$(a−1)∗K_{a−1}$行都删掉了，此时的矩阵变成了$A_{a−2}$.</li>
<li>重复步骤3，删除权重为$a-2,a-3,…,1$的列，直到矩阵$A_1$变成了空。<br>将之前删除的所有列元集中起来重新组合成$N×K$矩阵，$K=\sum_{i=1}^a K_i$</li>
</ol>
<p><strong>证明</strong>：</p>
<p>假设$A_a=A_{N*M}$表示由$a$个1且每列的1互不重合的列组成的矩阵</p>
<p>$A_{a-1}’$表示由a-1个1且每列的1互不重合的列组成的矩阵。$|A_a’|=K_a$，那么删除覆盖的$K_a\cdot a$行得到新的矩阵$A_{a-1}=A_{(N-aK_a)\times (M-K_a)}$，那么每一列至多有$a-1$个$1$，</p>
<p>$|A_{a-1}’|=K_{a-1}$，那么删除覆盖的$K_{a-1}\cdot (a-1)$行得到新的矩阵$A_{a-2}$。</p>
<p>以此类推，$A_{i-1}$，每行至少$v$个1，每列至多$i-1$个$1$，那么有$N-aK_a-(a-1)K_{a-1}-…-iK_i$行，记为$k_i$行，有$M-K_a-…-K_i$列。</p>
<p>$k_a=N-aK_a$，即$K_a=\frac{N-k_a}{a}$，令$N=k_{a+1}$，则$K_a=\frac{k_{a+1}-k_a}{a}$，以此类推得到</p>
<script type="math/tex; mode=display">
K_i=\frac{k_{i+1}-k_i}{i}</script><script type="math/tex; mode=display">
\sum_{i=1}^{a}K_i=\sum_{i=1}^{a}\frac{k_{i+1}-k}{i}=\frac{k_{a+1}}{a}-\frac{k_a}{a}+\frac{k_a}{a-1}-\frac{k_{a-1}}{a-1} +...+\frac{k_2}{1}=\frac{N}{a}+\frac{k_a}{a(a-1)}+\frac{k_{a-1}}{(a-1)(a-2)}+...+\frac{k_2}{2\times 1}</script><p>使用双计数，分别对行和列进行计数，对于$A_{i-1}$，每一行至少$v$个1，而每列至多$i-1$个$1$，可得对$1$进行行计数不会超过进行列计数，即</p>
<script type="math/tex; mode=display">
k_i\times v\leq (M-K_a-...-K_i)\times (i-1)\leq M\times (i-1) \frac{k_i}{i-1}\leq \frac{M}{v}</script><p>那么</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{a}K_i\leq \frac{N}{a}+\frac{1}{a}\frac{M}{v}+\frac{1}{a-1}\frac{M}{v}+...+\frac{1}{2}\frac{M}{v}=\frac{N}{a}+\frac{M}{v}(\frac{1}{a}+\frac{1}{a-1}+...+\frac{1}{2})\leq \frac{N}{a}+\frac{M}{v}lna\leq \frac{M}{v}+\frac{M}{v}lna=\frac{M}{v}(1+lna)​</script><h3 id="应用1：完美哈希族函数（Perfect-Hash-Function）"><a href="#应用1：完美哈希族函数（Perfect-Hash-Function）" class="headerlink" title="应用1：完美哈希族函数（Perfect Hash Function）"></a>应用1：完美哈希族函数（Perfect Hash Function）</h3><blockquote>
<p>$(n,m,w)$-完美哈希族是一个函数F集合，使得$|Y|=n$， $|X|=m$,</p>
<p>$f:Y\rightarrow X$对于$F$中的每一个$f$，对于任何$C\subseteq \{1,2,…,n\}$使得$|C|=w$，$C$是$Y$的$w$元子集合，并且至少存在一个$F$中的$f$使得$f|C$是一一对应的。如果$|F|=N$那么完美哈希族可以记作$PHF(N;n,m,w)$。</p>
<p>求满足条件的函数数目的一个上界。</p>
</blockquote>
<div align="center">
    <img src="/img/greedy/3.png"/>
</div>

<p>$|F|=N$，如上图，假设$w=3$，那么任选$Y$中的三列，有$\binom{n}{3}$种选择，要求其中存在一行使得三个函数值各不同，例如取$1，2，3$列，$f_{11}$，$f_{12}$，$f_{13}$互不相同就满足要求一一映射。</p>
<p>$f:Y\rightarrow X$，$n$个$Y$对应到$m$个$X$，每一个$Y$有$m$种选择，那么有$m^n$个函数。从中挑出最少的函数(即N越小越好)使得对于任何的$C$可以满足一一对应要求。</p>
<ul>
<li>套用ST定理：</li>
</ul>
<p>$N:\binom{n}{w}$，从$M:m^n$个函数中挑选出最少的函数满足要求，那么得到的矩阵就是$NxM$的$(0,1)$矩阵$A$，$A_{ij}=1$的含义就是当$|w|=i$，$f_j$是可以满足一一映射要求的。</p>
<p>$v:\binom{m}{w}w!\cdot m^{n-w}$，表示从$m$个值中选取$w$的值排列放入选择的$w$个，剩余未赋值的$n-w$个，就任意赋值。</p>
<p>$a:\binom{n}{w}$，每一个函数至多覆盖$a$个。</p>
<p>套用S-T定理得</p>
<script type="math/tex; mode=display">
N\leq \frac{m}{w!\binom{m}{w}}(1+log\binom{n}{w})</script><ul>
<li>使用概率方法:</li>
</ul>
<p>从$m^n$个函数中随机选择$N$个函数出来，构造一张随机的函数表，考虑坏概率，在函数表中没有一个函数可以使$w$存在一一映射关系，对于一个函数坏概率为存在一一对应关系的对立事件，取出$N$个函数，得</p>
<script type="math/tex; mode=display">
(1-\frac{\binom{m}{w}w!m^(n-w)}{m^n})^N\binom{n}{w}</script><p>使其小于1，那么一定存在完美哈希族。(两边取对数求解)</p>
<h3 id="应用2：分割系统-Splitting-Systems"><a href="#应用2：分割系统-Splitting-Systems" class="headerlink" title="应用2：分割系统(Splitting Systems)"></a>应用2：分割系统(Splitting Systems)</h3><p><strong>在某个域中，$\alpha ^n=\beta$，$\alpha ,\beta$已知且为离散的，那么如何求解$n$？</strong></p>
<p><strong>分割系统的提出就是为了解决离散对数问题。</strong></p>
<blockquote>
<p>假设$n,t$为偶数，$X$是点集合,$B$是超边集合。</p>
<p>a) $|X|=n$,$B$是$X$的$\frac{n}{2}$子集的集合，称为区组</p>
<p>b)对于每一个$Y\subseteq X$中存在区组$B$，使得$|B\cap Y|=\frac{t}{2}$。</p>
<p>取最少$N$个$B$使得上面的条件满足。</p>
</blockquote>
<ul>
<li>使用S-T定理</li>
</ul>
<p>$N:\binom{n}{t}$，对所有的t元子集合进行分割;</p>
<p>$M:\binom{n}{\frac{n}{2} }$，完成的方法总数;</p>
<p>接下来确定$v$，那么对于某一行有多少$\frac{n}{2}$元子集合可以分割$t_i$，$t$个位置中一半放$1$，剩余一半放$0$，问题是一个$n$元集合，此时还剩$n-t$个位置没有放数，且还缺少$\frac{n-t}{2}$个1，那么得到子集合个数$\binom{t}{ \frac{t}{2} }\cdot \binom{n-t}{\frac{n-t}{2}}$；</p>
<p>确定$a$，对于固定的$\frac{n}{2}$元子集合可以分割多少$t$，$\binom{\frac{n}{2}}{\frac{t}{2}}\binom{\frac{n}{2}}{\frac{t}{2}}$，套用S-T定理，</p>
<script type="math/tex; mode=display">
N\leq \frac{\binom{n}{\frac{n}{2}}}{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}(1+2ln\binom{\frac{n}{2}}{\frac{t}{2}})</script><div align="center">
    <img src="/img/greedy/2.png"/>
</div>



<ul>
<li>使用概率方法：</li>
</ul>
<p>定义$A_i$，第$i$个$t$元子集合未被分割。对于一个$t$元集合没有分割的概率是分割时间的对立事件，为</p>
<script type="math/tex; mode=display">
1-\frac{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}{\binom{n}{\frac{n}{2}}}</script><p>共有$N$个$\frac{n}{2} $元子集合未被分割，为</p>
<script type="math/tex; mode=display">
(1-\frac{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}{\binom{n}{\frac{n}{2} }})^N=P(A_i)</script><p>那么至少有一个$t$元集合未被分割的概率为</p>
<script type="math/tex; mode=display">
P(\cup A_i)\leq \sum P(A_i)=\binom{n}{t}P(A_i)<1</script><p>令其小于$1$，那么没有未被分割的情况概率大于$0$。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.codenong.com/cs106200371/">图论学习笔记五贪心算法 | 码农家园 (codenong.com)</a></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/" rel="tag"># 图与网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="prev" title="JAVA/代理模式">
      <i class="fa fa-chevron-left"></i> JAVA/代理模式
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/19/servlet/" rel="next" title="JAVA/Servlet规范">
      JAVA/Servlet规范 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98-Minimum-spanning-trees-MST"><span class="nav-number">1.</span> <span class="nav-text">最小生成树问题(Minimum spanning trees,MST)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86-Maximum-independent-set"><span class="nav-number">2.</span> <span class="nav-text">最大独立集(Maximum independent set)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-Greedy-knapsack"><span class="nav-number">3.</span> <span class="nav-text">背包问题(Greedy knapsack)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Stein-Lovasz-Theorem"><span class="nav-number">4.</span> <span class="nav-text">The Stein-Lovasz Theorem</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A81%EF%BC%9A%E5%AE%8C%E7%BE%8E%E5%93%88%E5%B8%8C%E6%97%8F%E5%87%BD%E6%95%B0%EF%BC%88Perfect-Hash-Function%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">应用1：完美哈希族函数（Perfect Hash Function）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A82%EF%BC%9A%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F-Splitting-Systems"><span class="nav-number">4.2.</span> <span class="nav-text">应用2：分割系统(Splitting Systems)</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fu"
      src="/images/cat.jpg">
  <p class="site-author-name" itemprop="name">fu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/fall_ivan" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;fall_ivan" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">49k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">45 mins.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"vGxmpKFQ0V9UFhbevVmCc8JP-gzGzoHsz","app_key":"ap55DtNaG0HBItnGc7CmFY5y","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vGxmpKFQ0V9UFhbevVmCc8JP-gzGzoHsz',
      appKey     : 'ap55DtNaG0HBItnGc7CmFY5y',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
