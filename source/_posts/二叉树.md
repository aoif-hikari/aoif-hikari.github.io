---
tags: leetcode
title: Leetcode/二叉树
---

> 二叉树与递归有着千丝万缕的联系，二叉树在定义时就使用了递归的概念：一棵二叉树可能是空树，如果不是空树，那么它的左右子树都是二叉树。

<!-- more -->

```java
// 二叉树
class BinaryNode{
    Object element;
    BinaryNode left;
    BinaryNode right;
}
```

## 基础：二叉树的遍历

遍历时均无返回值，所以遍历要另写函数，把需要返回的作为参数传入。

### DFS, 深度优先

#### 先序遍历：根左右（文件目录结构）。

常规迭代

- 初始化栈，并将根节点入栈；

- 当栈不为空时：
  - 弹出栈顶元素 node，并将值添加到结果中；
  - 如果 node 的右子树非空，将右子树入栈；
  - 如果 node 的左子树非空，将左子树入栈；

由于栈是“先进后出”的顺序，所以入栈时先将右子树入栈，这样使得前序遍历结果为 “根->左->右”的顺序。

```java
// 迭代，非递归实现,本质使用栈模拟递归
public void preorder(TreeNode root){
    if(root == null ) return;
    //初始化栈，并将根节点入栈；
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
	//当栈不为空时：
    while(!stack.isEmpty()){
        //弹出栈顶元素 node，并将值添加到结果中；
        TreeNode node = stack.pop();
        System.out.print(node.val); 
        //如果 node 的右子树非空，将右子树入栈；
        if(node.right != null) stack.push(node.right);
        //如果 node 的左子树非空，将左子树入栈；
        if(node.left != null) stack.push(node.left);
    }
    return;
}
```

模板迭代

- 先将根节点 `cur` 和所有的左孩子入栈并加入结果中，直至 `cur` 为空

- 每弹出一个栈顶元素 `tmp`，就到达它的右孩子，再将这个节点当作 `cur` 重新按上面的步骤来一遍，直至栈为空。

```java
public void preorderTraversal(TreeNode root) {     
    if(root == null ) return;

    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;

    while(cur != null || !stack.isEmpty()){
        //将根节点cur和所有的左孩子入栈并加入结果中，直至cur为空
        while(cur != null){
            System.out.print(cur.val); 
            stack.push(cur);
            cur = cur.left;
        }
        //每弹出一个栈顶元素tmp,就到达它的右孩子,再将这个节点当作cur
        TreeNode temp = stack.pop();
        cur = temp.right;
    }
    return;
}
```

```java
// 递归实现
public void preorder_Traversal(TreeNode root){
    if(root==null)return;        
    //访问节点的逻辑代码块
    System.out.print(root.val+" ");       
    preorder_Traversal(root.left);
    preorder_Traversal(root.right);
}
```

#### **中序遍历：左根右。**

模板迭代：

- 先将根节点 `cur` 和所有的左孩子入栈中，直至 `cur` 为空

- 每弹出一个栈顶元素 `tmp`，加入结果中，并到达它的右孩子，再将这个节点当作 `cur` 重新按上面的步骤来一遍，直至栈为空。

```java
public void preorderTraversal(TreeNode root) {     
    if(root == null ) return;

    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;

    while(cur != null || !stack.isEmpty()){
        //将根节点cur和所有的左孩子入栈中，直至cur为空
        while(cur != null){
            stack.push(cur);
            cur = cur.left;
        }
        //每弹出一个栈顶元素tmp,加入结果中，并到达它的右孩子,再将这个节点当作cur
        TreeNode temp = stack.pop();
        System.out.print(temp.val); 
        cur = temp.right;
    }
    return;
}
```

```java
// 递归实现
public void inorder_Traversal(TreeNode root){
    if(root==null)return;
    inorder_Traversal(root.left);        
    //访问节点的逻辑代码块
    System.out.print(root.val+" ");       
    inorder_Traversal(root.right);
}
```

#### **后续遍历：左右根。**

对前序遍历的（根左右）修改为（根右左），再倒序输出。

```java
// 常规倒序输出
public List<Integer> preorder(TreeNode root){
    if(root == null ) return;
    //初始化栈，并将根节点入栈；
    Stack<TreeNode> stack = new Stack<>();
    Stack<TreeNode> resStack = new Stack<>();
    stack.push(root);
	//当栈不为空时：
    while(!stack.isEmpty()){
        //弹出栈顶元素 node，并将值添加到结果中；
        TreeNode node = stack.pop();
        resStack.push(node);
        //如果 node 的右子树非空，将右子树入栈；
        if(node.left != null) stack.push(node.left);
        //如果 node 的左子树非空，将左子树入栈；
        if(node.right != null) stack.push(node.right);
    }
    List<Integer> res = new ArrayList<>();
    while(!resStack.isEmpty()){
        res.add(resStack.pop().val);
    }
    return res;
}

// 模板倒序输出
public List<Integer> postorderTraversal(TreeNode root) {
    Stack<TreeNode> s = new Stack<>();
    Stack<TreeNode> resStack = new Stack<>();
    TreeNode cur = root;
    //将根节点cur和所有的右孩子入栈并加入结果中，直至cur为空
    while(cur != null || !s.isEmpty()){
        while(cur != null){
            resStack.push(cur); // root
            s.push(cur); 
            cur = cur.right; // right
        }
       //弹出一个栈顶元素tmp，并到达它的左孩子，再将这个节点当作cur
        cur = s.pop();
        cur = cur.left; // left
    }
    // 反向输出
    List<Integer> res = new ArrayList<>();
    while(!resStack.isEmpty()){
        res.add(resStack.pop().val);
    }
    return res;
}
```

```java
// 递归实现
public void postorder_Traversal(TreeNode root){
    if(root==null)return;
    postorder_Traversal(root.left);
    postorder_Traversal(root.right);        
    //访问节点的逻辑代码块
    System.out.print(root.val+" ");
}
```

### 层次遍历(BFS, 广度优先)

广度优先搜索的步骤为：

- 初始化队列 q，并将根节点 root 加入到队列中；

- 当队列不为空时：
  - 队列中弹出节点 node，加入到结果中；
  - 如果左子树非空，左子树加入队列；
  - 如果右子树非空，右子树加入队列；

<img src="/img/tree/bfs1.gif"/>

```java
//队列实现,分层次，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。
public List<List<Integer>> LaywerTraversal(TreeNode root){
    List<List<Integer>> res = new ArrayList<>();
    if(root == null) return res;
    // 初始化队列 q，并将根节点 root 加入到队列中；
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.add(root);
    //当队列不为空时：
    while (!queue.isEmpty()) {
        int n = queue.size();
        List<Integer> level = new ArrayList<>();
        for (int i = 0; i < n; i++) { 
            //队列中弹出节点 node，加入到结果中；
            TreeNode node = queue.poll();
            level.add(node.val);
            //如果左子树非空，左子树加入队列；
            if (node.left != null) queue.add(node.left);
            //如果右子树非空，右子树加入队列；
            if (node.right != null) queue.add(node.right);
        }
        res.add(level);
    }
    return res;
}
```

<img src="/img/tree/bfs2.gif"/>

BFS常用于找最短路径。

在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。

在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。

> 表达式树：分别对应前缀表达式/中缀表达式/后缀表达式
>
> 树叶是操作数值，其他节点是操作符。

后缀表达式转树：操作数压栈，操作符弹栈

## 对应例题

### 先序遍历

144 二叉树的先序遍历

589 N 叉树的前序遍历

> **606 根据先序遍历结果构造字符串**
>
> - 在先序遍历中，对每个非空访问元素，在进行处理时，先形成字符串"("+ root.val；
>
>
> 例如，对于[1,2,3,4]，得到"(1(2(4"
>
> - 如果当前访问的节点的左子树为空且右子树不为空，就在字符串中添加一个"()"
>
>
> 这样得到, "(1(2(4()"
>
> - 同时，对于每轮递归中，在最终返回前，补全右括号")"
>
>
> 这样我们得到 "(1(2(4())(3))"
>
> 由此，基本输出形式已经完成。剩下处理头尾两个多余括号。

> **331 验证是否是合法先序遍历结果**
>
> - 二叉树看成有向图，一条有向边带来一个入度和一个出度，二叉树的总入度等于总出度，也等于边数。即，遍历到最后，总入度肯定等于总出度。
>
> - 还没遍历到最后时，肯定不会出现 入度 >= 出度 的时刻。
>
> 提供 1 个出度可以理解为提供一个挂载点，提供 1 个入度为消耗一个挂载点。入度 >= 出度，意味着当前已遍历的节点，消耗的挂载点已经大于等于提供的挂载点。说明已经没法挂载接下来遍历的节点了，还有要挂的，但挂满了，是不合法的。

### 中序遍历

94 基本的中序遍历

173 二叉搜索树迭代器

中序遍历一般会和BST（二叉搜索树）结合使用，这样访问的顺序就是已排序的了

### 后序遍历

145 基本的二叉树的后序遍历

590 N 叉树的后序遍历

### 层序遍历

102 二叉树的层序遍历

103 二叉树的锯齿形层序遍历（每层加flag或用双端队列）

107  二叉树的层序遍历 II（自底向上）

429 N 叉树的层序遍历

### 树的基本操作

递归三步：确定递归函数的参数和返回值；确定终止条件（if(root == null) return;）；确定单层递归逻辑（对哪个节点进行什么递归操作）；

226 翻转二叉树（对于每个节点，交换其左右子树，递归其左右子树）

100 相同的树（对于每个节点，判断其值是否相等，递归其左右子树）

572 另一个树的子树(一个树是另一个树的子树，要么这两个树相等；要么这个树是左树的子树；要么是右树的子树。)

> **剑指 Offer 26 树的子结构**
>
> - 先序遍历树 A中的每个节点；（对应函数 `isSubStructure(A, B)`）
>   - 特例处理： 当 树 A为空 **或** 树 B 为空 时，直接返回 false；
>   - 返回值： 若树 BB 是树 AA 的子结构，则必满足以下三种情况之一，因此用或 || 连接；
>     以 节点 A为根节点的子树 包含树 B ，对应 `recur(A, B)`；
>     树 B 是 树 A 左子树 的子结构，对应 `isSubStructure(A.left, B)`；
>     树 B 是 树 A 右子树 的子结构，对应 `isSubStructure(A.right, B)`;
> - 判断树A中 以当前节点为根节点的子树 是否包含树B。（对应函数 `recur(A, B)`）
>   - 终止条件：
>     当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；
>     当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；
>     当节点 A 和 B 的值不同：说明匹配失败，返回 false ；
>   - 返回值：
>     判断 A 和 B 的左子节点是否相等，即 `recur(A.left, B.left)` ；
>     判断 A 和 B 的右子节点是否相等，即 `recur(A.right, B.right)` ；

101 对称二叉树/剑指 Offer 28（添加辅助函数，对于每个节点的左右孩子，判断其左的右和右的左，左的左和右的右是否相等，递归其左的右和右的左，左的左和右的右）

617 合并二叉树

965 单值二叉树

104 二叉树的最大深度/559 N 叉树的最大深度/111 二叉树的最小深度/110 平衡二叉树(一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 )

257 二叉树的所有路径

##  BST搜索二叉树

> 基础操作：创建，判断 BST 的合法性、增、删、查。删较复杂

95 不同的二叉搜索树 II

98.验证二叉搜索树（中序遍历为升序/左子树不空，左子树上所有节点的值均小于根节点的值； 若右子树不空，则右子树上所有节点的值均大于根节点的值；左右子树也为二叉搜索树。）

700.二叉搜索树中的搜索

701.二叉搜索树中的插入操作

> 450.删除二叉搜索树中的节点
>
> - 没找到删除的节点，遍历到空节点直接返回了
>
> - 找到删除的节点
>
>   - 左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
>   - 删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
>   - 删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
>   - 左右孩子节点都不为空，则将删除节点左孩子放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子。
>
>   <img src="/img/tree/450.删除二叉搜索树中的节点.gif"/>
>
>   ```java
>   TreeNode cur = root.right;
>   while(cur.left != null){
>       cur = cur.left;
>   }
>   cur.left = root.left;
>   root = root.right;
>   return root;
>   ```





