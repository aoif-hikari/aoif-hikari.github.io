---
tags: 图像处理
mathjax: true 
title: Optical Flow / 光流
---

> 在连续图片序列中，从第t帧到第t+1帧，每个像素的**运动速度**和**运动方向**。

<!-- more -->

稀疏光流:只计算图片中特定点的光流
稠密光流:每个像素都要计算光流。

## 光流的表示
用三维数组 $[height, width, 2]$ 表示。其中$height$表示图像的高度，$width$表示图像的宽度，2表示x,y两个方向。
光流是个和原来图像大小相等的双通道图像。
在x方向上，正值表示物体向左移动，而负值表示物体向右移动；在y方向上，正值表示物体向上移动，而负值表示物体向下移动。

## 光流提取

- 传统算法 Lucas-Kanade （稀疏）
- 深度学习算法 FlowNet/FlowNet2.0 （稠密）

https://zhuanlan.zhihu.com/p/74460341

## 光流可视化

### 稀疏

```
//[11,11,2]
//通道1
[[ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]
 [ 2.5  2.   1.5  1.   0.5  0.  -0.5 -1.  -1.5 -2.  -2.5]]
//通道2
[[ 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5]
 [ 2.   2.   2.   2.   2.   2.   2.   2.   2.   2.   2. ]
 [ 1.5  1.5  1.5  1.5  1.5  1.5  1.5  1.5  1.5  1.5  1.5]
 [ 1.   1.   1.   1.   1.   1.   1.   1.   1.   1.   1. ]
 [ 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5]
 [ 0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0. ]
 [-0.5 -0.5 -0.5 -0.5 -0.5 -0.5 -0.5 -0.5 -0.5 -0.5 -0.5]
 [-1.  -1.  -1.  -1.  -1.  -1.  -1.  -1.  -1.  -1.  -1. ]
 [-1.5 -1.5 -1.5 -1.5 -1.5 -1.5 -1.5 -1.5 -1.5 -1.5 -1.5]
 [-2.  -2.  -2.  -2.  -2.  -2.  -2.  -2.  -2.  -2.  -2. ]
 [-2.5 -2.5 -2.5 -2.5 -2.5 -2.5 -2.5 -2.5 -2.5 -2.5 -2.5]]
```

![](https://notes.sjtu.edu.cn/uploads/upload_c8aeb6016d832173d50d999f73f6a45f.png)

### 稠密

![](https://notes.sjtu.edu.cn/uploads/upload_5ea99a85113e6fb0f28a8bc190c35260.png)



## warp

将生成的光流应用到一张图像

在x方向上，正值表示物体向左移动，负值表示物体向右移动；
在y方向上，正值表示物体向上移动，而负值表示物体向下移动。 

x0 = pos_x + x， y0 = pos_y + y。pos_x和pos_y是原始的像素坐标，x和y是光流（向下取整），x0和y0就是warp后的像素坐标。以x方向为例，原始坐标加上一个负值，得到的结果变小了，也就相当于这个像素像左移了，如果加一个正值，结果变大，像素右移。

坐标变换后，很多坐标并没有相应的原始像素与之对应，需要通过插值来处理。

### 插值

图像的很多处理得到的结果是连续的，为了得到离散点上的值，就需要插值。典型代表就是图像坐标的空间变换，如仿射变换，坐标经仿射变换后通常是小数，而图像只保存整数坐标位置上的像素值，所以需要插值。

![](https://notes.sjtu.edu.cn/uploads/upload_d9a581e5ce7f1f5ed31f590edf8ddcc5.png)

- 四个角上的点 $P_{x, y}, P_{x+1, y}, P_{x, y+1}, P_{x+1, y+1}$ 是整数坐标位置上的已知点；
- 红色的点 $P_{x_{p}, y_{p}}$ 是待插值的点；
- 红色虚线连着的两个点 $P_{x_{p}, y}, P_{x_{p}, y+1}$ 是两个辅助点。

最邻近和双线性两种插值方法都比较简单，仅需要源图像和待插值的坐标。

#### nearest

最邻近插值算法将距离$P_{x_{p}, y_{p}}$最近的已知点的像素值直接赋给$P_{x_{p}, y_{p}}$，对${x_{p}, y_{p}}$四舍五入得到${x, y}$，直接令$P_{x_{p}, y_{p}}=P_{x, y}$即可

- 简单，但缺失精度，造成插值的图像灰度上的不连续，变化地方可能出现明显锯齿状

#### bilinear

双线性插值从两个方向进行线性插值

$$
P_{x_{p}, y}=P_{x, y}+\left(P_{x+1, y}-P_{x, y}\right)\left(x_{p}-x\right)
$$

$$
P_{x_{p}, y+1}=P_{x, y+1}+\left(P_{x+1, y+1}-P_{x, y+1}\right)\left(x_{p}-x\right)
$$


$$
P_{x_{p}, y_{p}}=P_{x_{p}, y}+\left(P_{x_{p}, y+1}-P_{x_{p}, y}\right)\left(y_{p}-y\right)
$$


参考：https://blog.csdn.net/bby1987/article/details/105851870

































