---
tags: 操作系统
mathjax: true 
title: 操作系统/内存管理
---

> 内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理，如果高速CPU直接和慢速的外存进行数据的交互，有速度矛盾。

<!--more-->

- 内存地址从0开始，每个地址对应一个存储单元

- 内存中也有一个一个的“小房间”，每个小房间就是以一个存储单元

- 如果计算机“按字节编址”，则每个存储单元大小为**1字节**，即1B，即**8个二进制位**

- 如果字长16位的计算机“按字编址”，则每个存储单元大小为**1个字**，每个字的大小为**16个二进制位**

操作系统的内存管理有以下四大功能：

## 操作系统负责内存空间的分配与回收

连续分配：为用户进程分配的必须是一个连续的内存空间。

非连续分配：为用户进程分配的可以是一些分散的内存空间。

### 连续分配管理方式

> 内部碎片，分配给某进程的内存区域中，有些部分没有用上。
> 外部碎片，是指内存中的某些空闲分区由于太小而难以利用。

#### 单一连续分配

内存被分为系统区和用户区。

- 系统区通常位于内存的低地址部分，用于存放操作系统相关数据；

- 用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。

> 优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC 操作系统MS-DOS）。
>
> 缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。

#### 固定分区分配

为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。

> 分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合
>
> （比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）
>
> 分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分
>
> （比如：划分多个小分区、适量中等分区、少量大分区）

操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。

当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。用数据结构的数组（或链表）即可表示这个表

<img src="/img/memory/biao.jpg" style="zoom: 67%;" />

> 优点：实现简单，无外部碎片。
>
> 缺点：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b. 会产生内部碎片，内存利用率低。

#### 动态分区分配

又称为可变分区分配。不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

1 系统要用什么样的数据结构记录内存的使用情况？

<img src="/img/memory/dynamic.jpg" style="zoom: 67%;" />

2 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。

| 首次适应                                                     | 最佳适应                                                     | 最坏适应                                               | 邻近适应                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | :----------------------------------------------------- | :----------------------------------------------------------- |
| 从头到尾找适合的分区                                         | 优先使用更小的分区，以保留更多大分区                         | 优先使用更大的分区，以防止产生太小的不可用的碎片       | 由首次适应演变而来，每次从上次查找结束位置开始查找           |
| 空闲分区以地址递增次序排列                                   | 以容量递增次序排列                                           | 以容量递减次序排列                                     | 以地址递增次序排列（可排列成循环链表）                       |
| 综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序 | 会有更多的大分区被保留下来，更能满足大进程需求               | 可以减少难以利用的小碎片                               | 不用每次都从低地址的小分区开始检索。算法开销小（原因同首次适应） |
|                                                              | 会产生很多太小的、难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序 | 大分区容易被用完，不利于大进程；算法开销大（原因同左） | 会使高地址的大分区也被用完                                   |

3 如何进行分区的分配与回收操作？

**分配**：？

**回收**：相邻的空闲分区要合并

情况一：回收区的后面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个

情况二：回收区的前面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个

情况三：回收区的前、后各有一个相邻的空闲分区，三个相邻的空闲分区合并为一个

情况四：回收区的前、后都没有相邻的空闲分区，新增一个表项。注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。

> 动态分区分配没有内部碎片，但是有外部碎片。
>
> 如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。

### 非连续分配管理方式

#### 基本分页存储管理

- 页框：将**内存空间**分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，每个页框有一个编号，即“页框号”，页框号从0开始。（页框=页帧=内存块=物理块=物理页面）

- 页/页面：将**进程的逻辑地址空间**也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，页号也是从0开始。

操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。

也即**进程的页面**与**内存的页框**有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中。

> 注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张**页表**。页表通常存在PCB（进程控制块）中。

<img src="/img/memory/yebiao.jpg" style="zoom: 50%;" />

页表记录进程页面和实际存放的内存块之间的映射关系。每个页表项的长度相同。

1. 每个页表项多大？占几个字节？
2. 如何通过页表实现逻辑地址到物理地址的转换？

**快表**，又称联想寄存器（TLB， translation lookaside buffer ），是一种访问速度比内存快很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。

> TLB 和普通Cache 的区别——TLB 中只有页表项的副本，而普通Cache 中可能会有其他各种数据的副本。

引入快表后，地址的变换过程？

**单级页表存在的的问题**

- 问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。


两级页表，把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表。

如何实现地址变换？

- 问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。


根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存。

可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。若想访问的页面不在内存中，则产生缺页中断（内中断/异常），然后将目标页面从外存调入内存

#### 基本分段存储管理

> 与“分页”最大的区别就是——离散分配时所分配地址空间的基本单位不同

进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。
内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。

地址变换过程？

**分页与分段的区别**

- 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。

- 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

- 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）

> 访问一个逻辑地址需要几次访存？
> 分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存
> 分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存
> 与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。

#### 段页式存储管理

## 操作系统需要提供某种技术从逻辑上对内存空间扩充

### 覆盖技术

> 早期的计算机内存很小，经常会出现内存大小不够的情况。引入覆盖技术，解决“程序大小超过物理内存总和”的问题。

覆盖技术的思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“固定区”和若干个“覆盖区”。

- 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）。

- 不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。

- 必须由程序员声明覆盖结构，操作系统完成自动覆盖。

缺点：对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。

### 交换技术

交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时**换出**外存，把外存中某些已具备运行条件的进程**换入**内存（进程在内存与磁盘间动态调度）。

中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。

暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）。挂起态又可以进一步细分为就绪挂起、阻塞挂起。

- 应该在**外存**（磁盘）的什么位置保存被换出的进程？

具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。

> 文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；
>
> 对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。

由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式（文件管理章节）。总之，对换区的I/O速度比文件区的更快。

- 什么时候应该交换？

交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。

例如：发现许多进程运行时经常发生缺页，说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，可以暂停换出。

- 应该换出哪些进程？

可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…（注意：PCB 会常驻内存，不会被换出外存）

### 虚拟存储技术

#### 传统存储管理方式的特征、缺点

**一次性：**作业必须一次性全部装入内存后才能开始运行。

这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

**驻留性：**一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

#### 局部性原理

**时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）

**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）

<img src="/img/memory/jubu.jpg" style="zoom: 50%;" />

**高速缓冲技术**的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。

基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序（请求调页功能）。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存（页面置换功能）。

**在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。**

> 虚拟内存有一下三个主要特征：
> 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
> 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
> 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。

#### 实现

- 请求分页存储管理

**在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序（请求调页）**

> - **何时调入页面？**
>   - 预调页策略：运行前调入。根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如 果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页 面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入， 由程序员指出应该先调入哪些部分。
>   - 请求调页策略：运行时调入。进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会 被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。
>
> - **从何处调页？**
>   - 系统拥有足够的对换区空间：页面的调入、调 出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前， 需将进程相关的数据从文件区复制到对换区。
>   - 系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。
>   - UNIX 方式：运行之前进程有关的数据全部放在 文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。

**若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存（页面置换）**

> **页面置换算法**决定应该换出哪个页面。页面换入换出需要磁盘IO，开销较大，所以好的页面置换算法因该追求更少的缺页率。
>
> 最佳置换算法；先进先出置换算法；最近最久未使用置换算法；时钟置换算法；改进型的时钟置换算法

在请求分页系统中，每当要访问的页面不在内存时，便产生一个**缺页中断**（属于内中断），然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。

如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。

如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。

一条指令在执行期间，可能产生多次缺页中断。

> 刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为**抖动**，或颠簸。
>
> 产生**抖动**的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）

**请求分页存储管理**与**基本分页存储管理**的主要区别：
在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

**页面分配、置换策略**

> 驻留集：指请求分页存储管理中给进程分配的物理块的集合。

固定分配VS可变分配：区别在于进程运行期间驻留集大小是否可变

局部置换ⅤS全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出

固定分配局部置换：进程运行前就分配一定数量物理块,缺页时只能换出进程自己的某一页

可变分配全局置换：只要缺页就分配新物理块,可能来自空闲物理块,也可能需换出别的进程页面

可变分配局部置换：频繁缺页的进程,多分配一些物理块;缺页率很低回收一些物理块。直到缺页率合适

- 请求分段存储管理

- 请求段页式存储管理

## 操作系统需要提供地址转换功能

负责程序的逻辑地址与物理地址的转换。逻辑地址到物理地址的转换称地址重定位

数据的实际存放地址（物理地址），但在实际中生产机器指令的时候并不知道该进程的数据会被放到什么位置，所以编译生成的指令一般使用的是逻辑地址（相对地址）

从写程序到程序运行：

<img src="/img/memory/run.jpg" style="zoom: 50%;" />

1. **编译**：由编译程序将用户源代码文件（* .c文件）编译成若干个目标模块（* .o文件）（编译就是把高级语言翻译成机器语言）
2. **链接**：由连接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块

> **静态链接**：在程序运行之前，将各个目标模块以及它们所需的库函数链接成一个完整的可执行文件（装入模块），之后便不再拆开
>
> **装入时动态链接**：将各个目标模块装入内存时，边装入边链接的链接方式
>
> **运行时动态链接**：在程序执行中需要该目标模块时，才对他进行链接。其优点是便于修改和更新，便于实现对目标模块的分享

3. **装入**：由装入程序将装入模块装入内存运行

> **绝对装入**：单道程序环境，此时还没产生操作系统，编译、链接后得到的装入模块的指令直接就使用了绝对地址
>
> **静态重定位（可重定位装入）**：用于早期的多道批处理操作系统。
>
> - 编译、链接后的装入模块的地址都是从0开始的，
>
> - **指令中**使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。
>
> - 装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换在装入时一次完成的）。
>
> 特点：在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。
>
> **动态重定位（动态运行时装入）**：现代操作系统。
>
> - 编译、链接后的装入模块的地址都是从0开始的。
>
> - 装入内存后所有的**指令中**使用的地址依然是逻辑地址，需设置重定位寄存器。（装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。）
>
> 允许程序在内存中发生移动。

##  操作系统需要提供内存保护功能

保证各个进程在各自的存储空间内运行，互不干扰。两种方法：

<img src="/img/memory/protect1.jpg" style="zoom: 50%;" />

### 设置上下限寄存器

在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。

<img src="/img/memory/protect2.jpg" style="zoom:50%;" />

### 利用重定位寄存器、界地址寄存器进行判断

采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。

<img src="/img/memory/protect3.jpg" style="zoom:50%;" />