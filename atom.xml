<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aoif-hikari</title>
  
  
  <link href="https://aoif-hikari.github.io/atom.xml" rel="self"/>
  
  <link href="https://aoif-hikari.github.io/"/>
  <updated>2021-07-30T09:33:23.243Z</updated>
  <id>https://aoif-hikari.github.io/</id>
  
  <author>
    <name>fu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构/多路查找树</title>
    <link href="https://aoif-hikari.github.io/2021/07/30/%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>https://aoif-hikari.github.io/2021/07/30/%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2021-07-30T09:23:01.004Z</published>
    <updated>2021-07-30T09:33:23.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大量数据存储中，在查找的背景下，BST由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。那么如何减少树的深度?</p></blockquote><span id="more"></span><h2 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h2><p>二叉排序树在多数情况能够达到预期的查找效率，但是<strong>每个节点只能存储一个元素</strong>和<strong>只能有两个孩子</strong>，大量数据情况下会造成树的深度特别大，查找时多次的访问会造成查找效率的下降。所以引入新的数据结构——多路查找树。</p><ul><li>多路查找树的每一个节点的孩子树可以多于两个，且每个节点处可以存储多个元素。</li><li>多路查找树是一种特殊的查找树，所以其元素之间存在某种特定的排序关系。</li><li>四种特殊形式：2-3树，2-3-4树，B树（B-树），B+树</li></ul><h2 id="B树（B-树）"><a href="#B树（B-树）" class="headerlink" title="B树（B-树）"></a>B树（B-树）</h2><p>B树（B-树）是一种平衡的多路查找树。2-3树和2-3-4树都是B树的特例。节点的最大孩子数目称为B树的阶（order），因此，2-3树是3阶B树，2-3-4树是4阶B树。</p><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>定义2-3树中每一个节点都具有两个孩子(称<strong>2节点</strong>)或三个孩子(称<strong>3节点</strong>)。</p><ul><li><p>一个2节点包含一个元素（关键字）和两个孩子(只能包含两个孩子或没有孩子)，且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。</p></li><li><p>一个3节点包含一小一大两个元素和三个孩子(只能包含三个孩子或没有孩子)。如果某个3节点有孩子，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</p></li><li><p>2-3树的所有叶子都在同一层次。</p><p><img src="/img/multitree/2-3.png"/></p></li></ul><p>插入/删除：略</p><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3-4树是2-3树的扩展，包括了4节点的使用，一个4节点包含小中大三个元素和四个孩子（或没有孩子）。</p><p>插入/删除：略</p><h3 id="应用：内外存的数据交互"><a href="#应用：内外存的数据交互" class="headerlink" title="应用：内外存的数据交互"></a>应用：内外存的数据交互</h3><p>计算机存储设备一般分为两种：内存储器和外存储器。 操作系统经常与内存和硬盘这两种存储设备进行通信，与内存操作，是虚拟一个页的概念来作为最小单位。</p><p>内存储器为内存，内存存取速度快，但容量小，价格昂贵，而且不能长期保存数据(在不通电情况下数据会消失)。</p><p>外存储器即为磁盘读取，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。</p><blockquote><p>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右。执行一次IO的时间可以执行40万条指令，所以磁盘IO是非常高昂的操作。</p></blockquote><p>当要处理的数据很大时，无法一次全部装入内存。这时对B树调整，使得B树的阶数与硬盘存储的页面大小相匹配。比如说一棵B树的阶为1001（即1个节点包含1000个关键字），高度为2（从0开始），它可以存储超过10亿个关键字（1001x1001x1000+1001x1000+1000）,只要让根节点持久的保留在内存中，那么在这颗树上，寻找某一个关键字至多需要两次硬盘的读取即可。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><img src="/img/multitree/b.png"/></p><p>假设要查询的数值是5，查询过程：</p><p>第一次IO：把9节点加载到内存中，在内存中与目标比较；</p><p>第二次IO：把（2，6）节点加载到内存中，在内存中与目标比较；</p><p>第二次IO：把（3，5）节点加载到内存中，在内存中与目标比较；</p><blockquote><p>二叉查找树情况下，每个节点只存放一个数据，查询数据的时候每加载节点比较一遍，进行一次磁盘IO。最坏情况下，磁盘IO次数等于树的高度</p></blockquote><p>B树在查询过程中<strong>比较次数</strong>其实并不会比二叉查找树少，尤其当某一个节点中的元素数量很多的时候。可是，单个节点的元素比较都在内存中进行，相比较于磁盘IO的速度,内存中比较耗时可以忽略不计，性能提高比较大。所以只要树的高度足够低，IO数量足够少，查询性能提升越明显。 相比之下，只要不超过磁盘页的大小，仅仅是多了几次内存的交互，这也是B树的优势之一。</p><p>B树应用于文件系统索引和部分非关系型数据库，如MongoDB</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src="/img/multitree/b+.png"/></p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>单元素查询过程：在单元素查询时，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。</p><p>范围查询过程：例如查询3到11之间的元素,首先单元素查找到下限3，然后在链表上做遍历即可</p><p>3, 5 -&gt; 8 -&gt; 11</p><blockquote><p>B树只能依靠中序遍历来实现范围查询，3, 5 (-&gt; 6) -&gt; 8 (-&gt;9) -&gt; 11</p></blockquote><p>B+树适合随机查找，只不过查到后是索引，不能提供实际记录的访问，还需要到达包含此关键字的终端节点。非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。B+树还适合带有范围的查找。</p><h4 id="和B树查询的不同"><a href="#和B树查询的不同" class="headerlink" title="和B树查询的不同"></a>和B树查询的不同</h4><ul><li><p>B+树的中间节点没有卫星数据。B树中所有节点都带有卫星数据，而在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何的数据关联。所以同样大小的磁盘页可以容纳更多的节点元素，也意味着数据量相同的情况下，B+树的结构比B树更加“矮胖”，因此查询IO次数更少；</p></li><li><p>B+树的查询必须最终找到叶子节点，而B树只要匹配到元素即可，不论它是中间节点还是叶子节点，因此B树的查询性能并不稳定(最好情况是只查询根节点，最坏情况查询到叶子节点)，而B+树每一次查找都是稳定的。</p></li></ul><blockquote><p>卫星数据：指索引元素所指向的数据记录，比如数据库中的某一行</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>大部分关系型数据库(如MySQL)使用的都是B+树作为索引。</p><blockquote><p><strong>关于索引</strong></p><ul><li><p>磁盘IO的存取次数是评价一个数据库索引优劣的关键性指标。利用索引查询数据的时会逐一加载磁盘页到内存当中，每一页对应索引树的节点。所以索引需要的是减少磁盘IO的次数以及节点存储更多的数据量。</p></li><li><p>在数据库的设计中，聚集索引(Clustered Index)，叶子节点直接包含了卫星数据。在非聚集索引(NonClustered Index)，叶子节点叶子节点存储的是主键值。</p></li></ul></blockquote><p>B+树相较于B树的优势有三个:</p><ul><li>IO次数更少：单一节点比B树存储了更多的数据，使得查询IO的次数减少</li><li>查询性能稳定：所有查询都要查找到叶子节点，查询性能稳定</li><li>范围查询简便：所有叶子节点形成有序链表，便于范围查询</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;大量数据存储中，在查找的背景下，BST由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。那么如何减少树的深度?&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://aoif-hikari.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA/JSP</title>
    <link href="https://aoif-hikari.github.io/2021/07/22/jsp/"/>
    <id>https://aoif-hikari.github.io/2021/07/22/jsp/</id>
    <published>2021-07-22T03:06:44.139Z</published>
    <updated>2021-07-22T03:07:55.419Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JSP规范来自于JAVAEE规范中一种，制定了如何开发JSP文件<strong>代替响应对象将处理结果写入到响应体</strong>的开发流程制，Http服务器应该如何调用管理JSP文件。放在<code>/web/*.jsp</code>下</p></blockquote><span id="more"></span><h2 id="JSP规范"><a href="#JSP规范" class="headerlink" title="JSP规范"></a>JSP规范</h2><blockquote><p>响应对象存在弊端</p></blockquote><ul><li>适合将数据量较少的处理结果写入到响应体。如果处理结果数量过多，使用响应对象增加开发难度</li></ul><blockquote><p>JSP文件优势</p></blockquote><ul><li><p>JSP文件在互联网通信过程，是响应对象替代品。降低将处理结果写入到响应体的开发工作量，降低处理结果维护难度。</p></li><li><p>在JSP文件开发时，可以直接将处理结果写入到JSP文件，不需要手写out.print命令。</p></li><li><p>在Http服务器调用JSP文件时，根据JSP规范要求自动将JSP文件书写的所有内容通过输出流写入到响应体。</p></li></ul><blockquote><p>HTML文件与JSP文件区别</p></blockquote><ul><li>作为资源文件类型不同</li></ul><p>HTML文件属于静态资源文件，其相关命令需要在浏览器编译并执行的.</p><p>JSP文件属于动态资源文件，其相关命令需要在服务端编译并执行的</p><ul><li>调用形式不同</li></ul><p>如果浏览器访问HTML文件，此时Http服务器直接通过一个输出流将HTML文件中所有的内容写入到响应体</p><p>如果浏览器访问JSP文件。此时Http服务器根据JSP规范来操作JSP文件编辑——&gt;编译——-&gt;调用</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--在JSP文件中直接书写Java命令，不能被JSP文件识别，此时只会被当做字符串写入到响应体--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="comment">//在只有书写在执行标记&lt;%中内容才会被当做Java命令</span></span><br><span class="line">  <span class="comment">//1.声明Java变量</span></span><br><span class="line">  <span class="keyword">int</span> num1 = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> num2 = <span class="number">200</span>;</span><br><span class="line">  <span class="comment">//2.声明运行表达式：数学运算，关系运算，逻辑运算</span></span><br><span class="line">  <span class="keyword">int</span> num3 = num1 + num2; <span class="comment">//数学运算</span></span><br><span class="line">  <span class="keyword">int</span> num4 = num2&gt;=num1?num2:num1;<span class="comment">//关系运算</span></span><br><span class="line">  <span class="keyword">boolean</span> num5 = num2&gt;=<span class="number">200</span> &amp;&amp; num1&gt;=<span class="number">100</span>;<span class="comment">//逻辑运算</span></span><br><span class="line">  <span class="comment">//3.声明控制语句</span></span><br><span class="line">   <span class="keyword">if</span>(num2&gt;=num1)&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">   <span class="keyword">int</span> num1 =<span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> num2 =<span class="number">200</span>;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--在JSP文件，通过输出标记，通知JSP将Java变量的值写入到响应体--&gt;</span><br><span class="line">变量num1的值:&lt;%=num1%&gt;&lt;br/&gt;</span><br><span class="line">变量num2的值:&lt;%=num2%&gt;&lt;br/&gt;</span><br><span class="line">&lt;!--执行标记还可以通知Jsp将运算结果写入到响应体--&gt;</span><br><span class="line">num1 + num2 = &lt;%=num1+num2%&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--制造数据--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">       Student stu1 = <span class="keyword">new</span> Student(<span class="number">10</span>,<span class="string">&quot;mike&quot;</span>);</span><br><span class="line">       Student stu2 = <span class="keyword">new</span> Student(<span class="number">20</span>,<span class="string">&quot;allen&quot;</span>);</span><br><span class="line">       Student stu3 = <span class="keyword">new</span> Student(<span class="number">30</span>,<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">       List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       list.add(stu1);</span><br><span class="line">       list.add(stu2);</span><br><span class="line">       list.add(stu3);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--数据输出--&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;2&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;学员编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;学员姓名&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%</span><br><span class="line">       <span class="keyword">for</span>(Student stu:list)&#123;</span><br><span class="line">    %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=stu.getSid()%&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=stu.getSname()%&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">       &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h2 id="JSP文件内置对象"><a href="#JSP文件内置对象" class="headerlink" title="JSP文件内置对象"></a>JSP文件内置对象</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">   JSP文件内置对象: request</span><br><span class="line">             类型：HttpServletRequest</span><br><span class="line">             作用: 在JSP文件运行时读取请求包信息</span><br><span class="line">                  与Servlet在请求转发过程中实现数据共享</span><br><span class="line"></span><br><span class="line">  浏览器： http:<span class="comment">//localhost:8080/myWeb/request.jsp?userName=allen&amp;password=123</span></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">   <span class="comment">//在JSP文件执行时，借助于内置request对象读取请求包参数信息</span></span><br><span class="line">    String userName = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    String password =request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">来访用户姓名:&lt;%=userName%&gt;&lt;br/&gt;</span><br><span class="line">来访用户密码:&lt;%=password%&gt;</span><br></pre></td></tr></table></figure><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    JSP文件内置对象:session</span><br><span class="line">              类型:HttpSession</span><br><span class="line">              作用：JSP文件在运行时，可以session指向当前用户私人储物柜，添加共享数据，或则读取共享数据</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--session1.jsp,将共享数据添加到当前用户私人储物柜--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">   <span class="comment">// HttpSession session = request.getSession();</span></span><br><span class="line">   session.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="number">200</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">      session_1.jsp 与session_2.jsp为同一个用户/浏览器提供服务。</span><br><span class="line">      因此可以使用当前用户在服务端的私人储物柜进行数据共享</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;%</span><br><span class="line">     Integer value=(Integer) session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">session_2.jsp从当前用户session中读取数据:&lt;%=value%&gt;</span><br></pre></td></tr></table></figure><h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">       JSP文件内置对象 ： application</span><br><span class="line">       ServletContext application;全局作用域对象</span><br><span class="line">       同一个网站中Servlet与JSP，都可以通过当前网站的全局作用域对象实现数据共享       </span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    application.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="JSP文件原理"><a href="#JSP文件原理" class="headerlink" title="JSP文件原理"></a>JSP文件原理</h2><p>Tomcat根据JSP规范，将被访问的JSP文件[编辑]为一个java文件。这个Java文件是Servlet接口实现类；调用JVM（javac one_jsp.java）将这个java文件[编译]为class类型；生成这个class文件的实例对象（Servelt接口实例对象）；通过实例对象调用class文件中_jspService方法，_jspService方法在运行时负责将JSP文件中书写内容写入到响应体中</p><blockquote><p>_jspService方法内部结构</p><p>判断当前请求方式。Jsp文件可以接收的请求方式有POST,GET,HEAD</p><p>声明局部变量。这些局部变量都可以在JSP文件开发时直接使用</p><p>输出部分。这部分执行时将JSP文件内容通过输出流写入到响应体</p></blockquote><h2 id="Servlet-与-JSP"><a href="#Servlet-与-JSP" class="headerlink" title="Servlet 与 JSP"></a>Servlet 与 JSP</h2><p>JSP文件被访问时，并不是JSP文件在执行，而是对应的Servlet在执行。自定义Serlvet接口实现类与JSP文件之间调用关系，等同于两个Servlet之间调用关系</p><ul><li>Servlet 与JSP 分工</li></ul><p>Servlet：负责处理业务并得到【处理结果】</p><p>JSP：不负责业务处理，主要任务将Servlet中【处理结果】写入到响应体</p><ul><li>Servlet 与  JSP 之间调用关系</li></ul><p>Servlet工作完毕后，一般通过请求转发方式 向Tomcat申请调用JSP</p><ul><li>Servlet  与 JSP 之间实现数据共享</li></ul><p>Servlet将处理结果添加到【请求作用域对象】</p><p>JSP文件在运行时从【请求作用域对象】得到处理结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理业务，得到处理结果-----查询信息</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">10</span>,<span class="string">&quot;mike&quot;</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="number">20</span>,<span class="string">&quot;allen&quot;</span>);</span><br><span class="line">        List stuList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        stuList.add(s1);</span><br><span class="line">        stuList.add(s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将处理结果添加到请求作用域对象</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;key&quot;</span>, stuList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过请求转发方案，向Tomcat申请调用user_show.jsp</span></span><br><span class="line">        <span class="comment">//同时将request与response通过tomcat交给user_show.jsp使用</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/user_show.jsp&quot;</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">   <span class="comment">//从请求作用域对象得到OneServlet添加进去的集合</span></span><br><span class="line">     List&lt;Student&gt; stuList = (List)request.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!--将处理结果写入到响应体--&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;2&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;用户编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;用户姓名&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">       <span class="keyword">for</span>(Student stu:stuList)&#123;</span><br><span class="line">    %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=stu.getSid()%&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=stu.getSname()%&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">       &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>Tomcat服务器本身自带了EL工具包（Tomcat安装地址/lib/el-api.jar）</p><p>格式：${作用域对象别名.共享数据}</p><p>作用：EL表达式是EL工具包提供一种特殊命令格式【表达式命令格式】，在JSP文件上使用，负责在JSP文件上从作用域对象读取指定的共享数据并输出到响应体。</p><p><code>&lt;%@ page isELIgnored=&quot;true&quot; %&gt;</code> 表示是否禁用EL语言,TRUE表示禁止.FALSE表示不禁止</p><h3 id="JSP文件可以使用的作用域对象"><a href="#JSP文件可以使用的作用域对象" class="headerlink" title="JSP文件可以使用的作用域对象"></a>JSP文件可以使用的作用域对象</h3><ul><li>ServletContext application:  全局作用域对象</li></ul><ul><li>HttpSession session: 会话作用域对象</li></ul><ul><li>HttpServletRequest request: 请求作用域对象</li></ul><ul><li>PageContext  pageContext：当前页作用域对象，这是JSP文件独有的作用域对象。Servlet中不存在在当前页作用域对象存放的共享数据仅能在当前JSP文件中使用，不能共享给其他Servlet或则其他JSP文件真实开发过程，主要用于JSTL标签与JSP文件之间数据共享数据（JSTL———-&gt;pageContext——&gt;JSP）</li></ul><blockquote><p>EL表达式提供作用域对象别名</p><p>​          JSP                           EL表达式</p><p>​      application                 ${applicationScope.共享数据名}</p><p>​      session                       ${sessionScope.共享数据名}</p><p>​      request                       ${requestScope.共享数据名}</p><p>​      pageContext              ${pageScope.共享数据名}</p></blockquote><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">     Integer sid =(Integer)application.getAttribute(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">     String  home=  (String)request.getAttribute(<span class="string">&quot;home&quot;</span>);</span><br><span class="line"> Student stu= (Student)request.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">学员ID:&lt;%=sid%&gt;&lt;br/&gt;</span><br><span class="line">学员地址:&lt;%=home%&gt;&lt;br/&gt;</span><br><span class="line">学员编号:&lt;%=stu.getSid()%&gt;&lt;br/&gt;</span><br><span class="line">学员姓名:&lt;%=stu.getSname()%&gt;</span><br><span class="line">&lt;!---EL表达式--&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">学员ID:  $&#123;applicationScope.sid&#125;&lt;br/&gt;</span><br><span class="line">学员地址：$&#123;requestScope.home&#125;&lt;br/&gt;</span><br><span class="line">&lt;!---将引用对象属性写入到响应体--&gt;</span><br><span class="line">学员编号:$&#123;requestScope.key.sid&#125;&lt;br/&gt;</span><br><span class="line">学员姓名:$&#123;requestScope.key.sname&#125;</span><br></pre></td></tr></table></figure><p><strong>EL表达式没有提供遍历集合方法，因此无法从作用域对象读取集合内容输出</strong></p><h3 id="EL表达式简化版"><a href="#EL表达式简化版" class="headerlink" title="EL表达式简化版"></a>EL表达式简化版</h3><p>EL表达式允许开发时省略作用域对象别名。命令格式： ${共享数据名}</p><p>EL表达式简化版由于没有指定作用域对象，所以在执行时采用【猜】算法</p><blockquote><p>首先到【pageContext】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【pageContext】没有定位成功，到【request】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【request】没有定位成功，到【session】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【session】没有定位成功，到【application】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【application】没有定位成功，返回null</p><p> pageContext—-&gt;request—-&gt;session—-&gt;application</p></blockquote><p>存在隐患：容易降低程序执行速度；容易导致数据定位错误</p><p>应用场景：设计目的就是简化从pageContext读取共享数据并输出的难度</p><p>EL表达式简化版尽管存在很多隐患，但是在实际开发过程中为了节省时间一都使用简化版。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">标准版EL表达式输出session中key的值:$&#123;sessionScope.key&#125;&lt;br/&gt;</span><br><span class="line">简化版EL表达式输出session中key的值:$&#123;key&#125;&lt;br/&gt;</span><br></pre></td></tr></table></figure><h3 id="支持运算表达式"><a href="#支持运算表达式" class="headerlink" title="支持运算表达式"></a>支持运算表达式</h3><p>在JSP文件有时需要将读取共享数据进行运算之后，将运算结果写入到响应体</p><blockquote><p>运算表达式包括：</p><p>1) 数学运算</p><p>2) 关系运算:  &gt;    &gt;=   ==    &lt;   &lt;=  !=</p><p>​                       gt   ge   eq    lt  le   !=</p><p>3)逻辑运算：  &amp;&amp;   ||    ！</p></blockquote><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--EL表达式支持运算表达式--&gt;</span><br><span class="line">&lt;!--将作用域对象中共享数据读取出来相加，将相加结果写入到响应体--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">     String num1 = (String)request.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">     Integer num2 = (Integer)request.getAttribute(<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> sum = Integer.valueOf(num1) + num2;</span><br><span class="line">%&gt;</span><br><span class="line">传统的Java命令计算后的结果:&lt;%=sum%&gt;</span><br><span class="line">EL表达式计算后的结果:$&#123;key1+key2&#125;</span><br><span class="line">EL表达式输出关系运算:$&#123;age ge <span class="number">12</span>?<span class="string">&quot;欢迎光临&quot;</span>:<span class="string">&quot;谢绝入内&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="EL表达式提供内置对象"><a href="#EL表达式提供内置对象" class="headerlink" title="EL表达式提供内置对象"></a>EL表达式提供内置对象</h3><h4 id="param"><a href="#param" class="headerlink" title="param"></a>param</h4><p>命令格式: ${param.请求参数名}</p><p>命令作用： 通过请求对象读取当前请求包中请求参数内容，并将请求参数内容写入到响应体</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt; </span><br><span class="line">&lt;%</span><br><span class="line"> String userName = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line"> String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"> %&gt;</span><br><span class="line">来访者姓名:&lt;%=userName%&gt;</span><br><span class="line">来访者密码:&lt;%=password%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用EL表达式内置对象--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">   http:<span class="comment">//localhost:8080/myWeb/index_1.jsp?userName=mike&amp;password=123</span></span><br><span class="line">--&gt;</span><br><span class="line">来访者姓名:$&#123;param.userName&#125;&lt;br/&gt;</span><br><span class="line">来访者密码:$&#123;param.password&#125;</span><br></pre></td></tr></table></figure><h4 id="paramValues"><a href="#paramValues" class="headerlink" title="paramValues"></a>paramValues</h4><p>命令格式：${paramValues.请求参数名[下标]}</p><p>命令作用: 如果浏览器发送的请求参数是[一个请求参数关联多个值]，此时可以通过paramVaues读取请求参数下指定位置的值，并写入到响应体。此时pageNo请求参数在请求包以数组形式存在</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String  array[]= request.getParameterValues(<span class="string">&quot;pageNo&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">第一个值:&lt;%=array[<span class="number">0</span>]%&gt;</span><br><span class="line">第二个值:&lt;%=array[<span class="number">1</span>]%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用EL表达式内置对象--&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt; </span><br><span class="line">&lt;!--</span><br><span class="line">http:<span class="comment">//localhost:8080/myWeb/index_2.jsp?deptNo=10&amp;deptNo=20&amp;deptNo=30</span></span><br><span class="line">--&gt;</span><br><span class="line">第一个部门编号:$&#123;paramValues.deptNo[<span class="number">0</span>]&#125;&lt;br/&gt;</span><br><span class="line">第二个部门编号:$&#123;paramValues.deptNo[<span class="number">1</span>]&#125;&lt;br/&gt;</span><br><span class="line">第三个部门编号:$&#123;paramValues.deptNo[<span class="number">2</span>]&#125;&lt;br/&gt;</span><br></pre></td></tr></table></figure><p> header/headerValues/cookie</p><h3 id="EL表达式常见异常"><a href="#EL表达式常见异常" class="headerlink" title="EL表达式常见异常"></a>EL表达式常见异常</h3><p><code>javax.el.PropertyNotFoundException</code>在对象中没有找到指定属性</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JSP规范来自于JAVAEE规范中一种，制定了如何开发JSP文件&lt;strong&gt;代替响应对象将处理结果写入到响应体&lt;/strong&gt;的开发流程制，Http服务器应该如何调用管理JSP文件。放在&lt;code&gt;/web/*.jsp&lt;/code&gt;下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://aoif-hikari.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA/html与css</title>
    <link href="https://aoif-hikari.github.io/2021/07/22/html%E4%B8%8Ecss/"/>
    <id>https://aoif-hikari.github.io/2021/07/22/html%E4%B8%8Ecss/</id>
    <published>2021-07-22T03:03:58.422Z</published>
    <updated>2021-07-22T03:10:12.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTML，超文本标记式编程语言，是一种专门在浏览器编译与执行的编程语言。用于通知浏览器将接收的数据以指定方式在窗口展示；控制浏览器请求行为。CSS则用于定位浏览器中HTML标签并对定位的HTML标签中【样式属性】进行统一管理。</p></blockquote><span id="more"></span><h2 id="HTML语法规范"><a href="#HTML语法规范" class="headerlink" title="HTML语法规范"></a>HTML语法规范</h2><ul><li>所有命令都是声明在标签中,比如<code>&lt;br&gt;</code></li><li>不区分英文字母大小写，比如<code>&lt;BR&gt;</code>,<code>&lt;br&gt;</code>, <code>&lt;Br&gt;</code> 都是合法命令</li><li>命令开发时主要通过对命令中属性进行赋值实现开发目的。</li></ul><p>属性赋值时内容可以包含在<code>&quot;&quot;</code>中，也可以包含在<code>&#39;&#39;</code>，也可以省略双引号与单引号，此时属性之间必须采用空格进行隔离。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;one&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">name</span>=<span class="string">one/</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>命令根据书写方式分为：双目标签命令与单目标签命令</li></ul><p>双目标签命令书写命令分别出现在开始标签与结束标签，比如 <code>&lt;tr&gt;&lt;/tr&gt;</code>，结束标签不能省略<br>单目标签命令书写命令出现一个标签之内，比如<code>&lt;br/&gt;</code><br>单目标签命令用于表示结束”/“可以省略不写，比如 <code>&lt;br/&gt;</code>, <code>&lt;br&gt;</code> 这两个都是合法单目标签命令</p><h2 id="浏览器发送请求三要素"><a href="#浏览器发送请求三要素" class="headerlink" title="浏览器发送请求三要素"></a>浏览器发送请求三要素</h2><p>控制浏览器发送请求地址；请求方式；携带请求参数</p><h3 id="控制浏览器发送请求地址"><a href="#控制浏览器发送请求地址" class="headerlink" title="控制浏览器发送请求地址"></a>控制浏览器发送请求地址</h3><h4 id="超链接标签命令"><a href="#超链接标签命令" class="headerlink" title="超链接标签命令"></a>超链接标签命令</h4><ul><li>格式：  <code>&lt;a href=&quot;请求地址&quot;&gt;提示信息&lt;/a&gt;</code></li></ul><ul><li>原理：  超链接标签命令不会被浏览器自动执行。在用户使用鼠标单击超链接标签命令时，命令才会执行，执行要求浏览器立刻按照href属性地址发送请求</li></ul><h4 id="表单标签命令"><a href="#表单标签命令" class="headerlink" title="表单标签命令"></a>表单标签命令</h4><ul><li>格式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;请求地址&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="comment">&lt;!--提交按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>原理：表单标签命令不会被浏览器自动执行。在用户单击提交按钮时，此时表单标签命令被触发执行。执行时要求浏览器立刻按照action属性地址发送请求</li></ul><h3 id="控制浏览器发送请求采用请求方式"><a href="#控制浏览器发送请求采用请求方式" class="headerlink" title="控制浏览器发送请求采用请求方式"></a>控制浏览器发送请求采用请求方式</h3><p>请求方式：决定浏览器在发送请求时行为特征</p><p>浏览器可以选择请求方式：7种，目前为止只考虑【POST请求方式】和【GET请求方式】</p><blockquote><p>GET请求方式：</p><p>要求浏览器发送请求时，携带的【请求参数数量】不能超过4K；必须在浏览器地址栏上将【请求参数信息】展示出来；必须将请求参数信息保存在Http请求协议包中【请求头】；要求浏览器在接收到服务器返回的资源文件内容后，必须将资源文件内容保存在浏览器的缓存</p><p>POST请求方式：<br>要求浏览器发送请求时，可以携带任意数量的【请求参数】；必须在浏览器地址栏上隐藏请求参数信息；必须将请求参数信息保存在Http请求协议包中【请求体】；禁止浏览器将服务器返回资源文件内容进行保存【阅后即焚】</p></blockquote><h4 id="控制浏览器发送请求时采用GET请求方式"><a href="#控制浏览器发送请求时采用GET请求方式" class="headerlink" title="控制浏览器发送请求时采用GET请求方式"></a>控制浏览器发送请求时采用GET请求方式</h4><ul><li>超链接标签命令在执行时，要求浏览器必须采用GET方式发送请求</li></ul><ul><li>表单标签存在一个method属性，通过这个属性可以要求浏览器采用对应请求方式发送请求</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;请求地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;请求地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--method属性默认值是GET--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;请求地址&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="控制浏览器发送请求时采用POST请求方式"><a href="#控制浏览器发送请求时采用POST请求方式" class="headerlink" title="控制浏览器发送请求时采用POST请求方式"></a>控制浏览器发送请求时采用POST请求方式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="请求方式适用场景"><a href="#请求方式适用场景" class="headerlink" title="请求方式适用场景"></a>请求方式适用场景</h4><p>考虑到POST请求方式，用户可以将【病毒文件内容】发送到服务器上进行攻击。因此绝大多数门户级网站拒绝接收POST请求，日常开发过程绝大多数请求都是GET。在某些特殊场景下必须使用POST：</p><ul><li>文件上传</li><li>发起登录验证请求</li><li>索要服务器中实时变化数据时（股票价格，车票数量……）</li></ul><h3 id="控制浏览器发送请求携带请求参数"><a href="#控制浏览器发送请求携带请求参数" class="headerlink" title="控制浏览器发送请求携带请求参数"></a>控制浏览器发送请求携带请求参数</h3><p>方法运行时需要实参，需要由用户通过浏览器以请求参数方式提供。如<code>http：//www.baidu.com?n1=100&amp;n2=200</code>  [n1=100&amp;n2=200]就是浏览器发送请求参数。</p><p>请求参数格式：请求地址?请求参数名1=值1&amp;请求参数名2=值2</p><p>浏览器发送请求时携带的请求参数来源：</p><ul><li>通过超链接标签命令指定请求参数</li></ul><p><code>&lt;a href=&quot;http：//www.baidu.com?userName=mike&amp;password=123&quot;&gt;百度&lt;/a&gt;</code></p><ul><li>通过表单域标签命令指定请求参数</li></ul><p>表单域标签命令，一组声明在form标签内部的标签命令，提示用户填写对应的【请求参数内容】，用于提供相对灵活的请求参数内容</p><p>表单域标签分类：<code>&lt;input /&gt;</code>，<code>&lt;select&gt;&lt;/select&gt;</code>，<code>&lt;textarea&gt;&lt;/textarea&gt;</code></p><p>所有的表单域标签都拥有两个属性：name属性声明【请求参数名】；value属性声明【请求参数内容】</p><blockquote><p>value属性默认值</p><p>大多数表单域标签value属性默认值是空字符串 userName=’ ‘</p><p>对于radio与checkbox来说，value属性默认值’on’字符串</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http：//www.baidu.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mike&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当用户单击submit后，浏览器发送请求信息 <code>http：//www.baidu.com?userName=mike</code></p><blockquote><p>表单域标签作为请求参数条件</p></blockquote><p>对于大多数表单域标签来说，只要同时满足两个条件，就可以作为请求参数：必须声明在form标签内部；必须声明name属性。</p><p>对于radio标签与checkbox标签来说在满足上述两个条件同时，radio与checkbox必须在【被选中】的情况下才可以作为请求参数。</p><p>如果表单域标签使用disabled来修饰时，失去作为请求参数条件</p><blockquote><p>readOnly与disabled：<br>readOnly：要求当前标签中value属性只能看但是不能被修改，readOnly不会影响表单域标签作为请求参数条件<br>disabled：设置当前标签为不可用状态，此时标签中value属性内容不能被修改的。disabled修饰的表单域标签是永远都不能作为请求参数</p></blockquote><h2 id="HTML标签属性分类"><a href="#HTML标签属性分类" class="headerlink" title="HTML标签属性分类"></a>HTML标签属性分类</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p>大多数HTML标签都拥有的属性，是一个非常庞大群体</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id属性，用于区分HTML标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- name属性，允许一组标签拥有相同name--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;myText&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;myText&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="样式属性"><a href="#样式属性" class="headerlink" title="样式属性"></a>样式属性</h3><p>通知浏览器将HTML标签中数据在浏览器中以指定形态展示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color：red;color：green;width：300px;height：200px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="工作状态属性"><a href="#工作状态属性" class="headerlink" title="工作状态属性"></a>工作状态属性</h3><p>只存在于【表单域标签】中，用于表示【表单域标签】状态。</p><blockquote><p>checked：存在于radio与checkbox中，表示标签是否被选中</p><p>disabled：表示标签处于不可用状态</p><p>readOny：表示标签处于只读状态</p><p>seleteced：存在option标签，表示标签是否被选中</p></blockquote><h3 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h3><p>监听属性用于监听用户在何时对当前标签进行何种操作,当指定操作产生时，监听属性将会通知浏览器调用对应JavaScript方法处理当前请求。</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>通知浏览器将所有满足定位条件的HTML标签进行统一定位；对已经定位HTML标签中样式属性进行集中统一赋值管理。</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>CSS选择器，一组定位条件用于定位HTML标签，有9个大的分类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--CSS选择器语法格式--&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;!--type=&#x27;text/css&#x27;，--&gt;</span><br><span class="line">        &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        定位条件&#123;</span><br><span class="line">        &quot;样式属性<span class="number">1</span>&quot;：&quot;值<span class="number">1</span>&quot;;</span><br><span class="line">        &quot;样式属性<span class="number">2</span>&quot;：&quot;值<span class="number">2</span>&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--ID选择器,根据<span class="selector-tag">HTML</span>标签中ID属性的值进行定位--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-id">#id</span>编号&#123;</span><br><span class="line">        &quot;样式属性<span class="number">1</span>&quot;：&quot;值<span class="number">1</span>&quot;;</span><br><span class="line">        &quot;样式属性<span class="number">2</span>&quot;：&quot;值<span class="number">2</span>&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--标签类型选择器,根据<span class="selector-tag">HTML</span>标签类型进行定位--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    标签类型名&#123;</span><br><span class="line">        &quot;样式属性<span class="number">1</span>&quot;：&quot;值<span class="number">1</span>&quot;;</span><br><span class="line">        &quot;样式属性<span class="number">2</span>&quot;：&quot;值<span class="number">2</span>&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--层级选择器,根据标签之间父子关系或则兄弟关系进行定位--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    定位父标签条件  定位子标签条件&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    找到指定父标签下满足条件的所有子标签</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--自定义选择器--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .自定义选择器名&#123;</span><br><span class="line">        <span class="attribute">color</span>：red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;自定义选择器名&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>   class=&quot;自定义选择器名&quot;&gt;&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;HTML，超文本标记式编程语言，是一种专门在浏览器编译与执行的编程语言。用于通知浏览器将接收的数据以指定方式在窗口展示；控制浏览器请求行为。CSS则用于定位浏览器中HTML标签并对定位的HTML标签中【样式属性】进行统一管理。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://aoif-hikari.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode/二叉树</title>
    <link href="https://aoif-hikari.github.io/2021/07/19/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://aoif-hikari.github.io/2021/07/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-07-19T06:02:00.182Z</published>
    <updated>2021-07-30T09:34:07.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二叉树与递归有着千丝万缕的联系，二叉树在定义时就使用了递归的概念：一棵二叉树可能是空树，如果不是空树，那么它的左右子树都是二叉树。</p></blockquote><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span></span>&#123;</span><br><span class="line">    Object element;</span><br><span class="line">    BinaryNode left;</span><br><span class="line">    BinaryNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础：二叉树的遍历"><a href="#基础：二叉树的遍历" class="headerlink" title="基础：二叉树的遍历"></a>基础：二叉树的遍历</h2><p>遍历时均无返回值，所以遍历要另写函数，把需要返回的作为参数传入。</p><h3 id="DFS-深度优先"><a href="#DFS-深度优先" class="headerlink" title="DFS, 深度优先"></a>DFS, 深度优先</h3><h4 id="先序遍历：根左右（文件目录结构）"><a href="#先序遍历：根左右（文件目录结构）" class="headerlink" title="先序遍历：根左右（文件目录结构）"></a>先序遍历：根左右（文件目录结构）</h4><p>常规迭代</p><ul><li><p>初始化栈，并将根节点入栈；</p></li><li><p>当栈不为空时：</p><ul><li>弹出栈顶元素 node，并将值添加到结果中；</li><li>如果 node 的右子树非空，将右子树入栈；</li><li>如果 node 的左子树非空，将左子树入栈；</li></ul></li></ul><p>由于栈是“先进后出”的顺序，所以入栈时先将右子树入栈，这样使得前序遍历结果为 “根-&gt;左-&gt;右”的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代，非递归实现,本质使用栈模拟递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//初始化栈，并将根节点入栈；</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"><span class="comment">//当栈不为空时：</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//弹出栈顶元素 node，并将值添加到结果中；</span></span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        System.out.print(node.val); </span><br><span class="line">        <span class="comment">//如果 node 的右子树非空，将右子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">        <span class="comment">//如果 node 的左子树非空，将左子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板迭代</p><ul><li><p>先将根节点 <code>cur</code> 和所有的左孩子入栈并加入结果中，直至 <code>cur</code> 为空</p></li><li><p>每弹出一个栈顶元素 <code>tmp</code>，就到达它的右孩子，再将这个节点当作 <code>cur</code> 重新按上面的步骤来一遍，直至栈为空。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//将根节点cur和所有的左孩子入栈并加入结果中，直至cur为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(cur.val); </span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每弹出一个栈顶元素tmp,就到达它的右孩子,再将这个节点当作cur</span></span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        cur = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder_Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;        </span><br><span class="line">    <span class="comment">//访问节点的逻辑代码块</span></span><br><span class="line">    System.out.print(root.val+<span class="string">&quot; &quot;</span>);       </span><br><span class="line">    preorder_Traversal(root.left);</span><br><span class="line">    preorder_Traversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历：左根右"><a href="#中序遍历：左根右" class="headerlink" title="中序遍历：左根右"></a><strong>中序遍历：左根右</strong></h4><p>模板迭代：</p><ul><li><p>先将根节点 <code>cur</code> 和所有的左孩子入栈中，直至 <code>cur</code> 为空</p></li><li><p>每弹出一个栈顶元素 <code>tmp</code>，加入结果中，并到达它的右孩子，再将这个节点当作 <code>cur</code> 重新按上面的步骤来一遍，直至栈为空。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//将根节点cur和所有的左孩子入栈中，直至cur为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每弹出一个栈顶元素tmp,加入结果中，并到达它的右孩子,再将这个节点当作cur</span></span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        System.out.print(temp.val); </span><br><span class="line">        cur = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder_Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    inorder_Traversal(root.left);        </span><br><span class="line">    <span class="comment">//访问节点的逻辑代码块</span></span><br><span class="line">    System.out.print(root.val+<span class="string">&quot; &quot;</span>);       </span><br><span class="line">    inorder_Traversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后续遍历：左右根"><a href="#后续遍历：左右根" class="headerlink" title="后续遍历：左右根"></a><strong>后续遍历：左右根</strong></h4><p>对前序遍历的（根左右）修改为（根右左），再倒序输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规倒序输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//初始化栈，并将根节点入栈；</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; resStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"><span class="comment">//当栈不为空时：</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//弹出栈顶元素 node，并将值添加到结果中；</span></span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        resStack.push(node);</span><br><span class="line">        <span class="comment">//如果 node 的右子树非空，将右子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        <span class="comment">//如果 node 的左子树非空，将左子树入栈；</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!resStack.isEmpty())&#123;</span><br><span class="line">        res.add(resStack.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板倒序输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; resStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="comment">//将根节点cur和所有的右孩子入栈并加入结果中，直至cur为空</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !s.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            resStack.push(cur); <span class="comment">// root</span></span><br><span class="line">            s.push(cur); </span><br><span class="line">            cur = cur.right; <span class="comment">// right</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//弹出一个栈顶元素tmp，并到达它的左孩子，再将这个节点当作cur</span></span><br><span class="line">        cur = s.pop();</span><br><span class="line">        cur = cur.left; <span class="comment">// left</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反向输出</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!resStack.isEmpty())&#123;</span><br><span class="line">        res.add(resStack.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder_Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    postorder_Traversal(root.left);</span><br><span class="line">    postorder_Traversal(root.right);        </span><br><span class="line">    <span class="comment">//访问节点的逻辑代码块</span></span><br><span class="line">    System.out.print(root.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-广度优先（层次遍历）"><a href="#BFS-广度优先（层次遍历）" class="headerlink" title="BFS, 广度优先（层次遍历）"></a>BFS, 广度优先（层次遍历）</h3><p>广度优先搜索的步骤为：</p><ul><li><p>初始化队列 q，并将根节点 root 加入到队列中；</p></li><li><p>当队列不为空时：</p><ul><li>队列中弹出节点 node，加入到结果中；</li><li>如果左子树非空，左子树加入队列；</li><li>如果右子树非空，右子树加入队列；</li></ul></li></ul><p><img src="/img/tree/bfs1.gif"/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列实现,分层次，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; LaywerTraversal(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 初始化队列 q，并将根节点 root 加入到队列中；</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">//当队列不为空时：</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="comment">//队列中弹出节点 node，加入到结果中；</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="comment">//如果左子树非空，左子树加入队列；</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="comment">//如果右子树非空，右子树加入队列；</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/tree/bfs2.gif"/></p><p>BFS常用于找最短路径。</p><p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p><p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p><blockquote><p>表达式树：分别对应前缀表达式/中缀表达式/后缀表达式</p><p>树叶是操作数值，其他节点是操作符。</p></blockquote><p>后缀表达式转树：操作数压栈，操作符弹栈</p><h2 id="对应例题"><a href="#对应例题" class="headerlink" title="对应例题"></a>对应例题</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>144 二叉树的先序遍历</p><p>589 N 叉树的前序遍历</p><blockquote><p><strong>606 根据先序遍历结果构造字符串</strong></p><ul><li>在先序遍历中，对每个非空访问元素，在进行处理时，先形成字符串”(“+ root.val；</li></ul><p>例如，对于[1,2,3,4]，得到”(1(2(4”</p><ul><li>如果当前访问的节点的左子树为空且右子树不为空，就在字符串中添加一个”()”</li></ul><p>这样得到, “(1(2(4()”</p><ul><li>同时，对于每轮递归中，在最终返回前，补全右括号”)”</li></ul><p>这样我们得到 “(1(2(4())(3))”</p><p>由此，基本输出形式已经完成。剩下处理头尾两个多余括号。</p><p><strong>331 验证是否是合法先序遍历结果</strong></p><ul><li><p>二叉树看成有向图，一条有向边带来一个入度和一个出度，二叉树的总入度等于总出度，也等于边数。即，遍历到最后，总入度肯定等于总出度。</p></li><li><p>还没遍历到最后时，肯定不会出现 入度 &gt;= 出度 的时刻。</p></li></ul><p>提供 1 个出度可以理解为提供一个挂载点，提供 1 个入度为消耗一个挂载点。入度 &gt;= 出度，意味着当前已遍历的节点，消耗的挂载点已经大于等于提供的挂载点。说明已经没法挂载接下来遍历的节点了，还有要挂的，但挂满了，是不合法的。</p></blockquote><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>94 基本的中序遍历</p><p>173 二叉搜索树迭代器</p><p>中序遍历一般会和BST（二叉搜索树）结合使用，这样访问的顺序是升序</p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>145 基本的二叉树的后序遍历</p><p>590 N 叉树的后序遍历</p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>102 二叉树的层序遍历</p><p>103 二叉树的锯齿形层序遍历（每层加flag或用双端队列）</p><p>107  二叉树的层序遍历 II（自底向上）</p><p>429 N 叉树的层序遍历</p><h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><p>递归三步：确定递归函数的参数和返回值；确定终止条件（if(root == null) return;）；确定单层递归逻辑（对哪个节点进行什么递归操作）；</p><p>226 翻转二叉树（对于每个节点，交换其左右子树，递归其左右子树）</p><p>100 相同的树（对于每个节点，判断其值是否相等，递归其左右子树）</p><p>572 另一个树的子树(一个树是另一个树的子树，要么这两个树相等；要么这个树是左树的子树；要么是右树的子树。)</p><blockquote><p><strong>剑指 Offer 26 树的子结构</strong></p><ul><li>先序遍历树 A中的每个节点；（对应函数 <code>isSubStructure(A, B)</code>）<ul><li>特例处理： 当 树 A为空 <strong>或</strong> 树 B 为空 时，直接返回 false；</li><li>返回值： 若树 BB 是树 AA 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<br>以 节点 A为根节点的子树 包含树 B ，对应 <code>recur(A, B)</code>；<br>树 B 是 树 A 左子树 的子结构，对应 <code>isSubStructure(A.left, B)</code>；<br>树 B 是 树 A 右子树 的子结构，对应 <code>isSubStructure(A.right, B)</code>;</li></ul></li><li>判断树A中 以当前节点为根节点的子树 是否包含树B。（对应函数 <code>recur(A, B)</code>）<ul><li>终止条件：<br>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；<br>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；<br>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li><li>返回值：<br>判断 A 和 B 的左子节点是否相等，即 <code>recur(A.left, B.left)</code> ；<br>判断 A 和 B 的右子节点是否相等，即 <code>recur(A.right, B.right)</code> ；</li></ul></li></ul></blockquote><p>101 对称二叉树/剑指 Offer 28（添加辅助函数，对于每个节点的左右孩子，判断其左的右和右的左，左的左和右的右是否相等，递归其左的右和右的左，左的左和右的右）</p><p>617 合并二叉树</p><p>965 单值二叉树</p><p>104 二叉树的最大深度/559 N 叉树的最大深度/111 二叉树的最小深度/110 平衡二叉树(一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1 )</p><p>257 二叉树的所有路径</p><h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><blockquote><p>基础操作：创建，判断 BST 的合法性、增、删、查。删较复杂</p><p>性质：中序遍历为升序/投射x轴后有序。</p><p><img src="/img/tree/x.png"/></p></blockquote><p><strong>创建</strong></p><p>95 不同的二叉搜索树 II</p><p>108 将有序数组转换为二叉搜索树</p><p>109 有序链表转换二叉搜索树</p><p><strong>合法性</strong></p><p>98.验证二叉搜索树（<strong>中序遍历为升序</strong>/左子树不空，左子树上所有节点的值均小于根节点的值； 若右子树不空，则右子树上所有节点的值均大于根节点的值；左右子树也为二叉搜索树。）</p><p><strong>查</strong></p><p>700.二叉搜索树中的搜索</p><p><strong>增</strong></p><p>701 二叉搜索树中的插入操作</p><p><strong>删（合并删除/排序删除）</strong></p><blockquote><p>450.删除二叉搜索树中的节点</p><p><strong>合并删除：实质是将被删节点的的左子树合并到右子树上（反之也可），导致树的高度发生变化，极其容易导致树结构的不平衡。</strong></p><ul><li><p>没找到删除的节点，遍历到空节点直接返回</p></li><li><p>找到删除的节点</p><ul><li>左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>左右孩子节点都不为空，则将删除节点左孩子放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子。</li></ul><p><img src="/img/tree/450.删除二叉搜索树中的节点.gif"/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右孩子节点都不为空的情况</span></span><br><span class="line">TreeNode cur = root.right;</span><br><span class="line"><span class="keyword">while</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cur = cur.left;</span><br><span class="line">&#125;</span><br><span class="line">cur.left = root.left;</span><br><span class="line">root = root.right;</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li></ul><p><strong>复制删除：不删除这个结点，而是让这个节点被覆盖。没有改变树的深度，对于树的删除是更优。</strong></p><p>后继节点：大于删除结点的最小结点（删除结点的右子树最左结点）</p><p>前驱节点：小于删除结点的最大结点（删除结点的左子树最右结点）</p><p>即中序遍历后被删节点的前驱和后继。</p><ul><li><p>没找到删除的节点，遍历到空节点直接返回</p></li><li><p>找到删除的节点</p><ul><li><p>左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</p></li><li><p>若删除结点只有一个子结点，用子结点替换删除结点</p></li><li><p>若删除结点有两个子结点，用后继结点替换删除结点（前驱结点替代也可以，但习惯上拿后继结点来替代），再删除该后继节点。</p><p><img src="/img/tree/copydele.png"/></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) root = root.left;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点有两个子结点的情况</span></span><br><span class="line">root.val = successor(root); <span class="comment">// 把 root.val 改成 successor</span></span><br><span class="line">root.right = deleteNode(root.right, root.val); <span class="comment">// 删除 successor</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h3><p>一个二叉查找树，每个节点的左右两个子树的高度差的绝对值不超过 1。</p><blockquote><p><strong>平衡因子</strong>： 某个结点的左子树的高度减去右子树的高度得到的差值。</p></blockquote><h4 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h4><p>对于一般的二叉搜索树，其期望高度（即为一棵平衡树时）为$log_2n$，其各操作的时间复杂度$O(log_2n)$</p><p>但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即$O(n)$。</p><p>我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</p><p>例如：按顺序将一组数据{1,2,3,4,5,6}分别插入到一颗空二叉查找树和AVL树中，插入的结果如下图：</p><p><img src="/img/tree/avl1.png"/></p><p><img src="/img/tree/avl2.png"/></p><p>由图可知，同样的结点，由于插入方式不同导致树的高度也有所不同。</p><p>特别是在带插入结点个数很多且正序的情况下，会导致二叉树的高度是$O(N)$.</p><p>而AVL树就不会出现这种情况，树的高度始终是$O(logN)$。</p><h4 id="how？"><a href="#how？" class="headerlink" title="how？"></a>how？</h4><p>平衡化有两大基础操作： 左旋和右旋。这两种操作都是从<strong>失去平衡的最小子树根结点</strong>开始的(即离插入结点最近且平衡因子超过1的祖结点)。</p><p><strong>左旋</strong>： y 结点变为该部分子树的根结点，同时 x 结点（连同其左子树 a）移动至 y 结点的左孩子。若 y 结点有左孩子 b，由于 x 结点需占用其位置，所以调整至 x 结点的右孩子处。</p><p><strong>右旋</strong>：x 结点变为根结点，同时 y 结点连同其右子树 c 作为 x 结点的右子树，原 x 结点的右子树 b 变为 y 结点的左子树。</p><p><img src="/img/tree/rotate.png"/></p><p>需要平衡的四种情况：（y为失衡节点）</p><ul><li>LL，向左子树（L）的左孩子（L）中插入新节点后导致不平衡。处理方法：右旋</li></ul><p><img src="/img/tree/ll.png"/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node y)</span></span>&#123;</span><br><span class="line">Node x = y.left;</span><br><span class="line">Node t3 = x.right;</span><br><span class="line">x.right = y;</span><br><span class="line">y.left = t3;</span><br><span class="line"><span class="comment">//更新height</span></span><br><span class="line">y.height = Math.max(getHeight(y.left),getHeight(y.right))+<span class="number">1</span>;</span><br><span class="line">x.height = Math.max(getHeight(x.left),getHeight(x.right))+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RR，向右子树（R）的右孩子（R）中插入新节点后导致不平衡。处理方法：左旋</li></ul><p><img src="/img/tree/rr.png"/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node y)</span></span>&#123;</span><br><span class="line">Node x = y.right;</span><br><span class="line">Node t2 = x.left;</span><br><span class="line">x.left = y;</span><br><span class="line">y.right = t2;</span><br><span class="line"><span class="comment">//更新height</span></span><br><span class="line">y.height = Math.max(getHeight(y.left),getHeight(y.right))+<span class="number">1</span>;</span><br><span class="line">x.height = Math.max(getHeight(x.left),getHeight(x.right))+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LR，处理方法：先左旋（变为LL情况）再右旋</li></ul><p><img src="/img/tree/lr.png"/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右情况旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">LR</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    y.left = leftRotate(y.left);</span><br><span class="line">    <span class="keyword">return</span> rightRotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RL，处理方法：先右旋（变为RR情况）再左旋</li></ul><p><img src="/img/tree/rl.png"/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右左情况旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">RL</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    y.right = rightRotate(y.right);</span><br><span class="line">    <span class="keyword">return</span> leftRotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeRebalance</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factor = root.balaceFactor;</span><br><span class="line">    <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; root.left.balaceFactor &gt; <span class="number">0</span>) <span class="keyword">return</span> rightRotate(root); <span class="comment">//LL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; root.left.balaceFactor &lt;= <span class="number">0</span>) <span class="keyword">return</span> LR(root); <span class="comment">//LR</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &lt; -<span class="number">1</span> &amp;&amp; root.right.balanceFactor &lt;= <span class="number">0</span>) <span class="keyword">return</span> leftRotate(root); <span class="comment">//RR</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &lt; -<span class="number">1</span> &amp;&amp; root.right.balanceFactor &gt; <span class="number">0</span>) <span class="keyword">return</span> RL(root); <span class="comment">//RL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root; <span class="comment">// Nothing happened.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>非旋转方法：二叉排序树 -&gt; 中序遍历得升序数组 -&gt; AVL树（leetcode 108）</p></blockquote><h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">AVL Tree Visualzation (usfca.edu)</a></p><h3 id="红黑树（RBT）"><a href="#红黑树（RBT）" class="headerlink" title="红黑树（RBT）"></a>红黑树（RBT）</h3><p>红黑树本身是一棵二叉查找树，在其基础上附加了两个要求：</p><ol><li>树中的每个结点增加了一个用于存储颜色的标志域；</li><li>树中没有一条路径比其他任何路径长出两倍，整棵树要接近于“平衡”的状态。</li></ol><blockquote><p>这里所指的路径，指的是从任何一个结点开始，一直到其子孙的叶子结点的长度；</p><p>接近于平衡：红黑树并不是平衡二叉树，只是由于对各路径的长度之差有限制，所以近似于平衡的状态。</p></blockquote><p>红黑树节点属性：父节点，子节点（两个，左子节点和右子节点），颜色，value</p><p>树上的每个节点都遵循下面的规则:</p><ul><li><p>每个节点都有红色或黑色</p></li><li><p>树的根始终是黑色的</p></li><li><p>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p></li><li><p>没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点）</p></li><li><p>从节点（包括根）到其任何后代NULL节点的每条路径都具有相同数量的黑色节点（即自平衡）</p></li></ul><p><img src="/img/tree/rbt.png"/></p><blockquote><p>注意：图中每个结点附带一个整形数值，表示的是此结点的黑高度（从该结点到其子孙结点中包含的黑结点数，用 bh(x) 表示（x 表示此结点）），nil 的黑高度为 0，颜色为黑色（在编程时为节省空间，所有的 nil 共用一个存储空间）。在计算黑高度时，也看做是一个黑结点。</p></blockquote><p>红黑树中每个结点都有各自的黑高度，整棵树也有自己的黑高度，即为根结点的黑高度，如图中的红黑树的黑高度为 3。对于一棵具有 n 个结点的红黑树，树的高度至多为：<code>2lg(n+1)</code>。</p><h4 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h4><p>对于高度为 <code>h</code> 的二叉查找树的运行时间为<code>O(h)</code>，而包含有 <code>n</code> 个结点的红黑树本身就是最高为 <code>lgn</code>（简化之后）的查找树<code>（h=lgn）</code>，所以红黑树的时间复杂度为<code>O(lgn)</code>。</p><p>红黑树，虽隶属于二叉查找树，但二叉查找树的时间复杂度会受到其树深度的影响，而红黑树可以保证在最坏情况下的时间复杂度仍为<code>O(lgn)</code>。当数据量多到一定程度时，使用红黑树比二叉查找树的效率要高。</p><p>相比于AVL树，牺牲了部分平衡性，以换取删除/插入操作时少量的旋转次数，整体来说，性能优于AVL树。</p><blockquote><p>红黑树利用了缓存，等价于2-3树。</p><p><img src="/img/tree/2-3.jpg"/></p><p>其中2-节点 等价于普通平衡二叉树的节点，<strong>3-节点 本质上是非平衡性的缓存</strong>。</p><p>要再平衡（rebalance）时，增删操作时，2-节点与3-节点的转化会吸收不平衡性,减少旋转次数,使再平衡尽快结束。在综合条件下,增删操作相当时,数据的随机性强时,3-节点的非平衡性缓冲效果越明显。因此红<br>黑树的综合性能更优。</p><p><strong>本质上是用空间换时间。</strong></p></blockquote><p>查找方法同BST树。</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>换色</strong>：即红变黑，黑变红，只需要让某个对象的属性改变</p><p><strong>旋转</strong>，分为左旋和右旋，同二叉排序树转平衡二叉树的旋转原理完全相同。</p><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><blockquote><p>红黑树在插入数据时，插入的位置肯定在底部，不可能在中间突然插入一个值。</p><p>插入的数据一定是红色的（遵守红黑树规则5，如果有一条分支增加了一个黑色节点，就会打破该规则）</p><p>插入之后，为了满足规则4，就需要用到换色与左旋、右旋的操作</p></blockquote><p>当创建一个红黑树或者向已有红黑树中插入新的数据时，执行以下 3 步：</p><ul><li><p>按照二叉查找树插入结点的方法，找到新结点插入的位置；</p></li><li><p>将新插入的结点结点初始化，颜色设置为红色后插入到指定位置；</p></li><li><p>调整二叉查找树，想办法通过旋转以及修改树中结点的颜色，使其重新成为红黑树。分为以下情况：</p><ul><li><p>插入位置为整棵树的树根。处理办法：将插入结点的颜色改为黑色。</p></li><li><p>插入位置的双亲结点的颜色为黑色。处理方法：此种情况不需要做任何工作</p></li><li><p>插入位置的双亲结点的颜色为红色。处理方法：此时需要结合其<strong>祖父结点</strong>和祖父结点的另一个孩子结点（父结点的兄弟结点，此处称“<strong>叔叔结点</strong>”）的状态，分为 3 种情况：</p><ul><li>当前结点的父节点是红色，且叔叔结点也是红色：破坏了红黑树的第 4 条性质，解决方案为：将父结点颜色改为黑色；将叔叔结点颜色改为黑色；将祖父结点颜色改为红色；下一步将祖父结点认做当前结点，继续判断，处理结果如下图所示：</li></ul><p><img src="/img/tree/insert1.png"/></p><ul><li>当前结点的父结点颜色为红色，叔叔结点颜色为黑色，且当前结点是父结点的右孩子。解决方案：将父结点作为当前结点做左旋操作，此种情况就转变成了第 3 种情况，处理过程转情况 3 </li></ul><p><img src="/img/tree/insert2.png"/></p><ul><li>当前结点的父结点颜色为红色，叔叔结点颜色为黑色，且当前结点是父结点的左孩子。解决方案：将父结点颜色改为黑色，祖父结点颜色改为红色，从祖父结点处进行右旋处理。</li></ul><p><img src="/img/tree/insert3.png"/></p></li></ul></li></ul><blockquote><p>祖宗根节点必黑，允许黑连黑，不许红连红；新增红，爸叔通红就变色，爸红叔黑就旋转，哪黑往哪旋</p></blockquote><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>需要完成 2 步操作：</p><ul><li><p>将红黑树按照BST删除结点的方法删除指定结点；</p><ul><li>若该删除结点本身是叶子结点，则直接删除，返回NULL为根节点</li><li>若只有一个孩子结点（左孩子或者右孩子），则让其孩子结点顶替该删除结点；</li><li>若有两个孩子结点，则将删除节点左孩子放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子。</li></ul></li><li><p>判断删除该结点是否会破坏红黑树的性质。判断的依据是：如果删除结点的颜色为红色，则不会破坏；如果删除结点的颜色为黑色，则破坏性质5，调整删除结点后的树，使之重新成为红黑树。调整方案分 4 种情况讨论</p><ul><li><p>删除结点的兄弟结点颜色是红色，调整措施为：将兄弟结点颜色改为黑色，父亲结点改为红色，以父亲结点来进行左旋操作，同时更新删除结点的兄弟结点（左旋后兄弟结点发生了变化），如下图所示：</p><p><img src="/img/tree/dele1.png"/></p></li><li><p>删除结点的兄弟结点及其孩子全部都是黑色的，调整措施为：将删除结点的兄弟结点设为红色，同时设置删除结点的父结点标记为新的结点，继续判断；</p><p><img src="/img/tree/dele2.png"/></p></li><li><p>删除结点的兄弟结点是黑色，其左孩子是红色，右孩子是黑色。调整措施为：将兄弟结点设为红色，兄弟结点的左孩子结点设为黑色，以兄弟结点为准进行右旋操作，最终更新删除结点的兄弟结点；</p><p><img src="/img/tree/dele3.png"/></p></li><li><p>删除结点的兄弟结点是黑色，其右孩子是红色（左孩子不管是什么颜色），调整措施为：将删除结点的父结点的颜色赋值给其兄弟结点，然后再设置父结点颜色为黑色，兄弟结点的右孩子结点为黑色，根据其父结点做左旋操作，最后设置替换删除结点的结点为根结点；</p><p><img src="/img/tree/dele4.png"/></p></li></ul></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>Java中TreeSet和TreeMap的实现，以及JDK 8以后，HashMap的设计</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;二叉树与递归有着千丝万缕的联系，二叉树在定义时就使用了递归的概念：一棵二叉树可能是空树，如果不是空树，那么它的左右子树都是二叉树。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="https://aoif-hikari.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JAVA/Servlet规范</title>
    <link href="https://aoif-hikari.github.io/2021/07/19/servlet/"/>
    <id>https://aoif-hikari.github.io/2021/07/19/servlet/</id>
    <published>2021-07-19T05:35:28.734Z</published>
    <updated>2021-07-19T05:35:28.734Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Servlet规范，来自于JAVAEE规范中的一种。</p><p>后期使用springMVC框架。</p></blockquote><span id="more"></span><p>Servlet规范指定【动态资源文件】开发步骤；Http服务器调用动态资源文件规则；Http服务器管理动态资源文件实例对象规则。</p><p>Tomcat服务器下lib文件中servlet-api.jar存放Servlet接口（javax.servlet.Servlet接口）</p><p>Servlet规范任务中，Http服务器能调用的【动态资源文件】必须是一个<strong>Servlet接口实现类</strong></p><h2 id="Servlet规范开发步骤"><a href="#Servlet规范开发步骤" class="headerlink" title="Servlet规范开发步骤"></a>Servlet规范开发步骤</h2><ul><li>创建一个Java类继承HttpServlet父类，使之成为一个Servlet接口实现类</li></ul><ul><li><p>重写两个方法，doGet或则doPost</p></li><li><p>将Servlet接口实现类信息【注册】到Tomcat服务器</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /web/WEB-INF/web.xml文件中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将Servlet接口实现类类路径地址交给Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span><span class="comment">&lt;!--声明servlet接口实现类类路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    Tomcat  String mm = &quot;com.bjpowernode.controller.OneServlet&quot;</span><br><span class="line">    <span class="comment">&lt;!--为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/one<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--设置简短请求别名,别名在书写时必须以&quot;/&quot;为开头--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期"></a>Servlet对象生命周期</h2><ul><li>网站中所有的Servlet接口实现类的实例对象，只能由Http服务器(如Tomcat，相当于servlet的容器)负责额创建。 开发人员不能手动创建。</li></ul><ul><li>在默认的情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时，自动创建这个Servlet接口实现类的实例对象；在手动配置情况下，要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--手动配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>30<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span><span class="comment">&lt;!--填写一个大于0的整数即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>在Http服务器运行期间，一个Servlet接口实现类只能被创建出一个实例对象</p></li><li><p>在Http服务器关闭时刻，自动将网站中所有的Servlet对象进行销毁</p></li></ul><h2 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h2><p>来自于Servlet规范，在Tomcat中存在servlet-api.jar，实现类由Http服务器负责提供。负责将doGet/doPost方法<strong>执行结果</strong>写入到【响应体】交给浏览器。惯于将HttpServletResponse接口修饰的对象称为【<strong>响应对象</strong>】</p><p>主要功能:</p><ul><li><p>执行结果以二进制形式写入到【响应体】</p></li><li><p>设置响应头中[content-type]属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">         String result=<span class="string">&quot;Java&lt;br/&gt;Mysql&lt;br/&gt;HTML&lt;br/&gt;&quot;</span>; <span class="comment">//既有文字信息又有HTML标签命令</span></span><br><span class="line">        <span class="comment">//设置响应头content-type</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//向Tomcat索要输出流</span></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">//通过输出流将结果写入到响应体</span></span><br><span class="line">        out.print(result);</span><br><span class="line">    &#125;<span class="comment">//doGet执行完毕，Tomcat将响应包推送给浏览器</span></span><br></pre></td></tr></table></figure><ul><li>设置响应头中【location】属性，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String result =<span class="string">&quot;http://www.baidu.com?userName=mike&quot;</span>;</span><br><span class="line">    <span class="comment">//通过响应对象，将地址赋值给响应头中location属性</span></span><br><span class="line">    response.sendRedirect(result);<span class="comment">//[响应头  location=&quot;http://www.baidu.com&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//浏览器在接收到响应包之后，如果发现响应头中存在location属性，自动通过地址栏向location指定网站发送请求。sendRedirect方法远程控制浏览器请求行为【请求地址，请求方式，请求参数】</span></span><br></pre></td></tr></table></figure><h2 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h2><p>来自于Servlet规范中，在Tomcat中存在servlet-api.jar，接口实现类由Http服务器负责提供。负责在doGet/doPost方法运行时读取Http请求协议包中信息，修饰的对象称为【请求对象】</p><p>作用:</p><ul><li>读取Http请求协议包中【请求行】信息</li><li>读取保存在Http请求协议包中【请求头】或则【请求体】中请求参数信息</li><li>代替浏览器向Http服务器申请资源文件调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象，读取【请求行】中【url】信息</span></span><br><span class="line">         String url = request.getRequestURL().toString();</span><br><span class="line">        <span class="comment">//2.通过请求对象，读取【请求行】中【method】信息</span></span><br><span class="line">         String method = request.getMethod();</span><br><span class="line">        <span class="comment">//3.通过请求对象，读取【请求行】中uri信息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * URI：资源文件精准定位地址，在请求行并没有URI这个属性。</span></span><br><span class="line"><span class="comment">        *      实际上URL中截取一个字符串，这个字符串格式&quot;/网站名/资源文件名&quot;</span></span><br><span class="line"><span class="comment">        *      URI用于让Http服务器对被访问的资源文件进行定位</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String uri =  request.getRequestURI();<span class="comment">// substring</span></span><br><span class="line">        System.out.println(<span class="string">&quot;URL &quot;</span>+url);</span><br><span class="line">        System.out.println(<span class="string">&quot;method &quot;</span>+method);</span><br><span class="line">        System.out.println(<span class="string">&quot;URI &quot;</span>+uri);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.通过请求对象获得【请求头】中【所有请求参数名】</span></span><br><span class="line">        Enumeration paramNames =request.getParameterNames(); </span><br><span class="line">        <span class="comment">//将所有请求参数名称保存到一个枚举对象进行返回</span></span><br><span class="line">        <span class="keyword">while</span>(paramNames.hasMoreElements())&#123;</span><br><span class="line">            String paramName = (String)paramNames.nextElement();</span><br><span class="line">            <span class="comment">//2.通过请求对象读取指定的请求参数的值</span></span><br><span class="line">            String value = request.getParameter(paramName);</span><br><span class="line">            System.out.println(<span class="string">&quot;请求参数名 &quot;</span>+paramName+<span class="string">&quot; 请求参数值 &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        浏览器以GET方式发送请求,请求参数保存在【请求头】,在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求头二进制内容由Tomcat负责解码，Tomcat9.0默认使用【utf-8】字符集，可以解释一切国家文字</span></span><br><span class="line"><span class="comment">浏览器以POST方式发送请求，请求参数保存在【请求体】,在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求体二进制内容由当前请求对象（request）负责解码。request默认使用[ISO-8859-1]字符集，一个东欧语系字符集，此时如果请求体参数内容是中文，将无法解码只能得到乱码</span></span><br><span class="line"><span class="comment">解决方案:在Post请求方式下，在读取请求体内容之前，应该通知请求对象使用utf-8字符集对请求体内容进行一次重新解码*/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通知请求对象，使用utf-8字符集对请求体二进制内容进行一次重写解码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//通过请求对象，读取【请求体】参数信息</span></span><br><span class="line">        String value = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;从请求体得到参数值 &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请求对象和响应对象生命周期</p><ul><li>​       在Http服务器接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】</li><li>在Http服务器调用doGet/doPost方法时，负责将【请求对象】和【响应对象】作为实参传递到方法，确保doGet/doPost正确执行</li><li>在Http服务器准备推送Http响应协议包之前，负责将本次请求关联的【请求对象】和【响应对象】<br>​      销毁</li></ul><p>【请求对象】和【响应对象】生命周期贯穿一次请求的处理过程中</p></blockquote><h2 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h2><p>由三位数字组成的一个符号。Http服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中【状态行】上。</p><p>如果Http服务器针对本次请求，返回了对应的资源文件，通过Http状态码通知浏览器应该如何处理这个结果</p><p>如果Http服务器针对本次请求，无法返回对应的资源文件，通过Http状态码向浏览器解释不能提供服务的原因</p><p>分类：<br>100—-599组成；分为5个大类<br>100; 通知浏览器本次返回的资源文件并不是一个独立的资源文件，需要浏览器在接收响应包之后，继续向Http服务器所要依赖的其他资源文件</p><p>200，通知浏览器本次返回的资源文件是一个完整独立资源文件，浏览器在接收到之后不需要所要其他关联文件</p><p>302，通知浏览器本次返回的不是一个资源文件内容而是一个资源文件地址，需要浏览器根据这个地址自动发起请求来索要这个资源文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;资源文件地址&quot;</span>) <span class="comment">//写入到响应头中location</span></span><br><span class="line"><span class="comment">//而这个行为导致Tomcat将302状态码写入到状态行</span></span><br></pre></td></tr></table></figure><p>404: 通知浏览器，由于在服务端没有定位到被访问的资源文件 因此无法提供帮助</p><p>405：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet），但是这个Servlet对于浏览器采用的请求方式不能处理</p><p>500:通知浏览器，在服务端已经定位到被访问的资源文件（Servlet）这个Servlet可以接收浏览器采用请求方式，但是Servlet在处理请求期间，由于Java异常导致处理失败</p><h2 id="多个Servlet之间调用规则"><a href="#多个Servlet之间调用规则" class="headerlink" title="多个Servlet之间调用规则"></a>多个Servlet之间调用规则</h2><p>多个Servlet:</p><ul><li>前提条件：某些来自于浏览器发送请求，往往需要服务端中多个Servlet协同处理。但是浏览器一次只能访问一个Servlet，导致用户需要手动通过浏览器发起多次请求才能得到服务。这样增加用户获得服务难度，导致用户放弃访问当前网站</li></ul><ul><li>提高用户使用感受规则：无论本次请求涉及到多少个Servlet,用户只需要【手动】通知浏览器发起一次请求即可</li></ul><h3 id="重定向解决方案"><a href="#重定向解决方案" class="headerlink" title="重定向解决方案"></a>重定向解决方案</h3><p>用户第一次通过【手动方式】通知浏览器访问OneServlet。OneServlet工作完毕后，将TwoServlet地址写入到响应头location属性中，导致Tomcat将302状态码写入到状态行。浏览器接收到响应包之后，读取到302状态。此时浏览器自动根据响应头中location属性地址【自动】发起第二次请求，访问TwoServlet去完成请求中剩余任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;请求地址&quot;</span>) <span class="comment">//将地址写入到响应包中响应头中location属性</span></span><br></pre></td></tr></table></figure><ul><li>请求地址：既可以把当前网站内部的资源文件地址发送给浏览器 （/网站名/资源文件名）也可以把其他网站资源文件地址发送给浏览器(<a href="http://ip地址:端口号/网站名/资源文件名">http://ip地址:端口号/网站名/资源文件名</a>)</li><li>请求次数：浏览器至少发送两次请求，只有第一次请求是用户手动发送。后续请求都是浏览器自动发送的。</li><li>请求方式：通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】</li><li>缺点:重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间</li></ul><h3 id="请求转发解决方案"><a href="#请求转发解决方案" class="headerlink" title="请求转发解决方案"></a>请求转发解决方案</h3><p> 用户第一次通过手动方式要求浏览器访问OneServlet。OneServlet工作完毕后，通过当前的请求对象代替浏览器向Tomcat发送请求，申请调用TwoServlet。Tomcat接收到这个请求之后，自动调用TwoServlet完成剩余任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求对象代替浏览器向Tomcat发送请求</span></span><br><span class="line"><span class="comment">//1.通过当前请求对象生成资源文件申请报告对象</span></span><br><span class="line">RequestDispatcher  report = request.getRequestDispatcher(<span class="string">&quot;/资源文件名&quot;</span>); <span class="comment">//一定要以&quot;/&quot;为开头</span></span><br><span class="line"><span class="comment">//2.将报告对象发送给Tomcat</span></span><br><span class="line">report.forward(request, response)</span><br></pre></td></tr></table></figure><ul><li>无论本次请求涉及到多少个Servlet,用户只需要手动通过浏览器发送一次请求</li></ul><ul><li>Servlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数增加处理服务速度</li></ul><p>请求次数：在请求转发过程中，浏览器只发送一次请求</p><p>请求地址：只能向Tomcat服务器申请调用当前网站下资源文件地址</p><p>请求方式：在请求转发过程中，浏览器只发送一个了个Http请求协议包。参与本次请求的所有Servlet共享同一个请求协议包，因此这些Servlet接收的请求方式与浏览器发送的请求方式保持一致</p><h2 id="多个Servlet之间数据共享实现方案"><a href="#多个Servlet之间数据共享实现方案" class="headerlink" title="多个Servlet之间数据共享实现方案"></a>多个Servlet之间数据共享实现方案</h2><p>数据共享：OneServlet工作完毕后，将产生数据交给TwoServlet来使用</p><p>Servlet规范中提供四种数据共享方案</p><h3 id="ServletContext接口"><a href="#ServletContext接口" class="headerlink" title="ServletContext接口"></a>ServletContext接口</h3><p>来自于Servlet规范中一个接口。在Tomcat中存在servlet-api.jar，在Tomcat中负责提供这个接口实现类。</p><p>如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享。</p><p>习惯于将ServletContext对象称为【全局作用域对象】。</p><blockquote><p>每一个网站都存在一个全局作用域对象。 这个全局作用域对象【相当于】一个Map.在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中其他Servlet此时都可以从全局作用域对象得到这个数据进行使用。</p><p>生命周期：全局作用域对象生命周期贯穿网站整个运行期间</p></blockquote><p>在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象</p><p>在Http服务器运行期间时，一个网站只有一个全局作用域对象，全局作用域对象一直处于存活状态</p><p>在Http服务器准备关闭时，负责将当前网站中全局作用域对象 进行销毁处理          </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令实现： 【同一个网站】OneServlet将数据共享给TwoServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象向Tomcat索要当前网站全局作用域对象</span></span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="comment">//2.将数据添加到全局作用域对象，作为共享数据</span></span><br><span class="line">        application.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="number">100</span>);<span class="comment">// map: key-value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过请求对象向Tomcat索要当前网站全局作用域对象</span></span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="comment">//2.从全局作用域对象得到指定关键字对应的值</span></span><br><span class="line">        Integer money=(Integer)application.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cookie类"><a href="#Cookie类" class="headerlink" title="Cookie类"></a>Cookie类</h3><p>来自于Servlet规范中一个工具类，存在于Tomcat提供servlet-api.jar中。如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于Cookie对象进行数据共享</p><p>Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量。在现实生活场景中，Cookie相当于用户在服务端得到【会员卡】</p><p>原理: 用户通过浏览器第一次向MyWeb网站发送请求申请OneServlet。OneServlet在运行期间创建一个Cookie存储与当前用户相关数据。OneServlet工作完毕后，【<strong>将Cookie写入到响应头</strong>】交还给当前浏览器。浏览器收到响应响应包之后，将cookie存储在浏览器的缓存一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时。【<strong>浏览器需要无条件的将myWeb网站之前推送过来的Cookie，写入到请求头</strong>】发送过去。此时TwoServlet在运行时，可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现命令:  同一个网站 OneServlet 与  TwoServlet 借助于Cookie实现数据共享</span></span><br><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个cookie对象，保存共享数据（当前用户数据）</span></span><br><span class="line">        Cookie card = <span class="keyword">new</span> Cookie(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;abc&quot;</span>);<span class="comment">// Cookie(String name,String value)</span></span><br><span class="line">        Cookie card1= <span class="keyword">new</span> Cookie(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;efg&quot;</span>);</span><br><span class="line"><span class="comment">//cookie相当于一个map,一个cookie中只能存放一个键值对</span></span><br><span class="line">        <span class="comment">//这个键值对的key与value只能是String,键值对中key不能是中文</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.【发卡】将cookie写入到响应头，交给浏览器</span></span><br><span class="line">        resp.addCookie(card);</span><br><span class="line">        resp.addCookie(card1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TwoServlet&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象从请求头得到浏览器返回的Cookie</span></span><br><span class="line">        Cookie  cookieArray[] = request.getCookies();</span><br><span class="line">        <span class="comment">//2.循环遍历数据得到每一个cookie的key 与 value</span></span><br><span class="line">        <span class="keyword">for</span>(Cookie card:cookieArray)&#123;</span><br><span class="line">            String key =   card.getName(); <span class="comment">//读取key  &quot;key1&quot;</span></span><br><span class="line">            String value = card.getValue();<span class="comment">//读取value &quot;abc&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Cookie销毁时机</p></blockquote><p>在默认情况下，Cookie对象存放在浏览器的缓存中。只要浏览器关闭，Cookie对象就被销毁</p><p>在手动设置情况下，可以要求浏览器将接收的Cookie 存放在客户端计算机上硬盘上，同时需要指定Cookie在硬盘上存活时间。在存活时间范围内，关闭浏览器关闭客户端计算机，关闭服务器，都不会导致Cookie被销毁。在存活时间到达时，Cookie自动从硬盘上被删除</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cookie</span>.setMaxAge(<span class="number">60</span>); //cookie在硬盘上存活<span class="number">1</span>分钟</span><br></pre></td></tr></table></figure><p>Cookie域保存在自己浏览器内部，与别人互不干扰，但因为是客户端技术，所以安全性不高。</p><h3 id="HttpSession接口"><a href="#HttpSession接口" class="headerlink" title="HttpSession接口"></a>HttpSession接口</h3><p>来自于Servlet规范下一个接口。存在于Tomcat中servlet-api.jar，其实现类由Http服务器提供。Tomcat提供实现类存在于servlet-api.jar。如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于HttpSession对象进行数据共享。习惯于将HttpSession接口修饰对象称为【会话作用域对象】</p><blockquote><p>HttpSession 与  Cookie 区别：</p><p>存储位置:Cookie：存放在客户端计算机（浏览器内存/硬盘）。HttpSession：存放在服务端计算机内存</p><p>数据类型：Cookie对象存储共享数据类型只能是String。HttpSession对象可以存储任意类型的共享数据Object</p><p>数据数量: 一个Cookie对象只能存储一个共享数据。HttpSession使用map集合，可以存储任意数量共享数据</p><p>参照物：Cookie相当于客户在服务端【会员卡】。HttpSession相当于客户在服务端【私人保险柜】</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令实现:   同一个网站（myWeb）下OneServlet将数据传递给TwoServlet</span></span><br><span class="line">OneServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//2.将数据添加到用户私人储物柜</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;key1&quot;</span>,共享数据)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浏览器访问/myWeb中TwoServlet</span></span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//2.从会话作用域对象得到OneServlet提供的共享数据</span></span><br><span class="line">        Object 共享数据 = session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Http服务器如何将用户与HttpSession关联：cookie</p><blockquote><p>getSession()  与  getSession(false)</p><p>getSession(): 如果当前用户在服务端已经拥有了自己的私人储物。要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。要求tocmat为当前用户创建一个全新的私人储物柜</p><p>getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜.要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。此时Tomcat将返回null</p></blockquote><p>HttpSession销毁时机:</p><p>用户与HttpSession关联时使用的Cookie只能存放在浏览器缓存中，在浏览器关闭时，意味着用户与他的HttpSession关系被切断。由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会让Tomcat将浏览器关联的HttpSession进行销毁。为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】，空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟，此时Tomcat认为用户已经放弃了自己的HttpSession，Tomcat就会销毁这个HttpSession</p><h3 id="HttpServletRequest接口-1"><a href="#HttpServletRequest接口-1" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h3><p>在同一个网站中，如果两个Servlet之间通过【请求转发】方式进行调用，彼此之间共享同一个请求协议包。而一个请求协议包只对应一个请求对象。因此servlet之间共享同一个请求对象，此时可以利用这个<strong>请求对象</strong>在两个Servlet之间实现数据共享。</p><p>将请求对象称为【请求作用域对象】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OneServlet通过请求转发申请调用TwoServlet时，需要给TwoServlet提供共享数据</span></span><br><span class="line">OneServlet&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.将数据添加到【请求作用域对象】中attribute属性</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;key1&quot;</span>,数据); <span class="comment">//数据类型可以任意类型Object</span></span><br><span class="line">        <span class="comment">//2.向Tomcat申请调用TwoServlet</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/two&quot;</span>).forward(req,response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TwoServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从当前请求对象得到OneServlet写入到共享数据</span></span><br><span class="line">        Object 数据 = req.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听器接口"><a href="#监听器接口" class="headerlink" title="监听器接口"></a>监听器接口</h2><p>一组来自于Servlet规范下接口，共有8个接口。在Tomcat存在servlet-api.jar包。监听器接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类。监听器接口用于监控【<strong>作用域对象</strong>生命周期变化时刻】以及【作用域对象共享数据变化时刻】</p><blockquote><p>作用域对象：在Servlet规范中，认为在<strong>服务端内存</strong>中可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】</p><p>Servlet规范下作用域对象:</p><ul><li>ServletContext：全局作用域对象</li><li>HttpSession:  会话作用域对象</li><li>HttpServletRequest: 请求作用域对象</li></ul><p>(cookie存放在客户端，故不属于作用域对象)</p></blockquote><p>监听器接口实现类开发规范：根据监听的实际情况，选择对应监听器接口进行实现；重写监听器接口声明【监听事件处理方法】；在web.xml文件将监听器接口实现类注册到Http服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将监听器接口实现类注册到Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.bjpoewrnode.listener.OneListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>ServletContextListener接口</li></ul><p>合法的检测全局作用域对象被初始化时刻以及被销毁时刻</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitlized</span><span class="params">(ServletContextEvent sce)</span><span class="comment">//在全局作用域对象被Http服务器初始化被调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestory</span><span class="params">(ServletContextEvent sce)</span><span class="comment">//在全局作用域对象被Http服务器销毁时触发调用</span></span></span><br></pre></td></tr></table></figure><ul><li>ServletContextAttributeListener接口</li></ul><p>合法的检测全局作用域对象共享数据变化时刻</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextAdd</span><span class="params">()</span> <span class="comment">//在全局作用域对象添加共享数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextReplaced</span><span class="params">()</span> <span class="comment">//在全局作用域对象更新共享数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextRemove</span><span class="params">()</span> <span class="comment">//在全局作用域对象删除共享数据</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域对象共享数据变化时刻</span></span><br><span class="line">ServletContext application = request.getServletContext();</span><br><span class="line">application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="number">100</span>); <span class="comment">//新增共享数据</span></span><br><span class="line">application.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="number">200</span>); <span class="comment">//更新共享数据</span></span><br><span class="line">application.removeAttribute(<span class="string">&quot;key1&quot;</span>);  <span class="comment">//删除共享数据</span></span><br></pre></td></tr></table></figure><h2 id="过滤器接口"><a href="#过滤器接口" class="headerlink" title="过滤器接口"></a>过滤器接口</h2><p>来自于Servlet规范下接口，在Tomcat中存在于servlet-api.jar包。Filter接口实现类由开发人员负责提供，Http服务器不负责提供。Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截。</p><blockquote><p>拦截Http服务器，帮助Http服务器检测当前请求合法性；对当前请求进行增强操作</p></blockquote><p>Filter接口实现类开发步骤：创建一个Java类实现Filter接口；重写Filter接口中doFilter方法；web.xml将过滤器接口实现类注册到Http服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//合法请求</span></span><br><span class="line">        <span class="comment">//将拦截请求对象和响应对象交还给Tomcat,由Tomcat继续调用资源文件</span></span><br><span class="line">        <span class="keyword">if</span>(...)&#123; </span><br><span class="line">        <span class="comment">//增强功能，通知拦截的请求对象，使用UTF-8字符集对当前请求体信息进行一次重新编辑(POST())</span></span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);<span class="comment">//FilterChain的doFilter方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则过滤器代替Http服务器拒绝本次请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--将过滤器类文件路径交给Tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>oneFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.bjpowernode.filter.OneFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通知Tomcat在调用何种资源文件时需要被当前过滤器拦截--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>oneFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>拦截地址<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用某一个具体文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/mm.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用某一个文件夹下所有的资源文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用任意文件夹下某种类型文件之前，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要求Tomcat在调用网站中任意文件时，来调用OneFilter拦截---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用过滤器避免恶意登录（避开登陆界面直接通过地址栏访问网站内资源文件）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用Dao将查询验证信息推送到数据库服务器上</span></span><br><span class="line">        result = dao.login(userName, password);</span><br><span class="line">        <span class="keyword">if</span>(result ==<span class="number">1</span>)&#123;<span class="comment">//用户存在</span></span><br><span class="line">            <span class="comment">//在判定来访用户身份合法后，通过请求对象向Tomcat申请为当前用户申请一个HttpSession令牌</span></span><br><span class="line">            HttpSession session = request.getSession();</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myWeb/index.html&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/myWeb/login_error.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)servletRequest;</span><br><span class="line">        <span class="comment">// 与login相关的不过滤</span></span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        <span class="keyword">if</span>(uri.indexOf(<span class="string">&quot;login&quot;</span>) != -<span class="number">1</span> || <span class="string">&quot;/myWeb/&quot;</span>.equals(uri))&#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.拦截后，通过请求对象向Tomcat索要当前用户的HttpSession。</span></span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//getSession(false):如果当前用户在服务端已经拥有了自己的私人储物柜.要求tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜。此时Tomcat将返回null</span></span><br><span class="line">        <span class="comment">//2.判断来访用户身份合法性</span></span><br><span class="line">        <span class="keyword">if</span>(session == <span class="keyword">null</span>)&#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/login_error.html&quot;</span>)</span><br><span class="line">                .forward(servletRequest, servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通知Tomcat在调用任意文件之前都要调用当前过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Servlet规范，来自于JAVAEE规范中的一种。&lt;/p&gt;
&lt;p&gt;后期使用springMVC框架。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://aoif-hikari.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>图与网络/贪心算法</title>
    <link href="https://aoif-hikari.github.io/2021/07/12/%E8%B4%AA%E5%BF%83/"/>
    <id>https://aoif-hikari.github.io/2021/07/12/%E8%B4%AA%E5%BF%83/</id>
    <published>2021-07-12T11:14:36.923Z</published>
    <updated>2021-07-16T08:56:06.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>贪心算法在对问题求解时，总是做出在当前看来是最好的选择。</p></blockquote><span id="more"></span><h2 id="最小生成树问题-Minimum-spanning-trees-MST"><a href="#最小生成树问题-Minimum-spanning-trees-MST" class="headerlink" title="最小生成树问题(Minimum spanning trees,MST)"></a>最小生成树问题(Minimum spanning trees,MST)</h2><blockquote><p><strong>生成树</strong>：指一个连通子图，它含有图中全部$n$个顶点，但只有足以构成一棵树的$n-1$条边。</p><p><strong>最小生成树</strong>：在所有生成树中，所有边的权重和最小的生成树。</p><p>假设有一个连通的无向的图$G=(V,E)$，及权值函数$w: E\rightarrow R$。考虑贪婪的方法找出$MST$。</p></blockquote><p>这个贪心策略由下面的“一般型”算法延伸，该算法<strong>每次只增长最小生成树的一条边</strong>。</p><p>该算法管理边集$A$，$A$不断加$1$条边，需要做$n-1$次循环。在每次迭代之前，$A$是最小生成树的子集。在每一步，我们确定可以添加到$A$的边${u,v}$，在不违背这个不变式的情况下，$A\cup \{u，v\}$还是最小生成树的一个子集。</p><p>称这样的边为A的安全边（$safe\  edge$），因为它可以在保持不变的情况下添加到$A$。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">GENERIC-MST</span>(G,w)</span><br><span class="line"><span class="selector-tag">A</span> ← ?</span><br><span class="line"><span class="selector-tag">while</span> <span class="selector-tag">A</span> <span class="selector-tag">does</span> <span class="selector-tag">not</span> <span class="selector-tag">form</span> <span class="selector-tag">a</span> <span class="selector-tag">spanning</span> <span class="selector-tag">tree</span></span><br><span class="line">    <span class="selector-tag">do</span> <span class="selector-tag">find</span> <span class="selector-tag">an</span> <span class="selector-tag">edge</span> <span class="selector-tag">e</span> <span class="selector-tag">that</span> <span class="selector-tag">is</span> <span class="selector-tag">safe</span> <span class="selector-tag">for</span> <span class="selector-tag">A</span></span><br><span class="line">        <span class="selector-tag">A</span> ← <span class="selector-tag">A</span> ∪ <span class="selector-tag">e</span></span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>如何找到安全的边？</strong></p></blockquote><p><strong>定义</strong>: 无向图$G=(V,E)$的一个$cut(S,V-S)$是$V$的一个$cut$。</p><p>如果一条在$E$中的边$(u, v)$它的一个端点在$S$中，另一个端点在$V-S$中，我们说这条边穿过这个$cut(S,V-S)$</p><p>如果$A$中的边没有与该$cut$相交，则该$cut\ respects\ A$的边。</p><p>如果边的权值是任何边穿过$cut$的最小值，则边就是穿过$cut$的轻边($light\ edge$)。注意，可以有更多轻边，那么选择其中一条即可。</p><p>简单来说，就是$A∪safe\ edge$就是最小生成树的子集，$A$中的点没有穿过$cut$，再在$cut$中找到轻边作为安全边，得到新的$A$，然后再找到新的$cut$，满足$A$没有穿过$cut$，循环此过程，直至找到$n-1$条边。</p><blockquote><p>定理：设$G=(V,E)$是连通的具有权重$w$的无向图，令$A$是$E$的子集，包含在$G$的最小生成树中。设$(S, V-S)$为任意$cut(respect\ A)$，设$(u,v)$为穿过$(S, V-S)$的轻边。那么$(u,v)$是$A$的安全边。</p></blockquote><p><strong>证明</strong>:</p><p>设$T$是一个最小生成树，包含$A$。</p><ul><li><p>若$T$包含轻边$(u,v)$，则$A\cup \{u，v\} \in T$,</p></li><li><p>若$T$不包含轻边$(u,v)$，构造另一棵最小生成树$T’$，对于当前生成树$T，u，v$之间没有直接的边相连，但可以通过路径$p$连通，按图中将$G$分割为$cut$两部分，使得$u， v$在$cut$不同的点集，那么必然存在这样 的$x，y$也被划分在$cut$两部分，边$(u,v)(x,y)$都穿过该$cut$，$(u,v)$是轻边，连接$(u,v)$，断开$(x,y)$，得到新的生成树$T’$，$T’=T-(x,y)\cup (u,v)$。因为$(u,v)$是一个轻边，$w(u,v)\leq w(x,y)$。因此,$w (T’) = w (T) - w (x, y) + w (u, v) \leq w (T)$。由于$T$是最小生成树，所以$T’$也必须是最小生成树。</p></li></ul><p><strong>Kruskal , Prim使用特定的规则来确定安全边。</strong></p><ul><li><strong>kruaskal算法</strong>找到安全边的方法是，在所有连接森林中两颗不同树的边里面，找到权重最小的边$(u,v)$。</li></ul><div align="center">    <img src="/img/greedy/2.jpg"/></div><ul><li><strong>Prim算法</strong>所具有的一个性质是集合$A$中边总是构成一棵树。这颗树从一个任意的根节点r开始，一直长大到覆盖$V$中的所有结点时为止。算法每一步在连接集合$A$和$A$之外的节点所有边中，选择一条轻边加入到$A$中。</li></ul><div align="center">    <img src="/img/greedy/3.jpg"/></div><h2 id="最大独立集-Maximum-independent-set"><a href="#最大独立集-Maximum-independent-set" class="headerlink" title="最大独立集(Maximum independent set)"></a>最大独立集(Maximum independent set)</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Greedy independent <span class="keyword">set</span></span><br><span class="line"><span class="keyword">input</span> Graph G=(V,E);</span><br><span class="line">output independent <span class="keyword">set</span> V<span class="string">&#x27; in G;</span></span><br><span class="line"><span class="string">begin</span></span><br><span class="line"><span class="string">    V&#x27;</span>:=ф</span><br><span class="line">    U:=V</span><br><span class="line">    <span class="keyword">while</span> U <span class="keyword">is</span> <span class="keyword">not</span> empty <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        x: vertex <span class="keyword">of</span> minimum degree <span class="keyword">in</span> graph induced <span class="keyword">by</span> U</span><br><span class="line">        V<span class="string">&#x27;:=V&#x27;</span>U(x);</span><br><span class="line">        eliminate x <span class="keyword">and</span> <span class="keyword">all</span> its neighbors <span class="keyword">from</span> U</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> V<span class="string">&#x27;</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><blockquote><p>贪心算法找不到最大独立集的例子：</p><div align="center">    <img src="/img/greedy/1.png"/></div><p>贪心结果：${a, e}$</p><p>实际结果：${b, c, d}$</p></blockquote><p>可以看出，随着左部和中部图中点数的增加，贪心所得到的解与最优值可以相差任意远。可以使用图的密度函数判断贪心算法的表现。</p><blockquote><p>定理：假设图$G$有$n$个点和$m$条边，记$\delta =\frac{m}{n}$为图G的密度。贪心算法求得的解$m_{Gr}(G)\geq \frac{n}{(2\delta +1)}$</p></blockquote><p><strong>证明：</strong></p><p>设$x_i$为程序while循环第$i$次迭代时选定的顶点，$d_i$为$x_i$的度。</p><p>该算法将$x_i$及其所有$d_i$邻居从$G$中删除。第$i$步删除$d_{i+1}$个点，得到</p><script type="math/tex; mode=display">\sum_{i=1}^{m_{Gr}(G)}(d_i+1)=n.........(1)</script><p>又因为删除点的同时会删除边，那么与$x_i$相连的$d_i$个点至少度是$d_i$，那么删除的边有$(d_i+1)d_i$，又$d_i$个点之间可能存在互相连接的情况，那么删除的边至少有$(di+1)di/2$，删除的边数一定小于总边数，得</p><script type="math/tex; mode=display">\sum_{i=1}^{m_{Gr}(G)}(d_i+1)\frac{d_i}{2}\leq m=\delta n..........(2)</script><p>$(2)*2+(1)$得</p><script type="math/tex; mode=display">\sum_{i=1}^{m_{Gr}(G)}(d_i+1)^2\leq n(2\delta +1)</script><p>利用柯西斯瓦格不等式，对于所有的$i$，当$d_i+1=\frac{n}{m_{Gr}(G)}$时，不等式的左边取得极小值。</p><script type="math/tex; mode=display">n(2\delta +1)\geq \sum_{i=1}^{m_{Gr}(G)}(d_i+1)^2\geq \frac{n^2}{m_{Gr}(G)}</script><p>得证。</p><p>下面的定理提供了最优解与贪婪算法求得的解之间的关系。</p><blockquote><p>定理：有$n$个顶点和$m$的图$G$，设$\delta =\frac{m}{n}$。可以找到一个独立的集合$m_{Gr}(G)$，令最优解$\frac{m^*(G)}{m_{Gr}(G)}\leq (\delta +1)$</p></blockquote><p><strong>证明</strong>:</p><p>本证明与前一证明相似。在本例中，确定一个最大的独立集合${V^<em>}$，令$k_i$为在第$i$次循环中所删除$d_{i+1}$个顶点并在${V^</em>}$中的顶点数。显然</p><script type="math/tex; mode=display">\sum_{i=1}^{m_{Gr}(G)}k_i=|V^*|=m^*(G)............(3)</script><p>由于贪心算法选择的顶点最小度，删除的顶点的度的和至少是$d_i(d_i+1)$。</p><p>因为一条边的两个端点不可能都在$V^<em>$</em>中，*它这样删除边的数目至少为$\frac{(d_i(d_i+1)+k_i(k_i-1))}{2}$，这里可以修改$(2)$，得</p><script type="math/tex; mode=display">\sum_{i=1}^{m_{Gr}(G)}\frac{d_i(d_i+1+ki(k_i-1))}{2}\leq \delta n...........(4)</script><p>$(2)+(3)+2*(4)$得</p><script type="math/tex; mode=display">\sum_{i=1}^{m_{Gr}(G)}((d_i+1)^2+k_i^2)\leq n(2\delta +1)+m^*(G)</script><p>应用$C-S$不等式，当$d_i+1=\frac{n}{m_{Gr}(G)}\ and\ k_i=\frac{m^*(G)}{m_{Gr}(G)}$，上述不等式左边最小，因此</p><script type="math/tex; mode=display">n(2\delta +1)+m^*(G)\geq \sum_{i=1}^{m_{Gr}(G)}((d_i+1)^2+k_i^2)\geq \frac{n^2+m^*(G)^2}{m_{Gr}(G)}</script><p>即</p><script type="math/tex; mode=display">m_{Gr}(G)\geq m^*(G)\frac{\frac{n}{m^*(G)}+\frac{m^*(G)}{n}}{2\delta +1+\frac{m^*(G)}{n}}</script><p>当$m^*(G)=n$时，不等式最小。把这一项代入，定理成立。</p><h2 id="背包问题-Greedy-knapsack"><a href="#背包问题-Greedy-knapsack" class="headerlink" title="背包问题(Greedy knapsack)"></a>背包问题(Greedy knapsack)</h2><p>输入:集合$X$的$n$个元素，对于$X$中的每个$x_i$，价值$p_i$，重量$w_i$，正整数$b$；</p><p>输出:子集$Y\in X$使得$\sum_{x_i\in Y}w_i\leq b,max\ {\sum_{x_i\in Y}} p_i$</p><p>按$\frac{p_i}{w_i}$的规则进行贪心选择。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    sort X <span class="keyword">in</span> non-increasing <span class="keyword">order</span> <span class="keyword">with</span> respect <span class="keyword">to</span> the ratio pi/wi;</span><br><span class="line">    Y:=<span class="keyword">empty</span> <span class="keyword">set</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> b&gt;=wi <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        Y=YU<span class="comment">&#123;xi&#125;</span></span><br><span class="line">        b=b-wi</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    return Y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>找不到最优解的例子：</p><p>令$p_i=w_i=1，i=1,2，..，n-1, p_n=b-1, w_n=b=k_n$，其中$k$是一个任意大的数。</p><p>在这种情况下，最优解$m^*(x)=b-1$;而贪心算法找到的解的值为$n-1$。因此</p><script type="math/tex; mode=display">\frac{m^*(x)}{m_{Gr}(x)} > k</script><p>贪心算法的劣势是由于算法没有将价值最高的元素包含在解中，而最优的元素正是价值最高的。这表明一个简单的修改贪心的程序有更好的性能。</p><blockquote><p>定理：给定一个背包的实例$x$，令$m_H(x)=max(P_{max}，m_{Gr}(x))$，其中$P_{max}$是$x$中一个项目的最大价值，$m_H(x)$满足以下不等式:$\frac{m^*(x)}{m_H(x)}&lt; 2$。</p></blockquote><p><strong>证明</strong>：设$j$为根据贪心选择第一个装不进背包物品的下标，此时背包转装入的物品价值为</p><script type="math/tex; mode=display">\overline{p_j}=\sum_{i=1}^{j-1}\leq m_{Gr}(x)</script><p>重量为</p><script type="math/tex; mode=display">\overline{w_j}=\sum_{i=1}^{j-1}w_i\leq b</script><p>首先证明任何最优解必须满足以下条件不等式:</p><p>$m^*(x)&lt;\overline{p_j}+p_j$，</p><p>因为装入前j-1个物品后，容量还剩余$b-\overline{w_j}&lt; w_j$，贪心选择在装入$j-1$个物品后，无法装入$j$，其密度为$\frac{p_j}{w_j}$，那么如果剩余容量按最优的去放，$(b-\overline{w_j})\frac{p_j}{w_j}&lt;w_j\frac{p_j}{w_j}=p_j$</p><p>如果$p_j&lt;\overline{p_j}$，那么$m^*(x)&lt;2\overline{p_j}\leq 2m_{Gr}(x)\leq 2m_H(x)$；</p><p>如果$p_j&gt;\overline{p_j}$，那么$P_{max}&gt;\overline{P_j}$，有$m^*(x)\leq \overline{p_j}+p_j\leq 2{p_j}\leq 2P{max}\leq 2m_H(x)$</p><h2 id="The-Stein-Lovasz-Theorem"><a href="#The-Stein-Lovasz-Theorem" class="headerlink" title="The Stein-Lovasz Theorem"></a>The Stein-Lovasz Theorem</h2><blockquote><p>The stein-lovasz Theorem 理论最基本的模型是解决集合的元素覆盖问题。使用贪心算法，以获得一个使用最少列元完成最大行覆盖的方案。</p><p>假设$(0,1)$矩阵$A$的大小是$N×M$ ,矩阵$A$的特征是每行至少具有$v$个$1$，每列最多$a$个$1$。假设现在从其中抽取一个子矩阵$C⊂A$,大小是$N×K$，使得子矩阵的每行元素都不是全零行，证明$K$存在一个上界，<br>$K≤\frac{N}{a}+(\frac{M}{v})lna≤(\frac{M}{v})(1+lna)$</p><p>分析：能不能使用一种抽取列数尽可能少的方案，如果使用的列数目比给定的边界条件$\frac{N}{a}+(\frac{M}{v})lna$小，那么原来的问题就自然获得证明。</p></blockquote><p><strong>贪心算法思路描述如下</strong></p><ol><li>初始化矩阵$(0,1)$矩阵$A$，每列的$1$权重值$c_i∈\{1,2,3,……,a\}$,然后按照列权重按照 $a,a-1,a-2,…,1$ 执行降序排序，此时的矩阵命名为$A_a$;</li><li>从最左边权重最高为$a$的第一列开始，删除这一列，并且这列对应的$1$所在相应的$a$个行也统一删掉。在删除$1$列和$a$行后的矩阵$A$，重新划定权重，继续寻找左边最高权重为$a$的列，继续删除。在删除$2$列和$2∗a$行后的矩阵$A$，重新划定权重，继续寻找左边最高权重为$a$的列，继续删除。重复$K_a$次后，把最高权重为$a$的列及对应的$a∗K_a$行都删掉了，此时的矩阵变成了$A_{a−1}$;</li><li>以矩阵$A_{a−1}$开始，从左边权重最高为$a-1$的第一列开始，删除这一列，并且这列所对应的$a−1$行也统一删掉。删完后，重新划定权重，继续寻找左边最高权重为$a-1$的列，继续删除。重复$K_{a−1}$次后，把最高权重为$a-1$的列及其对应的$(a−1)∗K_{a−1}$行都删掉了，此时的矩阵变成了$A_{a−2}$.</li><li>重复步骤3，删除权重为$a-2,a-3,…,1$的列，直到矩阵$A_1$变成了空。<br>将之前删除的所有列元集中起来重新组合成$N×K$矩阵，$K=\sum_{i=1}^a K_i$</li></ol><p><strong>证明</strong>：</p><p>假设$A_a=A_{N*M}$表示由$a$个1且每列的1互不重合的列组成的矩阵</p><p>$A_{a-1}’$表示由a-1个1且每列的1互不重合的列组成的矩阵。$|A_a’|=K_a$，那么删除覆盖的$K_a\cdot a$行得到新的矩阵$A_{a-1}=A_{(N-aK_a)\times (M-K_a)}$，那么每一列至多有$a-1$个$1$，</p><p>$|A_{a-1}’|=K_{a-1}$，那么删除覆盖的$K_{a-1}\cdot (a-1)$行得到新的矩阵$A_{a-2}$。</p><p>以此类推，$A_{i-1}$，每行至少$v$个1，每列至多$i-1$个$1$，那么有$N-aK_a-(a-1)K_{a-1}-…-iK_i$行，记为$k_i$行，有$M-K_a-…-K_i$列。</p><p>$k_a=N-aK_a$，即$K_a=\frac{N-k_a}{a}$，令$N=k_{a+1}$，则$K_a=\frac{k_{a+1}-k_a}{a}$，以此类推得到</p><script type="math/tex; mode=display">K_i=\frac{k_{i+1}-k_i}{i}</script><script type="math/tex; mode=display">\sum_{i=1}^{a}K_i=\sum_{i=1}^{a}\frac{k_{i+1}-k}{i}=\frac{k_{a+1}}{a}-\frac{k_a}{a}+\frac{k_a}{a-1}-\frac{k_{a-1}}{a-1} +...+\frac{k_2}{1}=\frac{N}{a}+\frac{k_a}{a(a-1)}+\frac{k_{a-1}}{(a-1)(a-2)}+...+\frac{k_2}{2\times 1}</script><p>使用双计数，分别对行和列进行计数，对于$A_{i-1}$，每一行至少$v$个1，而每列至多$i-1$个$1$，可得对$1$进行行计数不会超过进行列计数，即</p><script type="math/tex; mode=display">k_i\times v\leq (M-K_a-...-K_i)\times (i-1)\leq M\times (i-1) \frac{k_i}{i-1}\leq \frac{M}{v}</script><p>那么</p><script type="math/tex; mode=display">\sum_{i=1}^{a}K_i\leq \frac{N}{a}+\frac{1}{a}\frac{M}{v}+\frac{1}{a-1}\frac{M}{v}+...+\frac{1}{2}\frac{M}{v}=\frac{N}{a}+\frac{M}{v}(\frac{1}{a}+\frac{1}{a-1}+...+\frac{1}{2})\leq \frac{N}{a}+\frac{M}{v}lna\leq \frac{M}{v}+\frac{M}{v}lna=\frac{M}{v}(1+lna)​</script><h3 id="应用1：完美哈希族函数（Perfect-Hash-Function）"><a href="#应用1：完美哈希族函数（Perfect-Hash-Function）" class="headerlink" title="应用1：完美哈希族函数（Perfect Hash Function）"></a>应用1：完美哈希族函数（Perfect Hash Function）</h3><blockquote><p>$(n,m,w)$-完美哈希族是一个函数F集合，使得$|Y|=n$， $|X|=m$,</p><p>$f:Y\rightarrow X$对于$F$中的每一个$f$，对于任何$C\subseteq \{1,2,…,n\}$使得$|C|=w$，$C$是$Y$的$w$元子集合，并且至少存在一个$F$中的$f$使得$f|C$是一一对应的。如果$|F|=N$那么完美哈希族可以记作$PHF(N;n,m,w)$。</p><p>求满足条件的函数数目的一个上界。</p></blockquote><div align="center">    <img src="/img/greedy/3.png"/></div><p>$|F|=N$，如上图，假设$w=3$，那么任选$Y$中的三列，有$\binom{n}{3}$种选择，要求其中存在一行使得三个函数值各不同，例如取$1，2，3$列，$f_{11}$，$f_{12}$，$f_{13}$互不相同就满足要求一一映射。</p><p>$f:Y\rightarrow X$，$n$个$Y$对应到$m$个$X$，每一个$Y$有$m$种选择，那么有$m^n$个函数。从中挑出最少的函数(即N越小越好)使得对于任何的$C$可以满足一一对应要求。</p><ul><li>套用ST定理：</li></ul><p>$N:\binom{n}{w}$，从$M:m^n$个函数中挑选出最少的函数满足要求，那么得到的矩阵就是$NxM$的$(0,1)$矩阵$A$，$A_{ij}=1$的含义就是当$|w|=i$，$f_j$是可以满足一一映射要求的。</p><p>$v:\binom{m}{w}w!\cdot m^{n-w}$，表示从$m$个值中选取$w$的值排列放入选择的$w$个，剩余未赋值的$n-w$个，就任意赋值。</p><p>$a:\binom{n}{w}$，每一个函数至多覆盖$a$个。</p><p>套用S-T定理得</p><script type="math/tex; mode=display">N\leq \frac{m}{w!\binom{m}{w}}(1+log\binom{n}{w})</script><ul><li>使用概率方法:</li></ul><p>从$m^n$个函数中随机选择$N$个函数出来，构造一张随机的函数表，考虑坏概率，在函数表中没有一个函数可以使$w$存在一一映射关系，对于一个函数坏概率为存在一一对应关系的对立事件，取出$N$个函数，得</p><script type="math/tex; mode=display">(1-\frac{\binom{m}{w}w!m^(n-w)}{m^n})^N\binom{n}{w}</script><p>使其小于1，那么一定存在完美哈希族。(两边取对数求解)</p><h3 id="应用2：分割系统-Splitting-Systems"><a href="#应用2：分割系统-Splitting-Systems" class="headerlink" title="应用2：分割系统(Splitting Systems)"></a>应用2：分割系统(Splitting Systems)</h3><p><strong>在某个域中，$\alpha ^n=\beta$，$\alpha ,\beta$已知且为离散的，那么如何求解$n$？</strong></p><p><strong>分割系统的提出就是为了解决离散对数问题。</strong></p><blockquote><p>假设$n,t$为偶数，$X$是点集合,$B$是超边集合。</p><p>a) $|X|=n$,$B$是$X$的$\frac{n}{2}$子集的集合，称为区组</p><p>b)对于每一个$Y\subseteq X$中存在区组$B$，使得$|B\cap Y|=\frac{t}{2}$。</p><p>取最少$N$个$B$使得上面的条件满足。</p></blockquote><ul><li>使用S-T定理</li></ul><p>$N:\binom{n}{t}$，对所有的t元子集合进行分割;</p><p>$M:\binom{n}{\frac{n}{2} }$，完成的方法总数;</p><p>接下来确定$v$，那么对于某一行有多少$\frac{n}{2}$元子集合可以分割$t_i$，$t$个位置中一半放$1$，剩余一半放$0$，问题是一个$n$元集合，此时还剩$n-t$个位置没有放数，且还缺少$\frac{n-t}{2}$个1，那么得到子集合个数$\binom{t}{ \frac{t}{2} }\cdot \binom{n-t}{\frac{n-t}{2}}$；</p><p>确定$a$，对于固定的$\frac{n}{2}$元子集合可以分割多少$t$，$\binom{\frac{n}{2}}{\frac{t}{2}}\binom{\frac{n}{2}}{\frac{t}{2}}$，套用S-T定理，</p><script type="math/tex; mode=display">N\leq \frac{\binom{n}{\frac{n}{2}}}{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}(1+2ln\binom{\frac{n}{2}}{\frac{t}{2}})</script><div align="center">    <img src="/img/greedy/2.png"/></div><ul><li>使用概率方法：</li></ul><p>定义$A_i$，第$i$个$t$元子集合未被分割。对于一个$t$元集合没有分割的概率是分割时间的对立事件，为</p><script type="math/tex; mode=display">1-\frac{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}{\binom{n}{\frac{n}{2}}}</script><p>共有$N$个$\frac{n}{2} $元子集合未被分割，为</p><script type="math/tex; mode=display">(1-\frac{\binom{t}{\frac{t}{2}}\binom{n-t}{\frac{n-t}{2}}}{\binom{n}{\frac{n}{2} }})^N=P(A_i)</script><p>那么至少有一个$t$元集合未被分割的概率为</p><script type="math/tex; mode=display">P(\cup A_i)\leq \sum P(A_i)=\binom{n}{t}P(A_i)<1</script><p>令其小于$1$，那么没有未被分割的情况概率大于$0$。</p><p>参考：<a href="https://www.codenong.com/cs106200371/">图论学习笔记五贪心算法 | 码农家园 (codenong.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;贪心算法在对问题求解时，总是做出在当前看来是最好的选择。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="图与网络" scheme="https://aoif-hikari.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JAVA/代理模式</title>
    <link href="https://aoif-hikari.github.io/2021/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://aoif-hikari.github.io/2021/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2021-07-09T02:02:53.501Z</published>
    <updated>2021-07-16T08:45:53.689Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>代理模式的一个典型应用：AOP(面向切面编程)</p></blockquote><span id="more"></span><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>a类本来需要调用c类（目标类）的方法完成某个功能， 但是c不让a调用。 </p><p>a —&gt;不能直接调用 c的方法。<br>在a 和 c 直接创建一个 b 代理，c让b访问。 c，b实现相同的功能（接口）。<br>a —&gt;访问b—&gt;访问c</p><p>作用：</p><ul><li><p>功能增强： 在原有的功能上，增加了额外的功能。 新增加的功能，叫做功能增强</p></li><li><p>控制访问： 代理类不让你访问目标，例如商家不让用户访问厂家。 </p></li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>代理类需要手工实现。即自己创建一个java类，表示代理类。所要代理的目标类是确定的。</p><ul><li>缺点：当目标类和代理类很多时候，<ul><li>当目标类增加， 代理类可能也需要成倍的增加。 代理类数量过多。</li><li>当接口中功能增加或修改，会影响众多的实现类，厂家类，代理类都需要修改。影响较大。</li></ul></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在程序执行过程中，使用jdk的<strong>反射</strong>机制，创建<strong>代理类对象</strong>， 并动态的指定要代理目标类。</p><p>即使目标类很多，代理类数量可以很少；当修改了接口中的方法时，不影响代理类。</p><p>动态代理是一种创建java对象的能力，不用创建代理类，就能创建代理类对象。</p><p>两种实现方式：jdk动态代理；cglib动态代理</p><h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><ul><li>使用java反射包中的类和接口实现动态代理的功能。</li><li>反射包 java.lang.reflect , 里面有三个类 ： InvocationHandler , Method, Proxy.</li><li>要求目标类实现接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用反射调用方法</span></span><br><span class="line">HelloService service = <span class="keyword">new</span> HelloServiceImpl(); <span class="comment">//创建类对象service</span></span><br><span class="line">service.sayHello(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 通过对象调用sayHello()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反射调用方法</span></span><br><span class="line">Method method =  HelloService.class.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class); <span class="comment">// 获取method对象（sayHello()方法）</span></span><br><span class="line">HelloService service2 = <span class="keyword">new</span> HelloServiceImpl2();</span><br><span class="line">Object ret = method.invoke(service2, <span class="string">&quot;李四&quot;</span>); <span class="comment">// invoke()方法调用对象service2的方法</span></span><br></pre></td></tr></table></figure><ul><li>InvocationHandler接口，只有一个方法invoke()，代理对象要完成的功能。（目标方法/功能增强）</li><li>Method类：表示目标类中的方法。通过Method可以执行某个目标类的方法，method.invoke(目标对象，方法的参数)</li><li>Proxy类：创建代理对象。之前创建对象是 new ，现在使用Proxy类的静态方法 newProxyInstance() 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现InvocationHandler接口，完成代理类要做的功能（1.调用目标方法，2.功能增强）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySellHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>; <span class="comment">// 为目标类创建对象（活动的，不是固定的，需要传入进来）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySellHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 实现invoke方法，完成代理类要做的功能</span></span><br><span class="line">    <span class="comment">// Object proxy: jdk创建的代理对象，无需赋值。</span></span><br><span class="line"><span class="comment">// Method method: 目标类中的方法，jdk提供</span></span><br><span class="line">    <span class="comment">// Object[] args：目标类中方法的参数， jdk提供。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object res  = <span class="keyword">null</span>;</span><br><span class="line">        res =  method.invoke(target,args); <span class="comment">// 反射，执行目标对象target的method方法</span></span><br><span class="line"><span class="comment">//功能增强，加价</span></span><br><span class="line">        <span class="keyword">if</span>( res != <span class="keyword">null</span> )&#123;</span><br><span class="line">            Float price = (Float)res;</span><br><span class="line">            price = price + <span class="number">25</span>;</span><br><span class="line">            res = price;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建代理对象，使用Proxy</span></span><br><span class="line"><span class="comment">//1. 创建目标对象</span></span><br><span class="line">UsbSell factory = <span class="keyword">new</span> UsbKingFactory();</span><br><span class="line"><span class="comment">//2.创建InvocationHandler对象</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MySellHandler(factory);</span><br><span class="line"><span class="comment">//3.创建代理对象</span></span><br><span class="line">UsbSell proxy = (UsbSell) Proxy.newProxyInstance(</span><br><span class="line">    factory.getClass().getClassLoader(),</span><br><span class="line">    factory.getClass().getInterfaces(),</span><br><span class="line">    handler</span><br><span class="line">);</span><br><span class="line"><span class="comment">//4.通过代理执行方法</span></span><br><span class="line"><span class="keyword">float</span> price = proxy.sell(<span class="number">1</span>); <span class="comment">// 代理对象proxy调用目标类factory中的sell方法</span></span><br></pre></td></tr></table></figure><h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><ul><li><p>cglib是第三方的工具库， 创建代理对象。</p></li><li><p>原理是继承， cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法， 实现功能的修改。要求目标类不能是final的， 方法也不能是final的。</p></li><li><p>cglib的要求目标类比较宽松， 只要能继承即可。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;代理模式的一个典型应用：AOP(面向切面编程)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://aoif-hikari.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>hexo配置</title>
    <link href="https://aoif-hikari.github.io/2021/07/07/hexo/"/>
    <id>https://aoif-hikari.github.io/2021/07/07/hexo/</id>
    <published>2021-07-07T11:46:00.000Z</published>
    <updated>2021-07-16T08:55:28.555Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>hexo，快速、简洁且高效的博客框架</p></blockquote><span id="more"></span><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="regexp">//</span> 清除缓存</span><br><span class="line">hexo g <span class="regexp">//</span> 创建静态文件</span><br><span class="line">hexo s <span class="regexp">//</span> 本地运行</span><br><span class="line">hexo d <span class="regexp">//</span> 部署到远程</span><br></pre></td></tr></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>主题文件夹放在<code>./theme/</code> 下，<code>_config.yml</code> 中<code>theme:</code> 改成主题文件夹名</p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>文章存放路径<code>/source/_posts/*.md</code></p><ul><li>文章头部</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="string">/8/3</span> <span class="number">18</span><span class="string">:20:00</span> <span class="string">//发布时间</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">hexo</span> <span class="string">//分类</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span> <span class="string">//使用mathjax渲染公式</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">hexo博客</span> <span class="string">//标题</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><ul><li>文章折叠</li></ul><p>需要折叠的部分之前加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>公式</li></ul><p>卸载原有公式渲染引擎 <code>npm uninstall hexo-renderer-marked --save</code> </p><p>安装kramed <code>npm install hexo-renderer-kramed --save</code></p><blockquote><p>问题1：kramed对<code>\,&#123;,&#125;</code>有转义，无法正常显示</p><p>解决方法：</p><p>定位到博客根目录，找到<code>/node_modules/kramed/lib/rules/inline.js</code>文件，进行部分修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,      第11行，将其修改为</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    第20行，将其修改为</span></span><br><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p>问题2：公式中以下符号会解析错误<code>&#123;&#123;` `&#125;&#125;</code> <code>&#123;%` `%&#125;</code></p><p>解决方法：中间加空格，变为<code>&#123; &#123;</code> <code>&#125; &#125;</code> <code>&#123; %</code> <code>% &#125;</code></p></blockquote><ul><li>图片居中(md支持html语法)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/img/...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="多分支管理"><a href="#多分支管理" class="headerlink" title="多分支管理"></a>多分支管理</h2><p>同时管理了两个分支：</p><ul><li>master -负责展示静态网页</li><li>hexo -备份本地hexo文件（默认分支）</li></ul><p>执行<code>hexo d</code>时，自动更新master分支（config文件中deploy配置）</p><p>add, commit, pull更新hexo分支需要备份的源文件</p><h2 id="中文目录无法跳转"><a href="#中文目录无法跳转" class="headerlink" title="中文目录无法跳转"></a>中文目录无法跳转</h2><p><a href="https://github.com/theme-next/hexo-theme-next/pull/1540/files">fix: Chinese TOC cannot jump by jiangtj · Pull Request #1540 · theme-next/hexo-theme-next (github.com)</a></p><p>解决方法：在 <code>themes/next/source/js/util.js</code> 中增加两行代码，删除两行代码。保存后<code>hexo clean &amp; hexo g &amp; hexo s</code> 即可解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> navItems = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.post-toc li&#x27;</span>);</span><br><span class="line">   <span class="keyword">const</span> sections = [...navItems].map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> link = element.querySelector(<span class="string">&#x27;a.nav-link&#x27;</span>);</span><br><span class="line">     <span class="comment">//增加该行</span></span><br><span class="line">     <span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(<span class="built_in">decodeURI</span>(link.getAttribute(<span class="string">&#x27;href&#x27;</span>)).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">     <span class="comment">// TOC item animation navigate.</span></span><br><span class="line">     link.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">       event.preventDefault();</span><br><span class="line">       <span class="comment">//删除该行</span></span><br><span class="line">       <span class="comment">//var target = document.getElementById(event.currentTarget.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">       <span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">       <span class="built_in">window</span>.anime(&#123;</span><br><span class="line">         <span class="attr">targets</span>  : <span class="built_in">document</span>.scrollingElement,</span><br><span class="line">         <span class="attr">duration</span> : <span class="number">500</span>,</span><br><span class="line">         <span class="attr">easing</span>   : <span class="string">&#x27;linear&#x27;</span>,</span><br><span class="line">         <span class="attr">scrollTop</span>: offset + <span class="number">10</span></span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">// 删除该行 </span></span><br><span class="line">     <span class="comment">//return document.getElementById(link.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">     <span class="comment">// 增加该行</span></span><br><span class="line">     <span class="keyword">return</span> target;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>无法解决的问题尝试清除缓存<code>hexo clean</code>后重新生成</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;hexo，快速、简洁且高效的博客框架&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="https://aoif-hikari.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>JAVA/JDBC</title>
    <link href="https://aoif-hikari.github.io/2021/07/07/jdbc/"/>
    <id>https://aoif-hikari.github.io/2021/07/07/jdbc/</id>
    <published>2021-07-07T09:39:41.156Z</published>
    <updated>2021-07-16T08:45:27.092Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java DataBase Connectivity, Java连接数据库，是SUN公司制定的一套接口, java.sql.*;</p><p>后期将集成到Mybatis框架中。</p></blockquote><span id="more"></span><p>从官网下载对应的驱动jar包，将其配置到环境变量classpath。</p><p>classpath=.;D:\course\06-JDBC\resources\MySql Connector Java 5.1.23\mysql-connector-java-5.1.23-bin.jar</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 1、注册驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();<span class="comment">//多态，父类型引用指向子类型对象</span></span><br><span class="line">        DriverManager.registerDriver(driver); <span class="comment">//静态方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册驱动的另一种方法</span></span><br><span class="line">        <span class="comment">//Class.forName(driver);</span></span><br><span class="line">        <span class="comment">//不用接受返回值，只想用类加载这个操作，执行静态代码块完成注册驱动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取连接</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">url包括哪几部分:协议，IP，Port，资源名</span></span><br><span class="line"><span class="comment">eg：http://180.101.49.11:80/index.html</span></span><br><span class="line"><span class="comment">http:// 通信协议; 180.101.49.11 IP地址; 80 端口号; index.html 资源名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mydatabase&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;146&quot;</span>;</span><br><span class="line">        <span class="comment">// static Connection getConnection(String url, String user, String password)</span></span><br><span class="line">        conn = DriverManager.getConnection(url,user,password); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;数据库连接对象&quot; + conn);</span></span><br><span class="line">        <span class="comment">//数据库连接对象com.mysql.jdbc.JDBC4Connection@1ae369b7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、获取数据库操作对象</span></span><br><span class="line">        <span class="comment">// Statement createStatement() 创建一个 Statement 对象来将 SQL 语句发送到数据库。</span></span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、执行sql语句</span></span><br><span class="line">        <span class="comment">// int executeUpdate(String sql) </span></span><br><span class="line">        <span class="comment">// 专门执行DML语句,返回值是“影响数据库中的记录条数”</span></span><br><span class="line">        <span class="comment">// 这里的sql语句不用;</span></span><br><span class="line">        <span class="keyword">int</span> count = stmt.executeUpdate(<span class="string">&quot;update dept set dname = &#x27;销售部&#x27;,</span></span><br><span class="line"><span class="string">                                       loc = &#x27;合肥&#x27; where deptno = 20;&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(count == 1 ? &quot;保存成功&quot;:&quot;保存失败&quot;);</span></span><br><span class="line"><span class="comment">// 5、处理查询结果集</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6、释放资源, 从小到大依次关闭</span></span><br><span class="line">            <span class="comment">// 释放Statement</span></span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放Connection</span></span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理返回结果"><a href="#处理返回结果" class="headerlink" title="处理返回结果"></a>处理返回结果</h2><p>executeUpdate：insert/update/delete, 返回结果对表文件操作时，受影响行数</p><p>executeQuery：查询命令【select  *  from 表名】，返回结果是查询命令得到【临时表】，ResultSet实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="comment">//rs = stmt.executeQuery(&quot;select empno,ename,sal from emp&quot;);</span></span><br><span class="line"><span class="comment">//遍历查询到的结果</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="comment">//按顺序取</span></span><br><span class="line">    String empno = rs.getString(<span class="number">1</span>);</span><br><span class="line">    String ename = rs.getString(<span class="number">2</span>);</span><br><span class="line">    String sal = rs.getString(<span class="number">3</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + sal);</span><br><span class="line"><span class="comment">//按名称取出</span></span><br><span class="line">    String empno = rs.getString(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">    String ename = rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">    String sal = rs.getString(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + sal);</span><br><span class="line"><span class="comment">//类型+顺序</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String ename = rs.getString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="number">3</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + (sal + <span class="number">100</span>));</span><br><span class="line"><span class="comment">//类型+名称</span></span><br><span class="line">    <span class="keyword">int</span> empno = rs.getInt(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">    String ename = rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">    <span class="keyword">double</span> sal = rs.getDouble(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">    System.out.println(empno + <span class="string">&quot;,&quot;</span> + ename + <span class="string">&quot;,&quot;</span> + (sal + <span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用动态资源绑定器传参"><a href="#使用动态资源绑定器传参" class="headerlink" title="使用动态资源绑定器传参"></a>使用动态资源绑定器传参</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle bundle = ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>); <span class="comment">//.properties后缀不用写</span></span><br><span class="line">String driver = bundle.getString(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">String url = bundle.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String user = bundle.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password = bundle.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">conn = DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mydatabase</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">146</span></span><br></pre></td></tr></table></figure><h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><p>问题：用户输入语句含有sql语句关键字，完成了sql语句的拼接，参与编译，导致原sql语句含义被扭曲。</p><p>解决方法：用户提供的信息不参与编译过程，用java.sql.PreparedStatement（继承java.sql.Statement）</p><ul><li>PreparedStatement属于预编译的数据库操作对象，原理：预先对sql语句的框架进行编译，再给sql语句传“值”，使用较多。</li><li>PreparedStatement效率高。只用预编译一次，可执行多次。在编译阶段做安全检查（ps.setString()）Statement执行一次编译一次</li><li>要求支持sql语句拼接时使用Statement。（如升/降序是在语句末尾拼接asc/desc）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用PreparedStatement模拟登录，防止sql注入现象</span></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Statement stat = null;</span></span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1、注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">// 2、获取连接</span></span><br><span class="line">    conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;146&quot;</span>);</span><br><span class="line">    <span class="comment">// 3、获取预编译的数据库操作对象</span></span><br><span class="line">    <span class="comment">// sql语句的框架中，一个?，表示一个占位符，一个?将来接收一个值。注意：?不用单引号括起来</span></span><br><span class="line">    String sql = <span class="string">&quot;select * from t_user where userName = ? and userPassword = ?&quot;</span>;</span><br><span class="line">    <span class="comment">// 程序执行到此处，会发送sql语句框架给DBMS，DBMS对sql语句框架进行预编译。</span></span><br><span class="line">    ps = conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 给占位符?传值，第一个?的下标是1，第二个?的下标是2（JDBC中下标都从1开始）</span></span><br><span class="line">    ps.setString(<span class="number">1</span>,userLoginInfo.get(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">    ps.setString(<span class="number">2</span>,userLoginInfo.get(<span class="string">&quot;userPassword&quot;</span>));</span><br><span class="line">    <span class="comment">// 4、执行sql语句</span></span><br><span class="line">    rs = ps.executeQuery();</span><br><span class="line">    <span class="comment">// 5、处理结果集</span></span><br><span class="line">    <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">        loginSuccess = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 6、释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升降序排列时需要sql注入</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入desc或者asc&quot;</span>);</span><br><span class="line">String keyWords = s.nextLine();</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">    conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;146&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//createStatement可以完成拼接</span></span><br><span class="line">    stmt = conn.createStatement();</span><br><span class="line">    String sql = <span class="string">&quot;select ename from emp order by ename &quot;</span> + keyWords;</span><br><span class="line">    rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">        System.out.println(rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDBC事务自动提交"><a href="#JDBC事务自动提交" class="headerlink" title="JDBC事务自动提交"></a>JDBC事务自动提交</h2><p>即执行任一条DML语句，则自动提交一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//conn.setAutoCommit(false); // 开启事务</span></span><br><span class="line"><span class="comment">//conn.commit(); // 提交事务</span></span><br><span class="line"><span class="comment">//conn.rollback(); // 回滚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        conn = DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>,</span><br><span class="line">            <span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="string">&quot;146&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------将自动提交改为手动提交------------------------------</span></span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// 开启事务</span></span><br><span class="line">        <span class="comment">//-----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取预编译的数据库操作对象</span></span><br><span class="line">        String sql = <span class="string">&quot;update t_act set balance = ? where actno = ? &quot;</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        ps.setInt(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">        ps.setDouble(<span class="number">2</span>,<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行sql语句</span></span><br><span class="line">        <span class="keyword">int</span> count = ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String s = null;</span></span><br><span class="line"><span class="comment">            s.toString();</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        ps.setInt(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line">        ps.setDouble(<span class="number">2</span>,<span class="number">222</span>);</span><br><span class="line">        count += ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        System.out.println(count == <span class="number">2</span> ? <span class="string">&quot;转账成功&quot;</span> : <span class="string">&quot;转账失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -----------程序能执行到此处，说明没有异常，事务结束，手动提交数据----------------------</span></span><br><span class="line">        conn.commit(); <span class="comment">// 提交事务</span></span><br><span class="line">        <span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// --------遇到异常，回滚-------------------</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback(); <span class="comment">// 回滚</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//-----------------------------------------</span></span><br><span class="line">    &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>行级锁（悲观锁）:for update 当前事务结束之前，行结果被锁住，无法修改。事务排队进行，不允许并发<br>乐观锁：多线程并发，事务不需要排队，都可以修改，需要版本号。</p><h2 id="DAO与Entity"><a href="#DAO与Entity" class="headerlink" title="DAO与Entity"></a>DAO与Entity</h2><p>DAO(Data Access Object) 数据访问对象，将数据库操作都封装起来。包括：</p><p>1）实体类Dept：用于存放与传输对象数据。</p><p>2）数据库连接和关闭工具类JdbcUtil： 避免了数据库连接和关闭代码的重复使用，方便修改。</p><p>3）DAO 实现类DeptDao： 针对不同数据库给出DAO接口定义方法的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实体类（一张表对应一个实体，用于描述表结构，一个实例对象对应表中一个数据行，属性与表中字段保持一致）</span></span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.entity;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deptNo;</span><br><span class="line">    <span class="keyword">private</span> String  dname;</span><br><span class="line">    <span class="keyword">private</span> String  loc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDeptNo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> deptNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeptNo</span><span class="params">(Integer deptNo)</span> </span>&#123;<span class="keyword">this</span>.deptNo = deptNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDname</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> dname;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDname</span><span class="params">(String dname)</span> </span>&#123;<span class="keyword">this</span>.dname = dname;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoc</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> loc;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoc</span><span class="params">(String loc)</span> </span>&#123;<span class="keyword">this</span>.loc = loc;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dept</span><span class="params">(Integer deptNo, String dname, String loc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deptNo = deptNo;</span><br><span class="line">        <span class="keyword">this</span>.dname = dname;</span><br><span class="line">        <span class="keyword">this</span>.loc = loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据库连接和关闭工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Connection con = <span class="keyword">null</span>;<span class="comment">//类文件属性，可以在类文件中所有的方法中使用</span></span><br><span class="line">    <span class="keyword">private</span>  PreparedStatement ps=<span class="keyword">null</span>;<span class="comment">//类文件属性，可以在类文件中所有的方法中使用</span></span><br><span class="line">    <span class="comment">//静态语句块 static&#123;&#125;</span></span><br><span class="line">    <span class="comment">//在当前类文件第一次被加载到JVM时，JVM将会自动调用当前类文件静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//1.注册数据库服务器提供的Driver接口实现类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装Connection对象创建细节 不需要考虑使用对象创建细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Connection  <span class="title">createCon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection对象创建失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象创建细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createStatement</span><span class="params">(String sql)</span></span>&#123;</span><br><span class="line">        Connection con = createCon();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = con.prepareStatement(sql);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象与Connection对象销毁细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ps!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装PreparedStatement对象与Connection对象与ResultSet对象销毁细节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DAO接口实现（命名为表名+Dao，实现CRUD功能）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  JdbcUtil util = <span class="keyword">new</span> JdbcUtil();</span><br><span class="line">    <span class="comment">//添加数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(String deptNo,String dname,String loc)</span></span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;insert into dept (deptNo,dname,loc) values(?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setInt(<span class="number">1</span>, Integer.valueOf(deptNo));</span><br><span class="line">            ps.setString(<span class="number">2</span>, dname);</span><br><span class="line">            ps.setString(<span class="number">3</span>, loc);</span><br><span class="line">            result=ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String deptNo)</span></span>&#123;</span><br><span class="line">        String sql =<span class="string">&quot;delete from dept where deptno=?&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setInt(<span class="number">1</span>, Integer.valueOf(deptNo));</span><br><span class="line">            result = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String deptNo,String dname,String loc)</span></span>&#123;</span><br><span class="line">        String  sql =<span class="string">&quot;update dept set dname=?,loc=? where deptno=?&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps.setString(<span class="number">1</span>, dname);</span><br><span class="line">            ps.setString(<span class="number">2</span>, loc);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, Integer.valueOf(deptNo));</span><br><span class="line">            result = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           util.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql =<span class="string">&quot;select * from dept&quot;</span>;</span><br><span class="line">        PreparedStatement ps = util.createStatement(sql);</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">//将是临时表数据行转换为实体类实例对象保管</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">int</span> deptNo = rs.getInt(<span class="string">&quot;deptno&quot;</span>);</span><br><span class="line">                String dname = rs.getString(<span class="string">&quot;dname&quot;</span>);</span><br><span class="line">                String loc = rs.getString(<span class="string">&quot;loc&quot;</span>);</span><br><span class="line">                Dept dept = <span class="keyword">new</span> Dept(deptNo, dname, loc);</span><br><span class="line">                list.add(dept);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            util.close(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java DataBase Connectivity, Java连接数据库，是SUN公司制定的一套接口, java.sql.*;&lt;/p&gt;
&lt;p&gt;后期将集成到Mybatis框架中。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://aoif-hikari.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode/链表</title>
    <link href="https://aoif-hikari.github.io/2021/07/07/Leetcode-%E9%93%BE%E8%A1%A8/"/>
    <id>https://aoif-hikari.github.io/2021/07/07/Leetcode-%E9%93%BE%E8%A1%A8/</id>
    <published>2021-07-07T08:14:25.468Z</published>
    <updated>2021-07-22T03:03:35.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>常用数据结构—链表</p></blockquote><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">// 设预指针pre的下一个节点指向head，防止空节点</span></span><br><span class="line">ListNode pre = <span class="keyword">new</span> ListNode(); </span><br><span class="line">pre.next = head;</span><br><span class="line"><span class="comment">// 设置动态当前指针cur</span></span><br><span class="line">ListNode cur = head; </span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>707 设计链表</p><p>剑指 Offer 06. 从尾到头打印链表（栈）</p><ul><li>删</li></ul><p>剑指 Offer 18. 删除链表的节点</p><p>83 删除排序链表中的重复元素(相同节点保留一个)</p><p><strong>82 删除排序链表中的重复元素 II(相同节点全部删除)</strong></p><ul><li>翻转</li></ul><p>24 两两交换链表中的结点</p><p>206/剑指 Offer 24. 反转链表</p><p>92 反转链表 II</p><p>25 k个一组翻转链表</p><ul><li>合并</li></ul><p>21/ 剑指 Offer 25 合并两个有序链表</p><p>23 合并K个升序链表</p><p>2 两数相加</p><p>445 两数相加 II（栈）</p><ul><li>快慢指针</li></ul><p>19/剑指 Offer 22 删除链表的倒数第 N 个结点</p><p>61 旋转链表</p><p>876 链表的中间结点</p><p>234 回文链表(中点+反转)</p><p>143 重排链表(中点+反转+合并)</p><ul><li>拆分</li></ul><p>86 分隔链表</p><p>328 奇偶链表</p><p><strong>138/剑指 Offer 35. 复杂链表的复制</strong>（hashmap）</p><ul><li>其他</li></ul><p><strong>160/剑指 Offer 52. 两个链表的第一个公共节点</strong></p><blockquote><ul><li><p><strong>集合set</strong></p></li><li><p><strong>快慢指针（先统计两个链表的长度，如果长度不一样，让链表长的先走，直到两个链表长度一样，这此时两个链表同时每次后移一步，看节点是否一样）</strong></p></li><li><p><strong>双指针</strong></p></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;常用数据结构—链表&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="https://aoif-hikari.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>图与网络/双计数</title>
    <link href="https://aoif-hikari.github.io/2021/07/06/%E5%8F%8C%E8%AE%A1%E6%95%B0/"/>
    <id>https://aoif-hikari.github.io/2021/07/06/%E5%8F%8C%E8%AE%A1%E6%95%B0/</id>
    <published>2021-07-06T10:38:00.000Z</published>
    <updated>2021-07-19T05:35:28.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>双计数狭义上讲，对于一个集合运用两种不同的方式（行 / 列），得到等式结果或者不等式的结果。</p></blockquote><span id="more"></span><h2 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a>握手定理</h2><blockquote><p>对于图$G=(V, E)$，有</p><script type="math/tex; mode=display">\sum_{v\in V}d(v) = 2|E|</script></blockquote><p>证明：对图G的邻接矩阵中1的个数分别从行（左），列（右）进行计数。即对二元组$\{(v,e)|v\in e\}$进行计数。</p><blockquote><p>推论：图中奇度点数目为偶数。</p><p>超图握手定理：对于超图$G=(V, B)$</p></blockquote><script type="math/tex; mode=display">\sum_{v\in V}d(v) = \sum_{\beta\in B}|\beta|</script><h2 id="完全图边的双计数"><a href="#完全图边的双计数" class="headerlink" title="完全图边的双计数"></a>完全图边的双计数</h2><script type="math/tex; mode=display">\sum_{i=1}^S{n_i} = n</script><script type="math/tex; mode=display">{n\choose 2} = \sum_{i = 1}^S {n_i \choose 2}+\sum_{i<j}n_in_j</script><p>对于一个完全图，共有$n\choose 2$条边；</p><p>将完全图划分为$S$部分，每部分有$n_i$个点，${n_i \choose 2}$条边；</p><p>每部分之间有$n_in_j$条边。</p><h2 id="等式证明"><a href="#等式证明" class="headerlink" title="等式证明"></a>等式证明</h2><script type="math/tex; mode=display">{n\choose k } = \frac{n}{k}{n-1 \choose k-1}</script><p>证明：设$A$为$k$元子集，对二元组$\{(x,A)|x\in A, |A| = k\}$进行计数。</p><script type="math/tex; mode=display">\sum_{k = 1}^n k{n\choose k} = n \sum_{k = 1}^n { {n-1}\choose {k-1} } = n2^{n-1}</script><p>证明：设$A$为$k$元子集，$k=1,2,…,n$，对二元组$\{(x,A)|x\in A, |A| = k\}$进行计数。</p><script type="math/tex; mode=display">{n \choose k}{k \choose l} = {n \choose l} { {n-1}\choose {k-l} }</script><p>证明：设$A$为$l$元子集，$B$为$k$元子集，对二元组$\{(A,B)||A|=l,|B|=k,A\subseteq B\}$进行计数。</p><h2 id="Turan-Number"><a href="#Turan-Number" class="headerlink" title="Turan Number"></a>Turan Number</h2><script type="math/tex; mode=display">T(n,k,l)\geq \frac{n\choose l}{k \choose l}</script><blockquote><p>图兰数$T(n,k,l) (l\leq k \leq n)$是$n$元集合$X$的$l$元子集的最小值(下界)，使得$X$的每个$k$元子集至少包含一个这样的l元子集。</p></blockquote><p>证明：设$F$为满足条件的l元子集，记$F=\{A_1，A_2，…\}$，此时可用关联矩阵表示，$A_i$为满足条件的$l$元集合，$B_i$为$ k$元子集，若$A_i$在$B_i$上，则为$1$，就可以得到一个$0-1$矩阵。对矩阵中$1$的个数计数。</p><p>行计数：对于某一个$l$元集合，有$\binom{n-l}{k-l}]$个$k$元集合包含它，共有$|F|$个，行计数$1$的个数为$|F|\binom{n-l}{k-l}$</p><p>列计数：每个$B_i$必包含一个$A_i$，则每一列至少有一个$1$，可以得到$|F|\binom{n-l}{k-l} \geq {n\choose k}$</p><h2 id="Zarankiewicz’s-problem"><a href="#Zarankiewicz’s-problem" class="headerlink" title="Zarankiewicz’s problem"></a>Zarankiewicz’s problem</h2><blockquote><p>对于一个$n\times n$的$0-1$矩阵，如果不存在$a\times a$的全$1$子矩阵，那么这个$nxn$的矩阵最多有多少个1？</p><p>等价于：用二部图重新表述这个问题。一个部分大小为$n$的二部图$G=(V_1,V_2,E)$，其中$V_1,V_2$是顶点的不相交$n$元集合，$E\in V_1\times V_2$是边的集合。令$K_a(n)$为最小整数$k$边，使得任意大小为$n$且边数大于k的二部图至少包含一个$a\times a-clique$。对于任意的自然数$n$和$a$，</p></blockquote><script type="math/tex; mode=display">K_a(n) \leq (a-1)^{\frac{1}{a} }n^{2-\frac{1}{a} }+(a-1)n</script><p>对$S= \{(x,A)|x\in V_1,A \in V_2,|A|=a,且x与A中所有点都有边相连\}$计数, 即对下图中的结构进行计数。</p><div align="center">    <img src="/img/0607-1.png" style="zoom:33%;"></div><p>固定$x$：从与$x$相连的元素中取$A$，设$x$的neighbor为$d(x)$，那么A有$\sum_{x\in V_1}\binom{d(x)}{a}$种选法，且$|S|=\sum_{x\in V_1}\binom{d(x)}{a}$</p><p>固定$A$：从$n$中选出$a$元集合，与之对应相连的$x$最多有$(a-1)$个，否则就会出现$a\times a-clique$，即$|S| \leq \binom{n}{a}(a-1)$</p><p>即$\sum_{x\in V_1}\binom{d(x)}{a}\leq \binom{n}{a}(a-1)$</p><blockquote><p>Jensen不等式，对凸函数有：</p><script type="math/tex; mode=display">s.t.\sum_{i=1}^n\lambda_i = 1</script><script type="math/tex; mode=display">\sum_{i=1}^n\lambda_if(x_i)\geq f(\sum_{i=1}^n\lambda_ix_i),</script><p>Jensen不等式可由数学归纳法证明，略。</p></blockquote><p>令$f(x)=\binom{x}{a}$,$x_i=d(x_i)$;</p><p>根据Jensen不等式，有</p><p>$\frac{1}{n}\sum_{x\in V_1}\binom{d(x)}{a}\geq \binom{\frac{1}{n}\sum_{x\in V_1}d(x)}{a}$</p><p>$\sum_{x\in V_1}\binom{d(x)}{a}\geq n\binom{\frac{1}{n}\sum_{x\in V_1}d(x)}{a}=n\binom{\frac{|E|}{n} }{a}$(因为为二部图，则degree为一倍边数)</p><p>即$n\binom{\frac{|E|}{n} }{a}\leq \binom{n}{a}(a-1)$</p><p>经过放缩有$n(\frac{|E|}{n}-(a-1))^a&lt;\frac{n(|E|/n)(|E|/n-1)…(|E|/n-(a-1))}{a!}=n\binom{\frac{|E|}{n} }{a}$</p><p>$\binom{n}{a}(a-1)=\frac{n(n-1)…(n-(a-1))}{a!}(a-1)&lt;\frac{n^a}{a!}(a-1)$，两边同时开a次方即可解。</p><ul><li>$K_a(n)$的下界可以用概率方法求得</li></ul><h2 id="H-free图"><a href="#H-free图" class="headerlink" title="H-free图"></a>H-free图</h2><blockquote><p>一个有$n$个顶点的无$H$图可以最多有多少条边?</p><p>定理：如果图$G=(V，E)$中不包含4个点的圈, 即$C_4-free$，那么有$|E|\leq \left \lfloor n/4(1+\sqrt{4n-3}) \right \rfloor$</p></blockquote><p>令点集$V={1，2，…，n}$，用于双计数的集合为$S=\{(u,\{v,w\})|u与v,w都邻接，且v≠w\}$，即对下图中的结构进行计数。</p><div align="center">    <img src="/img/0607-1.png" style="zoom:33%;"></div><p>固定$u$,那么$v$和$w$只能在度为$d(u)$的点中选取，即$\binom{d(u)}{2}$，有$\sum _{u\in V}\binom{d(u)}{2}=|S|$；</p><p>固定$v$和$w$，最多只有一个点可以和它们都关联，那么有$\binom{n}{2}\geq |S|$，</p><p>那么，$\sum _{u\in V}d^2(u)\leq \sum _{u\in V}d(u)+n(n-1)$,</p><blockquote><p>柯西—施瓦茨不等式，$|(\alpha ,\beta )|\leq ||\alpha ||*||\beta ||$</p><p>上述不等式中对应的分别是$[d(u_1),d(u_2)….d(u_n)]$，$(1,1,…1)$。</p></blockquote><p>由柯西—施瓦茨不等式得，$n\sum_{u\in V}d^2(n)\geq (\sum_{u\in V}d(n)*1)^2$，代入上式，$\frac{(\sum_{u\in V} d(u))^2}{n}\leq \sum_{u\in V}d(u)+n)n-1$，</p><p>由握手定理得$4|E|^2\leq n2|E|+n^2(n-1)$，求解n可得上述结论。</p><h2 id="三计数"><a href="#三计数" class="headerlink" title="三计数"></a>三计数</h2><blockquote><p>在超图中，有</p><script type="math/tex; mode=display">\sum_{x\in X}d^2(x)=\sum_{A\in F} \sum_{x\in A}d(x)=\sum_{A\in F} \sum_{B\in F}|A\cap B|</script></blockquote><p>对于集合$(X,F)$，$X$为点集合，$F$为超边集合，对三元组${(x,A,B)|A,B∈F,x∈A，x∈B}$计数。</p><p>左：$x$在全集$X$上，$A，B$集合均包含点$x$；</p><p>中：先选出在$A$的$x$，再使得$x$在$B$中；</p><p>右：先选出$A$和$B$集合，使得$x$在$A$和$B$上，即在$A\cap B$上。</p><h2 id="整除关系"><a href="#整除关系" class="headerlink" title="整除关系"></a>整除关系</h2><blockquote><p>假设两个有限集$R$和$C$和一个子集$S\subseteq R\times C$。无论何时$(p，g)∈s $那么认为$p$和$q$是关联的。</p><p>设$r_p$表示$p$固定，与$p$关联的元素数目；$c_p$表示$q$固定，与$q$关联的元素数目。有</p><script type="math/tex; mode=display">\sum_{p\in R}r_p=|S|=\sum_{q\in C}c_q</script></blockquote><p>假设$M_{|p|\times |q|}$的关联矩阵使用双计数进行证明，矩阵中若$p_i$和$q_j$相关联，$a_{ij}$则置为$1$，否则为$0$，那么$|S|$就是矩阵$M$中全部$1$的个数，等式的第一项可从行计数，最后一项可从列计数角度统计矩阵中1的个数。</p><p>例：</p><p>$R=C={1，2，…，n}$，集合$S=\{(i,j)|i可以整除j\}$，</p><p>$t(j)$表示$j$的因子的数目，如$j=4$，因子有$1,2,4$，那么$t(4)=3$。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i/j</th><th style="text-align:center">1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"></td><td>1</td><td></td><td>1</td><td></td><td>1</td><td></td><td>1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"></td><td></td><td>1</td><td></td><td></td><td>1</td><td></td><td></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"></td><td></td><td></td><td>1</td><td></td><td></td><td></td><td>1</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center"></td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center"></td><td></td><td></td><td></td><td></td><td>1</td><td></td><td></td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"></td><td></td><td></td><td></td><td></td><td></td><td>1</td><td></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"></td><td></td><td></td><td></td><td></td><td></td><td></td><td>1</td></tr></tbody></table></div><script type="math/tex; mode=display">\overline{t(j)}=\frac{1}{n}\sum_{j=1}^{n}t(j)=\frac{1}{n}\sum_{i=1}^{n}\left \lfloor n/i \right \rfloor</script><script type="math/tex; mode=display">\frac{1}{n}\sum_{i=1}^{n}(\frac{n}{j}-1)<\frac{1}{n}\sum_{i=1}^{n}\left \lfloor n/i \right \rfloor\leq \frac{1}{n}\sum_{i=1}^{n}\frac{n}{i}=\sum_{i=1}^{n}\frac{1}{i}</script><script type="math/tex; mode=display">\sum_{i=1}^{n}\frac{1}{i}-1 < t(j) \leq lnn</script><script type="math/tex; mode=display">|\overline{t(j)}-lnn|<1</script><h2 id="Sperner-Lemma"><a href="#Sperner-Lemma" class="headerlink" title="Sperner Lemma"></a>Sperner Lemma</h2><blockquote><p>假设某个顶点为$V1、V2、V3$的“大”三角形被三角化了(也就是说，被分解成有限数量的“小”三角形，这些“小”三角形每条边都能拼接在一起)。</p><p>假设三角化中的顶点从集合$\{1,2,3\}$中获取颜色，使得$V_i$接收颜色$i$(对于每个$i$)，并且沿着$V_i$到$V_i$的边的顶点只用$i$和$j$的颜色，而内部顶点用1、2或3的颜色任意着色。那么在三角测量中一定有一个小的“三色”三角形。</p></blockquote><div align="center">    <img src="/img/0607-3.png"></div><p><strong>证明：</strong></p><p>假定大三角形外部有一点$A$，每一个小三角形中心都有一个顶点$O$，若小三角形含有1，2顶点，则从$O$经过1，2点构成的边形成一条边(即出度)，如下图</p><div align="center">    <img src="/img/0607-4.png"></div><p>根据握手定理可知，度之和必为偶数， 在$V_1$和$V_2$构成的边上，观察可得出度必为奇数，即边上(1,2).(2,1)的线段必有奇数个，那么在小三角形必存在奇数度的三角形，即必存在1度的三角形，得证。</p><p>参考：<a href="https://www.it610.com/article/1295411404924329984.htm">【图论学习笔记二】双计数(Double Counting) - it610.com</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;双计数狭义上讲，对于一个集合运用两种不同的方式（行 / 列），得到等式结果或者不等式的结果。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="图与网络" scheme="https://aoif-hikari.github.io/tags/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://aoif-hikari.github.io/2021/07/06/hello-world/"/>
    <id>https://aoif-hikari.github.io/2021/07/06/hello-world/</id>
    <published>2021-07-06T01:59:35.000Z</published>
    <updated>2021-07-07T10:01:34.307Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a></p></blockquote><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
